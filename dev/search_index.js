var documenterSearchIndex = {"docs":
[{"location":"api/analysis/#Analysis-API","page":"Analysis API","title":"Analysis API","text":"Analysis tools for computing diagnostics, managing output, and monitoring simulations in real-time.","category":"section"},{"location":"api/analysis/#CFL-Conditions","page":"Analysis API","title":"CFL Conditions","text":"","category":"section"},{"location":"api/analysis/#CFL","page":"Analysis API","title":"CFL","text":"Computes adaptive timesteps based on the Courant-Friedrichs-Lewy (CFL) stability criterion.\n\nConstructor:\n\nCFL(\n    problem::IVP;\n    safety::Float64=0.5,\n    max_change::Float64=2.0,\n    min_change::Float64=0.5,\n    max_dt::Float64=Inf,\n    min_dt::Float64=0.0\n)\n\nArguments:\n\nproblem: IVP problem\nsafety: Safety factor (0 < safety < 1)\nmax_change: Maximum timestep increase factor per step\nmin_change: Maximum timestep decrease factor per step\nmax_dt: Maximum allowed timestep\nmin_dt: Minimum allowed timestep\n\nExamples:\n\n# Standard CFL\ncfl = CFL(problem, safety=0.5)\n\n# Conservative settings\ncfl = CFL(problem, safety=0.3, max_change=1.2, min_change=0.8)\n\n# With timestep bounds\ncfl = CFL(problem, safety=0.5, max_dt=0.01, min_dt=1e-6)\n\nMethods:","category":"section"},{"location":"api/analysis/#add_velocity!","page":"Analysis API","title":"add_velocity!","text":"Add velocity field for CFL calculation.\n\nadd_velocity!(cfl, velocity_field)\n\nExample:\n\ncfl = CFL(problem)\nadd_velocity!(cfl, u)  # u is a VectorField\n\n# For multiple velocity scales\nadd_velocity!(cfl, u)  # Advection velocity\nadd_velocity!(cfl, c)  # Sound speed (for compressible flow)","category":"section"},{"location":"api/analysis/#compute_timestep","page":"Analysis API","title":"compute_timestep","text":"Calculate adaptive timestep.\n\ndt = compute_timestep(cfl)\n\nReturns: Adaptive timestep satisfying CFL condition\n\nExample:\n\nwhile solver.sim_time < t_end\n    dt = compute_timestep(cfl)\n    step!(solver, dt)\nend\n\nCFL Condition:\n\nFor explicit methods:\n\nDelta t leq C fracDelta xu_max\n\nwhere C is the safety factor.\n\nProperties:\n\ncfl.safety          # Safety factor\ncfl.max_dt          # Maximum timestep\ncfl.min_dt          # Minimum timestep\ncfl.current_dt      # Last computed timestep\n\n","category":"section"},{"location":"api/analysis/#Output-Handlers","page":"Analysis API","title":"Output Handlers","text":"","category":"section"},{"location":"api/analysis/#NetCDF-Output","page":"Analysis API","title":"NetCDF Output","text":"","category":"section"},{"location":"api/analysis/#add*netcdf*handler","page":"Analysis API","title":"addnetcdfhandler","text":"Create NetCDF output handler for saving fields to files.\n\nSyntax:\n\nadd_netcdf_handler(\n    solver::InitialValueSolver,\n    base_path::String;\n    fields::Vector{<:AbstractField},\n    write_interval::Float64=1.0,\n    mode::String=\"overwrite\"\n)\n\nArguments:\n\nsolver: IVP solver\nbase_path: Base path for output files (without extension)\nfields: Fields to save\nwrite_interval: Time between writes\nmode: File mode (\"overwrite\", \"append\")\n\nExamples:\n\n# Basic output\nhandler = add_netcdf_handler(\n    solver,\n    \"output/snapshots\",\n    fields=[u, p, T],\n    write_interval=0.1\n)\n\n# Multiple handlers for different cadences\nsnapshots = add_netcdf_handler(solver, \"snapshots\", fields=[u, p, T], write_interval=0.1)\ncheckpoints = add_netcdf_handler(solver, \"checkpoints\", fields=[u, p, T], write_interval=1.0)\n\nOutput files:\n\nCreates files like: snapshots_proc0.nc, snapshots_proc1.nc, etc.\nOne file per MPI process\nUse merge_processor_files to combine\n\n","category":"section"},{"location":"api/analysis/#NetCDFFileHandler","page":"Analysis API","title":"NetCDFFileHandler","text":"Direct handler class for more control.\n\nConstructor:\n\nNetCDFFileHandler(\n    filename::String,\n    fields::Vector{<:AbstractField};\n    write_mode::String=\"overwrite\",\n    compression::Int=4\n)\n\nMethods:\n\n# Write current state\nwrite_fields!(handler, sim_time)\n\n# Close file\nclose!(handler)\n\nExample:\n\nhandler = NetCDFFileHandler(\"output.nc\", [u, p, T], compression=6)\n\nwhile solver.sim_time < t_end\n    step!(solver)\n\n    if solver.iteration % 100 == 0\n        write_fields!(handler, solver.sim_time)\n    end\nend\n\nclose!(handler)\n\n","category":"section"},{"location":"api/analysis/#HDF5-Output","page":"Analysis API","title":"HDF5 Output","text":"","category":"section"},{"location":"api/analysis/#add*hdf5*handler","page":"Analysis API","title":"addhdf5handler","text":"Similar to NetCDF but uses HDF5 format.\n\nSyntax:\n\nadd_hdf5_handler(\n    solver::InitialValueSolver,\n    base_path::String;\n    fields::Vector{<:AbstractField},\n    write_interval::Float64=1.0\n)\n\nExample:\n\nhandler = add_hdf5_handler(\n    solver,\n    \"output/data\",\n    fields=[u, p, T],\n    write_interval=0.1\n)\n\n","category":"section"},{"location":"api/analysis/#Analysis-Evaluators","page":"Analysis API","title":"Analysis Evaluators","text":"","category":"section"},{"location":"api/analysis/#Scalar-Evaluators","page":"Analysis API","title":"Scalar Evaluators","text":"Compute scalar diagnostics during simulation.","category":"section"},{"location":"api/analysis/#add*scalar*evaluator","page":"Analysis API","title":"addscalarevaluator","text":"add_scalar_evaluator(\n    solver::InitialValueSolver,\n    name::String,\n    expression::String\n)\n\nExample:\n\n# Kinetic energy\nadd_scalar_evaluator(solver, \"KE\", \"0.5*integrate(u*u + v*v + w*w)\")\n\n# Enstrophy\nadd_scalar_evaluator(solver, \"enstrophy\", \"0.5*integrate(omega*omega)\")\n\n# Nusselt number\nadd_scalar_evaluator(solver, \"Nu\", \"1 + mean(w*T)\")\n\n# Access values\nKE = get_scalar(solver, \"KE\")\n\n","category":"section"},{"location":"api/analysis/#Field-Evaluators","page":"Analysis API","title":"Field Evaluators","text":"Compute derived fields during simulation.","category":"section"},{"location":"api/analysis/#add*field*evaluator","page":"Analysis API","title":"addfieldevaluator","text":"add_field_evaluator(\n    solver::InitialValueSolver,\n    name::String,\n    expression::String\n)\n\nExample:\n\n# Vorticity\nadd_field_evaluator(solver, \"omega\", \"∂x(v) - ∂z(u)\")\n\n# Q-criterion\nadd_field_evaluator(solver, \"Q\", \"0.5*(Omega*Omega - S*S)\")\n\n# Temperature gradient magnitude\nadd_field_evaluator(solver, \"grad_T_mag\", \"sqrt(∂x(T)^2 + ∂z(T)^2)\")\n\n# Access computed field\nomega = get_field(solver, \"omega\")\n\n","category":"section"},{"location":"api/analysis/#Analysis-Tasks","page":"Analysis API","title":"Analysis Tasks","text":"","category":"section"},{"location":"api/analysis/#Unified-Evaluator","page":"Analysis API","title":"Unified Evaluator","text":"Combine multiple analysis operations.\n\nevaluator = UnifiedEvaluator(solver)\n\n# Add various tasks\nadd_task!(evaluator, \"scalar\", \"KE\", \"0.5*integrate(u*u)\")\nadd_task!(evaluator, \"field\", \"omega\", \"curl(u)\")\nadd_task!(evaluator, \"profile\", \"T_mean\", \"mean(T, dim=1)\")  # Mean over x\n\n# Evaluate all tasks\nevaluate!(evaluator)\n\n# Access results\nKE = evaluator.results[\"KE\"]\nomega = evaluator.results[\"omega\"]\nT_profile = evaluator.results[\"T_mean\"]\n\n","category":"section"},{"location":"api/analysis/#Statistical-Analysis","page":"Analysis API","title":"Statistical Analysis","text":"","category":"section"},{"location":"api/analysis/#Time-Averaging","page":"Analysis API","title":"Time Averaging","text":"# Create time averager\navg = TimeAverager(fields=[u, T], averaging_interval=1.0)\n\n# During simulation\nwhile solver.sim_time < t_end\n    step!(solver)\n    accumulate!(avg, solver.sim_time)\nend\n\n# Get averaged fields\nu_mean = get_average(avg, \"u\")\nT_mean = get_average(avg, \"T\")","category":"section"},{"location":"api/analysis/#Spatial-Averaging","page":"Analysis API","title":"Spatial Averaging","text":"# Mean over dimension\nT_mean_x = mean(T, dim=1)  # Average over x\nu_mean_profile = mean(u, dim=1)  # Velocity profile\n\n# Volume average\nT_vol_avg = mean(T)  # Average over entire domain","category":"section"},{"location":"api/analysis/#Reynolds-Decomposition","page":"Analysis API","title":"Reynolds Decomposition","text":"# Compute fluctuations\nfunction reynolds_decomposition(field, mean_field)\n    fluctuation = field - mean_field\n    return fluctuation\nend\n\n# Example\nu_mean = mean(u, dim=1)\nu_prime = reynolds_decomposition(u, u_mean)\n\n# Reynolds stresses\nuu_mean = mean(u_prime * u_prime, dim=1)\nuv_mean = mean(u_prime * v_prime, dim=1)\n\n","category":"section"},{"location":"api/analysis/#Spectral-Analysis","page":"Analysis API","title":"Spectral Analysis","text":"","category":"section"},{"location":"api/analysis/#Energy-Spectra","page":"Analysis API","title":"Energy Spectra","text":"# 1D energy spectrum\nfunction compute_energy_spectrum_1d(u, direction)\n    # Transform to spectral space\n    to_spectral!(u)\n    u_hat = get_spectral_data(u)\n\n    # Compute energy\n    E = abs2.(u_hat)\n\n    # Bin by wavenumber magnitude\n    k, E_k = bin_spectrum(E, direction)\n\n    return k, E_k\nend\n\n# Usage\nk, E_k = compute_energy_spectrum_1d(u, 1)  # Spectrum in x-direction\n\n# Plot\nusing Plots\nplot(k, E_k, xscale=:log10, yscale=:log10,\n     xlabel=\"k\", ylabel=\"E(k)\")","category":"section"},{"location":"api/analysis/#3D-Isotropic-Spectrum","page":"Analysis API","title":"3D Isotropic Spectrum","text":"function compute_isotropic_spectrum(u)\n    # Compute 3D energy distribution\n    to_spectral!(u)\n\n    E_hat = sum(abs2.(component) for component in u.components)\n\n    # Bin by |k|\n    k_mag = compute_k_magnitude(domain)\n    k, E_k = spherical_average(E_hat, k_mag)\n\n    return k, E_k\nend\n\n# Kolmogorov scaling check\nk, E_k = compute_isotropic_spectrum(u)\nplot(k, E_k, xscale=:log10, yscale=:log10)\nplot!(k, k.^(-5/3), linestyle=:dash, label=\"k^(-5/3)\")\n\n","category":"section"},{"location":"api/analysis/#Flow-Property-Analysis","page":"Analysis API","title":"Flow Property Analysis","text":"","category":"section"},{"location":"api/analysis/#Nusselt-Number","page":"Analysis API","title":"Nusselt Number","text":"Heat transfer efficiency in convection:\n\nfunction compute_nusselt(T, w, domain)\n    # Nu = 1 + <w*T> (horizontally averaged)\n    to_grid!(T)\n    to_grid!(w)\n\n    wT = w.data .* T.data\n    wT_mean = mean(wT, dims=1)  # Average over x\n\n    Nu = 1.0 .+ wT_mean\n    return mean(Nu)  # Domain average\nend","category":"section"},{"location":"api/analysis/#Reynolds-Number","page":"Analysis API","title":"Reynolds Number","text":"From velocity statistics:\n\nfunction compute_reynolds_number(u, nu, L)\n    # Re = U*L/nu\n    to_grid!(u)\n    U = sqrt(mean(u.data .^ 2))  # RMS velocity\n    Re = U * L / nu\n    return Re\nend","category":"section"},{"location":"api/analysis/#Richardson-Number","page":"Analysis API","title":"Richardson Number","text":"Stratification vs. shear:\n\nfunction compute_richardson_number(u, T, dz, g, T0)\n    # Ri = (g/T0) * (∂T/∂z) / (∂u/∂z)^2\n    dTdz = ∂z(T)\n    dudz = ∂z(u)\n\n    to_grid!(dTdz)\n    to_grid!(dudz)\n\n    Ri = (g / T0) .* dTdz.data ./ (dudz.data .^ 2)\n    return mean(Ri)\nend\n\n","category":"section"},{"location":"api/analysis/#Probe-Points","page":"Analysis API","title":"Probe Points","text":"Sample fields at specific locations.\n\n# Define probe locations\nprobes = ProbeSet([\n    (\"probe1\", x=1.0, z=0.5),\n    (\"probe2\", x=2.0, z=0.5),\n    (\"probe3\", x=3.0, z=0.5)\n])\n\n# Sample during simulation\nwhile solver.sim_time < t_end\n    step!(solver)\n\n    if solver.iteration % 10 == 0\n        sample_probes!(probes, [u, T], solver.sim_time)\n    end\nend\n\n# Get time series\nu_probe1 = get_probe_data(probes, \"probe1\", \"u\")\nt_series = get_probe_times(probes)\n\n# Plot\nplot(t_series, u_probe1, xlabel=\"t\", ylabel=\"u\", label=\"Probe 1\")\n\n","category":"section"},{"location":"api/analysis/#Monitoring-and-Diagnostics","page":"Analysis API","title":"Monitoring and Diagnostics","text":"","category":"section"},{"location":"api/analysis/#Simulation-Monitoring","page":"Analysis API","title":"Simulation Monitoring","text":"# Create monitor\nmonitor = SimulationMonitor(\n    print_interval=100,\n    print_fields=true,\n    print_diagnostics=true\n)\n\n# Add to solver\nattach_monitor!(solver, monitor)\n\n# Automatically prints during simulation:\n# Iteration: 100, t = 0.100, dt = 0.001, KE = 1.234, max(u) = 2.345","category":"section"},{"location":"api/analysis/#Custom-Diagnostics","page":"Analysis API","title":"Custom Diagnostics","text":"function my_diagnostics(solver, fields)\n    u, T = fields\n\n    # Compute custom quantities\n    KE = 0.5 * mean(u.data .^ 2)\n    max_T = maximum(T.data)\n    min_T = minimum(T.data)\n\n    return Dict(\n        \"KE\" => KE,\n        \"T_max\" => max_T,\n        \"T_min\" => min_T\n    )\nend\n\n# Register diagnostic\nadd_diagnostic!(solver, my_diagnostics, interval=10)\n\n","category":"section"},{"location":"api/analysis/#Data-Post-Processing","page":"Analysis API","title":"Data Post-Processing","text":"","category":"section"},{"location":"api/analysis/#Merging-Parallel-Output","page":"Analysis API","title":"Merging Parallel Output","text":"After simulation with MPI:\n\n# Merge NetCDF files from all ranks\nusing Tarang.IO\n\nmerge_netcdf_files(\n    \"output/snapshots\",\n    output_file=\"output/snapshots_merged.nc\",\n    cleanup=true  # Remove individual rank files\n)","category":"section"},{"location":"api/analysis/#Loading-Data","page":"Analysis API","title":"Loading Data","text":"using NCDatasets\n\n# Load merged data\nds = Dataset(\"output/snapshots_merged.nc\")\n\n# Access fields\nu_data = ds[\"u\"][:]\nT_data = ds[\"T\"][:]\ntime = ds[\"time\"][:]\n\nclose(ds)\n\n# Analyze or visualize\nusing Plots\nheatmap(T_data[:, :, end], title=\"Temperature at t=$(time[end])\")\n\n","category":"section"},{"location":"api/analysis/#Complete-Example","page":"Analysis API","title":"Complete Example","text":"using Tarang, MPI\n\nMPI.Init()\n\n# ... setup problem and solver ...\n\n# CFL condition\ncfl = CFL(problem, safety=0.5, max_dt=0.01)\nadd_velocity!(cfl, u)\n\n# Output handlers\nsnapshots = add_netcdf_handler(solver, \"snapshots\",\n                                fields=[u, p, T], write_interval=0.1)\n\n# Scalar diagnostics\nadd_scalar_evaluator(solver, \"KE\", \"0.5*integrate(u*u + w*w)\")\nadd_scalar_evaluator(solver, \"Nu\", \"1 + mean(w*T)\")\n\n# Monitoring\nmonitor = SimulationMonitor(print_interval=100)\nattach_monitor!(solver, monitor)\n\n# Time integration\nwhile solver.sim_time < 10.0\n    dt = compute_timestep(cfl)\n    step!(solver, dt)\n\n    # Custom analysis every 1000 steps\n    if solver.iteration % 1000 == 0\n        KE = get_scalar(solver, \"KE\")\n        Nu = get_scalar(solver, \"Nu\")\n\n        if MPI.Comm_rank(MPI.COMM_WORLD) == 0\n            println(\"t=$(solver.sim_time): KE=$KE, Nu=$Nu\")\n        end\n    end\nend\n\n# Merge output files\nif MPI.Comm_rank(MPI.COMM_WORLD) == 0\n    merge_netcdf_files(\"snapshots\", output_file=\"snapshots.nc\", cleanup=true)\nend\n\nMPI.Finalize()\n\n","category":"section"},{"location":"api/analysis/#See-Also","page":"Analysis API","title":"See Also","text":"Solvers: Integration methods\nFields: Field operations for analysis\nTutorial: Analysis: Detailed examples","category":"section"},{"location":"api/bases/#Bases-API","page":"Bases API","title":"Bases API","text":"Spectral bases define how functions are represented in each coordinate direction. Tarang.jl provides Fourier, Chebyshev, and Legendre bases for different boundary conditions.","category":"section"},{"location":"api/bases/#Docstrings","page":"Bases API","title":"Docstrings","text":"","category":"section"},{"location":"api/bases/#Overview","page":"Bases API","title":"Overview","text":"Each coordinate dimension requires a spectral basis that determines:\n\nRepresentation: How functions are expanded (Fourier series, polynomial series, etc.)\nBoundary conditions: Periodic, non-periodic, or special constraints\nGrid points: Where functions are evaluated (collocation points)\nDerivatives: How differentiation is computed in spectral space","category":"section"},{"location":"api/bases/#Basis-Selection-Guide","page":"Bases API","title":"Basis Selection Guide","text":"Basis Type Use Case Boundary Conditions Grid Points\nRealFourier Periodic, real-valued data Periodic Uniform\nComplexFourier Periodic, complex data Periodic Uniform\nChebyshevT Bounded, smooth Dirichlet/Neumann Gauss-Lobatto\nChebyshevU Bounded, special BCs Custom Gauss\nLegendre Bounded, alternative Dirichlet/Neumann Gauss-Lobatto\n\n","category":"section"},{"location":"api/bases/#Fourier-Bases","page":"Bases API","title":"Fourier Bases","text":"","category":"section"},{"location":"api/bases/#RealFourier","page":"Bases API","title":"RealFourier","text":"Real-valued Fourier basis for periodic coordinates with real data.\n\nConstructor:\n\nRealFourier(\n    coord::Coordinate;\n    size::Int,\n    bounds::Tuple{Float64,Float64},\n    dealias::Float64=1.0\n)\n\nArguments:\n\ncoord: Coordinate object for this direction\nsize: Number of modes (must be even for real Fourier)\nbounds: Domain boundaries (min, max)\ndealias: Dealiasing factor (default 1.0 = no dealiasing, 2/3 for 3/2 rule)\n\nExamples:\n\ncoords = CartesianCoordinates(\"x\")\nx = coords[\"x\"]\n\n# Basic real Fourier basis\nbasis = RealFourier(x, size=128, bounds=(0.0, 2π))\n\n# With dealiasing (3/2 rule)\nbasis = RealFourier(x, size=128, bounds=(0.0, 2π), dealias=2/3)\n\n# Custom domain length\nbasis = RealFourier(x, size=256, bounds=(0.0, 4.0))\n\nProperties:\n\nbasis.coord         # Coordinate\nbasis.size          # Number of modes\nbasis.bounds        # (min, max)\nbasis.length        # Domain length (max - min)\nbasis.dealias       # Dealiasing factor\nbasis.grid_size     # Number of grid points\n\nGrid Points:\n\n# Get grid points (uniform spacing)\ngrid = get_grid(basis)\n# Returns: [0.0, Δx, 2Δx, ..., L-Δx]\n\n# Grid spacing\nΔx = basis.length / basis.grid_size\n\nWavenumbers:\n\n# Get wavenumber array\nk = get_wavenumbers(basis)\n# Returns: [0, 1, 2, ..., N/2-1, -N/2, ..., -1] * (2π/L)\n\n# Fundamental wavenumber\nk0 = 2π / basis.length\n\nMemory Savings: RealFourier uses real-to-complex FFT, saving ~50% memory compared to ComplexFourier.\n\n","category":"section"},{"location":"api/bases/#ComplexFourier","page":"Bases API","title":"ComplexFourier","text":"Complex-valued Fourier basis for periodic coordinates.\n\nConstructor:\n\nComplexFourier(\n    coord::Coordinate;\n    size::Int,\n    bounds::Tuple{Float64,Float64},\n    dealias::Float64=1.0\n)\n\nArguments: Same as RealFourier\n\nExamples:\n\ncoords = CartesianCoordinates(\"x\")\nx = coords[\"x\"]\n\n# Complex Fourier basis\nbasis = ComplexFourier(x, size=128, bounds=(0.0, 2π))\n\nUse Cases:\n\nComplex-valued fields (e.g., quantum mechanics)\nIncompatible with RealFourier optimizations\nMore general but uses more memory\n\nWavenumbers:\n\nk = get_wavenumbers(basis)\n# Returns: [0, 1, 2, ..., N-1] * (2π/L)\n\n","category":"section"},{"location":"api/bases/#Chebyshev-Bases","page":"Bases API","title":"Chebyshev Bases","text":"","category":"section"},{"location":"api/bases/#ChebyshevT","page":"Bases API","title":"ChebyshevT","text":"Chebyshev polynomials of the first kind for bounded, non-periodic coordinates.\n\nConstructor:\n\nChebyshevT(\n    coord::Coordinate;\n    size::Int,\n    bounds::Tuple{Float64,Float64}\n)\n\nArguments:\n\ncoord: Coordinate object\nsize: Number of modes (polynomial degree + 1)\nbounds: Domain boundaries (min, max)\n\nExamples:\n\ncoords = CartesianCoordinates(\"z\")\nz = coords[\"z\"]\n\n# Chebyshev basis for vertical direction\nbasis = ChebyshevT(z, size=64, bounds=(0.0, 1.0))\n\n# Larger domain\nbasis = ChebyshevT(z, size=128, bounds=(-1.0, 1.0))\n\nProperties:\n\nbasis.coord         # Coordinate\nbasis.size          # Number of modes\nbasis.bounds        # (min, max)\nbasis.length        # Domain length\nbasis.grid_size     # Number of grid points\n\nGrid Points (Gauss-Lobatto):\n\n# Get Chebyshev-Gauss-Lobatto points\ngrid = get_grid(basis)\n# Points clustered near boundaries for better resolution\n\n# In canonical [-1, 1] domain:\n# ξ_i = cos(π*i / (N-1)) for i = 0, 1, ..., N-1\n\n# Mapped to physical domain [a, b]:\n# x_i = (a + b)/2 + (b - a)/2 * ξ_i\n\nPolynomial Expansion:\n\nFunctions are expanded as:\n\nf(x) = sum_n=0^N-1 a_n T_n(x)\n\nwhere T_n(x) is the nth Chebyshev polynomial.\n\nBoundary Conditions:\n\nValues at boundaries are grid points (includes endpoints)\nWell-suited for Dirichlet boundary conditions\nCan handle Neumann conditions with tau method\n\n","category":"section"},{"location":"api/bases/#ChebyshevU","page":"Bases API","title":"ChebyshevU","text":"Chebyshev polynomials of the second kind.\n\nConstructor:\n\nChebyshevU(\n    coord::Coordinate;\n    size::Int,\n    bounds::Tuple{Float64,Float64}\n)\n\nUse Cases:\n\nSpecific boundary condition types\nAlternative to ChebyshevT for some problems\nLess commonly used than ChebyshevT\n\nGrid Points (Gauss):\n\n# Chebyshev-Gauss points (excludes endpoints)\ngrid = get_grid(basis)\n# ξ_i = cos(π*(i+1/2) / N) for i = 0, 1, ..., N-1\n\n","category":"section"},{"location":"api/bases/#Legendre-Basis","page":"Bases API","title":"Legendre Basis","text":"","category":"section"},{"location":"api/bases/#Legendre","page":"Bases API","title":"Legendre","text":"Legendre polynomials for bounded coordinates.\n\nConstructor:\n\nLegendre(\n    coord::Coordinate;\n    size::Int,\n    bounds::Tuple{Float64,Float64}\n)\n\nArguments: Same as ChebyshevT\n\nExamples:\n\ncoords = CartesianCoordinates(\"z\")\nz = coords[\"z\"]\n\n# Legendre basis\nbasis = Legendre(z, size=64, bounds=(0.0, 1.0))\n\nGrid Points (Gauss-Lobatto):\n\n# Legendre-Gauss-Lobatto points\ngrid = get_grid(basis)\n# Points include endpoints, clustered at boundaries\n\nPolynomial Expansion:\n\nFunctions are expanded as:\n\nf(x) = sum_n=0^N-1 a_n P_n(x)\n\nwhere P_n(x) is the nth Legendre polynomial.\n\nComparison with Chebyshev:\n\nSimilar accuracy and convergence properties\nDifferent grid point distribution\nChoice often based on problem-specific considerations\nLegendre may be preferred for some weight functions\n\n","category":"section"},{"location":"api/bases/#Compound-Bases","page":"Bases API","title":"Compound Bases","text":"For multi-dimensional problems, combine bases for each direction.\n\nExample: 2D Rayleigh-Bénard:\n\ncoords = CartesianCoordinates(\"x\", \"z\")\n\n# Periodic horizontal direction\nx_basis = RealFourier(coords[\"x\"], size=256, bounds=(0.0, 4.0))\n\n# Bounded vertical direction with walls\nz_basis = ChebyshevT(coords[\"z\"], size=64, bounds=(0.0, 1.0))\n\n# Create domain with both bases\ndomain = Domain(dist, (x_basis, z_basis))\n\nExample: 3D Channel Flow:\n\ncoords = CartesianCoordinates(\"x\", \"y\", \"z\")\n\n# Streamwise (periodic)\nx_basis = RealFourier(coords[\"x\"], size=256, bounds=(0.0, 2π))\n\n# Spanwise (periodic)\ny_basis = RealFourier(coords[\"y\"], size=128, bounds=(0.0, π))\n\n# Wall-normal (bounded)\nz_basis = ChebyshevT(coords[\"z\"], size=64, bounds=(0.0, 1.0))\n\ndomain = Domain(dist, (x_basis, y_basis, z_basis))\n\n","category":"section"},{"location":"api/bases/#Grid-and-Spectral-Space","page":"Bases API","title":"Grid and Spectral Space","text":"","category":"section"},{"location":"api/bases/#Transforms","page":"Bases API","title":"Transforms","text":"Converting between grid and spectral space:\n\n# Field starts in spectral space\nfield = ScalarField(dist, \"T\", (x_basis, z_basis))\n\n# Transform to grid space\nto_grid!(field)\n\n# Now can evaluate/modify in physical space\ngrid_data = get_grid_data(field)\ngrid_data[10, 20] = 1.0\n\n# Transform back to spectral space\nto_spectral!(field)","category":"section"},{"location":"api/bases/#Grid-Point-Access","page":"Bases API","title":"Grid Point Access","text":"# Get grid points for each basis\nx_grid = get_grid(x_basis)\nz_grid = get_grid(z_basis)\n\n# Create 2D grid\nX = repeat(x_grid, 1, length(z_grid))\nZ = repeat(z_grid', length(x_grid), 1)\n\n# Initialize field on grid\nT_grid = get_grid_data(T)\nfor i in 1:size(T_grid, 1), j in 1:size(T_grid, 2)\n    x, z = X[i,j], Z[i,j]\n    T_grid[i,j] = sin(2π*x) * cos(π*z)\nend\n\n","category":"section"},{"location":"api/bases/#Differentiation","page":"Bases API","title":"Differentiation","text":"Spectral differentiation is computed by applying operators in spectral space.","category":"section"},{"location":"api/bases/#Fourier-Differentiation","page":"Bases API","title":"Fourier Differentiation","text":"For Fourier bases, differentiation is multiplication by ik:\n\nfracddx left(sum a_k e^ikxright) = sum (ik) a_k e^ikx\n\nExample:\n\n# Derivative operator created automatically\n# When you use ∂x(f) in equations\n\nadd_equation!(problem, \"∂x(u) = f\")","category":"section"},{"location":"api/bases/#Chebyshev-Differentiation","page":"Bases API","title":"Chebyshev Differentiation","text":"For Chebyshev bases, differentiation uses recurrence relations:\n\nfracdT_ndx = n U_n-1(x)\n\nImplemented as sparse matrix multiplication in spectral space.\n\nExample:\n\n# Vertical derivative with Chebyshev basis\nadd_equation!(problem, \"∂z(T) = 0\")\n\n","category":"section"},{"location":"api/bases/#Dealiasing","page":"Bases API","title":"Dealiasing","text":"Dealiasing prevents aliasing errors in nonlinear terms.","category":"section"},{"location":"api/bases/#The-3/2-Rule","page":"Bases API","title":"The 3/2 Rule","text":"Most common dealiasing strategy for spectral methods:\n\n# Enable 3/2 dealiasing\nbasis = RealFourier(x, size=128, bounds=(0.0, 2π), dealias=2/3)\n\n# This pads the grid by 3/2 during nonlinear term evaluation\n# Grid size: 128 * 3/2 = 192 points\n# Retains only 128 modes after multiplication","category":"section"},{"location":"api/bases/#When-to-Dealias","page":"Bases API","title":"When to Dealias","text":"Always: For products of fields (e.g., u*∂x(u))\nOptional: For linear problems\nRecommend: 3/2 rule for most problems\nHigher: 2/1 padding for very nonlinear problems\n\nConfiguration:\n\n[transforms]\nDEALIAS_BEFORE_CONVERTING = true\n\n","category":"section"},{"location":"api/bases/#Resolution-Guidelines","page":"Bases API","title":"Resolution Guidelines","text":"","category":"section"},{"location":"api/bases/#Fourier-Bases-2","page":"Bases API","title":"Fourier Bases","text":"Rule of thumb: Resolve smallest scales in the flow\n\n# Estimate from physical parameters\nL = 2π          # Domain length\nη = (ν^3/ε)^(1/4)  # Kolmogorov scale\nN = L / η        # Required modes\n\n# Practical examples\n# Low Re flow: 64-128 modes\n# Moderate Re: 256-512 modes\n# High Re/turbulent: 1024+ modes","category":"section"},{"location":"api/bases/#Chebyshev/Legendre-Bases","page":"Bases API","title":"Chebyshev/Legendre Bases","text":"Exponential convergence for smooth functions:\n\n# Smooth flows: 32-64 modes\n# Boundary layers: 64-128 modes\n# Steep gradients: 128-256 modes\n\n# Example: Rayleigh-Bénard at Ra=10^6\nz_basis = ChebyshevT(z, size=64, bounds=(0.0, 1.0))\n\n","category":"section"},{"location":"api/bases/#Advanced-Topics","page":"Bases API","title":"Advanced Topics","text":"","category":"section"},{"location":"api/bases/#Custom-Grid-Sizes","page":"Bases API","title":"Custom Grid Sizes","text":"# Manually specify grid size (for custom padding)\nbasis = RealFourier(x, size=128, bounds=(0.0, 2π))\nbasis.grid_size = 192  # 3/2 padding","category":"section"},{"location":"api/bases/#Basis-Algebra","page":"Bases API","title":"Basis Algebra","text":"# Check compatibility\nis_compatible(basis1, basis2)\n\n# Get combined grid\ncombined_grid = get_combined_grid([basis1, basis2])","category":"section"},{"location":"api/bases/#Spectral-Accuracy","page":"Bases API","title":"Spectral Accuracy","text":"# Estimate spectral coefficients decay\ncoeffs = get_spectral_data(field)\ndecay = abs.(coeffs)\n\n# Plot to check resolution\nusing Plots\nplot(decay, yscale=:log10,\n     xlabel=\"Mode\", ylabel=\"Coefficient magnitude\")\n\n","category":"section"},{"location":"api/bases/#Performance-Considerations","page":"Bases API","title":"Performance Considerations","text":"Power-of-2 sizes: Use N = 2^m for fastest FFTs\nMemory alignment: FFTW performs best with aligned arrays\nFFTW planning: Use FFTWMEASURE or FFTWPATIENT for optimal plans\nGrid size: Larger grids = more memory, slower transforms\nDealiasing: Increases computational cost by ~50%\n\n","category":"section"},{"location":"api/bases/#See-Also","page":"Bases API","title":"See Also","text":"Coordinates: Coordinate systems for bases\nDomains: Combining bases into domains\nFields: Creating fields on bases\nOperators: Differential operators","category":"section"},{"location":"api/bases/#Tarang.RealFourier","page":"Bases API","title":"Tarang.RealFourier","text":"RealFourier <: FourierBasis\n\nReal Fourier sine/cosine basis (msin = -sin convention). Modes: [cos(0x), cos(1x), -sin(1x), cos(2x), -sin(2*x), ...]\n\n\n\n\n\n","category":"type"},{"location":"api/bases/#Tarang.ComplexFourier","page":"Bases API","title":"Tarang.ComplexFourier","text":"ComplexFourier <: FourierBasis\n\nComplex Fourier exponential basis. Modes: [exp(i0x), exp(i1x), exp(-i1x), exp(i2x), exp(-i2x), ...]\n\n\n\n\n\n","category":"type"},{"location":"api/bases/#Tarang.ChebyshevT","page":"Bases API","title":"Tarang.ChebyshevT","text":"ChebyshevT <: JacobiBasis\n\nChebyshev polynomials of the first kind T_n(x). Equivalent to Ultraspherical(alpha=0) or Jacobi(a=-1/2, b=-1/2).\n\n\n\n\n\n","category":"type"},{"location":"api/bases/#Tarang.ChebyshevU","page":"Bases API","title":"Tarang.ChebyshevU","text":"ChebyshevU <: JacobiBasis\n\nChebyshev polynomials of the second kind U_n(x). Equivalent to Ultraspherical(alpha=1) or Jacobi(a=1/2, b=1/2).\n\n\n\n\n\n","category":"type"},{"location":"api/bases/#Tarang.Legendre","page":"Bases API","title":"Tarang.Legendre","text":"Legendre <: JacobiBasis\n\nLegendre polynomial basis P_n(x). Equivalent to Jacobi(a=0, b=0).\n\n\n\n\n\n","category":"type"},{"location":"api/fields/#Fields-API","page":"Fields API","title":"Fields API","text":"Fields represent variables in your PDE system. Tarang.jl provides scalar, vector, and tensor fields distributed across MPI processes.","category":"section"},{"location":"api/fields/#ScalarField","page":"Fields API","title":"ScalarField","text":"","category":"section"},{"location":"api/fields/#Constructor","page":"Fields API","title":"Constructor","text":"ScalarField(\n    distributor::Distributor,\n    name::String,\n    bases::Tuple\n) -> ScalarField\n\nArguments:\n\ndistributor: MPI distributor managing parallel decomposition\nname: Field name (used in equations and output)\nbases: Tuple of spectral bases, one per dimension\n\nExample:\n\ncoords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords, mesh=(2, 2))\n\nx_basis = RealFourier(coords[\"x\"], size=128, bounds=(0.0, 2π))\nz_basis = ChebyshevT(coords[\"z\"], size=64, bounds=(0.0, 1.0))\n\nT = ScalarField(dist, \"temperature\", (x_basis, z_basis))","category":"section"},{"location":"api/fields/#Methods","page":"Fields API","title":"Methods","text":"","category":"section"},{"location":"api/fields/#Data-Access","page":"Fields API","title":"Data Access","text":"# Get spectral-space data (distributed PencilArray)\nspectral_data = get_spectral_data(field)\n\n# Get grid-space data (for evaluation/initial conditions)\ngrid_data = get_grid_data(field)\n\n# Get local portion of data on this MPI rank\nlocal_data = field.data","category":"section"},{"location":"api/fields/#Space-Transforms","page":"Fields API","title":"Space Transforms","text":"# Transform from grid to spectral space\nto_spectral!(field)\n\n# Transform from spectral to grid space\nto_grid!(field)\n\n# Check current space\nis_in_spectral_space(field)  # returns Bool\nis_in_grid_space(field)      # returns Bool","category":"section"},{"location":"api/fields/#Field-Operations","page":"Fields API","title":"Field Operations","text":"# Set all values\nfill!(field, value)\n\n# Copy between fields\ncopy!(dest_field, src_field)\n\n# Scale field\nscale!(field, factor)\n\n# Add fields: field1 = field1 + alpha * field2\naxpy!(alpha, field2, field1)","category":"section"},{"location":"api/fields/#Properties","page":"Fields API","title":"Properties","text":"field.name          # String: Field name\nfield.bases         # Tuple: Spectral bases\nfield.data          # PencilArray: Distributed data\nfield.space         # Symbol: :spectral or :grid\nfield.distributor   # Distributor: MPI distribution","category":"section"},{"location":"api/fields/#VectorField","page":"Fields API","title":"VectorField","text":"","category":"section"},{"location":"api/fields/#Constructor-2","page":"Fields API","title":"Constructor","text":"VectorField(\n    distributor::Distributor,\n    coords::Coordinates,\n    name::String,\n    bases::Tuple\n) -> VectorField\n\nArguments:\n\ndistributor: MPI distributor\ncoords: Coordinate system (determines vector dimensionality)\nname: Base name for vector components\nbases: Spectral bases tuple\n\nExample:\n\ncoords = CartesianCoordinates(\"x\", \"y\", \"z\")\ndist = Distributor(coords, mesh=(2, 2, 2))\n\nbases = (\n    RealFourier(coords[\"x\"], size=128, bounds=(0.0, 2π)),\n    RealFourier(coords[\"y\"], size=128, bounds=(0.0, 2π)),\n    ChebyshevT(coords[\"z\"], size=64, bounds=(0.0, 1.0))\n)\n\n# Creates velocity vector u = (u_x, u_y, u_z)\nu = VectorField(dist, coords, \"u\", bases)\n\n# Access components\nux = u.components[1]  # x-component\nuy = u.components[2]  # y-component\nuz = u.components[3]  # z-component","category":"section"},{"location":"api/fields/#Methods-2","page":"Fields API","title":"Methods","text":"","category":"section"},{"location":"api/fields/#Component-Access","page":"Fields API","title":"Component Access","text":"# Get specific component\nux = u.components[1]\nuy = u[2]  # Alternative indexing\n\n# Iterate over components\nfor component in u.components\n    # ... operate on each component\nend","category":"section"},{"location":"api/fields/#Vector-Operations","page":"Fields API","title":"Vector Operations","text":"# Magnitude (in grid space)\nto_grid!(u)\nmag = sqrt.(sum(c.data.^2 for c in u.components))\n\n# Dot product: a · b\nfunction dot_product(a::VectorField, b::VectorField)\n    sum(ac.data .* bc.data for (ac, bc) in zip(a.components, b.components))\nend\n\n# Cross product (3D only): a × b\nc = cross(a, b)  # or: c = a × b","category":"section"},{"location":"api/fields/#Properties-2","page":"Fields API","title":"Properties","text":"u.name          # String: Base name\nu.components    # Vector{ScalarField}: Vector components\nu.coords        # Coordinates: Coordinate system\nu.ndim          # Int: Number of dimensions","category":"section"},{"location":"api/fields/#TensorField","page":"Fields API","title":"TensorField","text":"","category":"section"},{"location":"api/fields/#Constructor-3","page":"Fields API","title":"Constructor","text":"TensorField(\n    distributor::Distributor,\n    coords::Coordinates,\n    name::String,\n    bases::Tuple;\n    symmetric=false\n) -> TensorField\n\nArguments:\n\ndistributor: MPI distributor\ncoords: Coordinate system\nname: Base name for tensor components\nbases: Spectral bases tuple\nsymmetric: If true, only store upper triangular part\n\nExample:\n\n# Stress tensor τ (symmetric)\ntau = TensorField(dist, coords, \"tau\", bases, symmetric=true)\n\n# Velocity gradient tensor ∇u (not symmetric)\ngrad_u = TensorField(dist, coords, \"grad_u\", bases, symmetric=false)","category":"section"},{"location":"api/fields/#Methods-3","page":"Fields API","title":"Methods","text":"","category":"section"},{"location":"api/fields/#Component-Access-2","page":"Fields API","title":"Component Access","text":"# Get component (i,j)\ntau_xx = tensor[1, 1]\ntau_xy = tensor[1, 2]\n\n# For symmetric tensors, tau[i,j] == tau[j,i]","category":"section"},{"location":"api/fields/#Field-Initialization","page":"Fields API","title":"Field Initialization","text":"","category":"section"},{"location":"api/fields/#From-Function","page":"Fields API","title":"From Function","text":"# Initialize scalar field\nfunction init_temperature!(T, Lx, Lz)\n    T_grid = get_grid_data(T)\n\n    for i in 1:size(T_grid, 1), j in 1:size(T_grid, 2)\n        x = (i-1) * Lx / size(T_grid, 1)\n        z = (j-1) * Lz / size(T_grid, 2)\n\n        T_grid[i, j] = sin(2π * x / Lx) * cos(π * z / Lz)\n    end\n\n    to_spectral!(T)\nend\n\ninit_temperature!(T, 2π, 1.0)","category":"section"},{"location":"api/fields/#Random-Perturbations","page":"Fields API","title":"Random Perturbations","text":"using Random\n\nfunction add_random_perturbation!(field, amplitude=0.01)\n    data = get_grid_data(field)\n\n    # Different seed per MPI rank\n    Random.seed!(42 + MPI.Comm_rank(MPI.COMM_WORLD))\n\n    data .+= amplitude .* (rand(size(data)...) .- 0.5)\n\n    to_spectral!(field)\nend\n\nadd_random_perturbation!(T, 0.01)","category":"section"},{"location":"api/fields/#From-Array","page":"Fields API","title":"From Array","text":"# Set from existing array\nT_grid = get_grid_data(T)\nT_grid .= my_data_array\n\nto_spectral!(T)","category":"section"},{"location":"api/fields/#Field-I/O","page":"Fields API","title":"Field I/O","text":"","category":"section"},{"location":"api/fields/#Saving-Fields","page":"Fields API","title":"Saving Fields","text":"using HDF5\n\nfunction save_field(field, filename)\n    # Ensure in grid space\n    to_grid!(field)\n\n    # Gather to root process\n    data = get_grid_data(field)\n\n    if MPI.Comm_rank(MPI.COMM_WORLD) == 0\n        h5write(filename, field.name, data)\n    end\nend\n\nsave_field(T, \"temperature.h5\")","category":"section"},{"location":"api/fields/#Loading-Fields","page":"Fields API","title":"Loading Fields","text":"function load_field!(field, filename)\n    if MPI.Comm_rank(MPI.COMM_WORLD) == 0\n        data = h5read(filename, field.name)\n    else\n        data = nothing\n    end\n\n    # Broadcast to all ranks\n    # ... (distribute according to pencil decomposition)\n\n    to_spectral!(field)\nend\n\nload_field!(T, \"temperature.h5\")","category":"section"},{"location":"api/fields/#Memory-Layout","page":"Fields API","title":"Memory Layout","text":"","category":"section"},{"location":"api/fields/#Spectral-Space","page":"Fields API","title":"Spectral Space","text":"In spectral space, fields are stored as arrays of spectral coefficients:\n\nFourier: Complex coefficients (or real for RealFourier)\nChebyshev: Coefficients in Chebyshev polynomial basis\nLegendre: Coefficients in Legendre polynomial basis","category":"section"},{"location":"api/fields/#Grid-Space","page":"Fields API","title":"Grid Space","text":"In grid space, fields are pointwise values on the collocation grid:\n\nFourier: Uniform grid\nChebyshev: Chebyshev-Gauss-Lobatto points\nLegendre: Legendre-Gauss-Lobatto points","category":"section"},{"location":"api/fields/#Distributed-Layout","page":"Fields API","title":"Distributed Layout","text":"Fields use PencilArrays for distribution:\n\n# Local size on this MPI rank\nlocal_size = size(field.data)\n\n# Global size\nglobal_size = field.data.global_size\n\n# Rank in process mesh\nrank = field.distributor.rank","category":"section"},{"location":"api/fields/#Type-Hierarchy","page":"Fields API","title":"Type Hierarchy","text":"AbstractField\n├── ScalarField\n├── VectorField\n│   └── components::Vector{ScalarField}\n└── TensorField\n    └── components::Array{ScalarField, 2}","category":"section"},{"location":"api/fields/#Performance-Tips","page":"Fields API","title":"Performance Tips","text":"","category":"section"},{"location":"api/fields/#Minimize-Transforms","page":"Fields API","title":"Minimize Transforms","text":"Transforms are expensive. Group operations:\n\n# Bad: Multiple transforms\nto_grid!(u)\nto_grid!(v)\nresult = u.data .* v.data\nto_spectral!(result_field)\n\n# Good: One transform per field\nto_grid!(u)\nto_grid!(v)\nresult = u.data .* v.data\nresult_field.data .= result\nresult_field.space = :grid\nto_spectral!(result_field)","category":"section"},{"location":"api/fields/#Reuse-Work-Arrays","page":"Fields API","title":"Reuse Work Arrays","text":"# Create work array once\nwork = similar(field.data)\n\n# Reuse in loop\nfor i in 1:nsteps\n    work .= compute_something(field)\n    field.data .+= dt .* work\nend","category":"section"},{"location":"api/fields/#In-Place-Operations","page":"Fields API","title":"In-Place Operations","text":"# Bad: Allocates new arrays\nfield.data = field.data .+ alpha .* other.data\n\n# Good: In-place operation\nfield.data .+= alpha .* other.data","category":"section"},{"location":"api/fields/#See-Also","page":"Fields API","title":"See Also","text":"Operators: Differential operators on fields\nDomains: Spatial domains and bases\nProblems: Setting up PDE problems with fields","category":"section"},{"location":"pages/temporal_filters/#Temporal-Filters-for-Lagrangian-Averaging","page":"Temporal Filters for Lagrangian Averaging","title":"Temporal Filters for Lagrangian Averaging","text":"Efficient computation of Lagrangian means using exponential time filters.\n\nReference: Minz, Baker, Kafiabad & Vanneste (2025). \"Efficient Lagrangian averaging with exponential filters\". Phys. Rev. Fluids 10, 074902.\n\n","category":"section"},{"location":"pages/temporal_filters/#Quick-Summary","page":"Temporal Filters for Lagrangian Averaging","title":"Quick Summary","text":"What: Temporal filters that separate fast waves from slow mean flowsWhy: Traditional averaging requires storing entire time history; these filters need only the current stateWhich filter to use:ExponentialMean - Simple, low memory (1 array), moderate filtering\nButterworthFilter - Sharp cutoff, 2x memory (2 arrays), excellent filtering\nLagrangianFilter - Full Lagrangian averaging with particle displacement tracking\n\n","category":"section"},{"location":"pages/temporal_filters/#Quick-Start","page":"Temporal Filters for Lagrangian Averaging","title":"Quick Start","text":"","category":"section"},{"location":"pages/temporal_filters/#Basic-Usage-(3-lines-of-code)","page":"Temporal Filters for Lagrangian Averaging","title":"Basic Usage (3 lines of code)","text":"using Tarang\n\n# 1. Create a filter for your field size\nfilter = ButterworthFilter((64, 64); α=0.5)  # α = 1/averaging_time\n\n# 2. In your time loop, update the filter\nupdate!(filter, field_data, dt)\n\n# 3. Get the filtered mean anytime\nmean_field = get_mean(filter)","category":"section"},{"location":"pages/temporal_filters/#Complete-Working-Example","page":"Temporal Filters for Lagrangian Averaging","title":"Complete Working Example","text":"using Tarang\n\n# Setup: 2D field with slow trend + fast oscillations\nNx, Ny = 64, 64\nα = 0.5      # Averaging time = 1/α = 2 time units\ndt = 0.01\nnsteps = 500\n\n# Create Butterworth filter (better than exponential for sharp separation)\nfilter = ButterworthFilter((Nx, Ny); α=α)\n\n# Simulate: field = slow_trend + fast_oscillation\nfor step in 1:nsteps\n    t = step * dt\n\n    # Your field: slow part (want to keep) + fast part (want to remove)\n    slow_part = 1.0 + 0.1 * t\n    fast_part = 0.5 * sin(20.0 * t)  # ω=20 >> α=0.5, will be filtered out\n    field = fill(slow_part + fast_part, Nx, Ny)\n\n    # Update filter\n    update!(filter, field, dt)\nend\n\n# Result: filtered mean ≈ slow_part only\nh_mean = get_mean(filter)\nprintln(\"Filtered mean: \", h_mean[1,1])  # ≈ 1.0 + 0.1*5.0 = 1.5\n\n","category":"section"},{"location":"pages/temporal_filters/#Choosing-a-Filter","page":"Temporal Filters for Lagrangian Averaging","title":"Choosing a Filter","text":"                    ┌─────────────────────────────────────┐\n                    │  Do you need Lagrangian averaging?  │\n                    │  (particle tracking, Stokes drift)  │\n                    └─────────────────────────────────────┘\n                                    │\n                    ┌───────────────┴───────────────┐\n                    ▼                               ▼\n                   YES                              NO\n                    │                               │\n                    ▼                               ▼\n           ┌────────────────┐              ┌─────────────────────┐\n           │LagrangianFilter│              │Need sharp wave-mean │\n           └────────────────┘              │   separation?       │\n                                           └─────────────────────┘\n                                                    │\n                                    ┌───────────────┴───────────────┐\n                                    ▼                               ▼\n                                   YES                              NO\n                                    │                               │\n                                    ▼                               ▼\n                          ┌──────────────────┐            ┌─────────────────┐\n                          │ButterworthFilter │            │ ExponentialMean │\n                          │  (recommended)   │            │   (simplest)    │\n                          └──────────────────┘            └─────────────────┘","category":"section"},{"location":"pages/temporal_filters/#Filter-Comparison","page":"Temporal Filters for Lagrangian Averaging","title":"Filter Comparison","text":"Feature ExponentialMean ButterworthFilter LagrangianFilter\nUse case Simple running mean Wave-mean separation Full Lagrangian averaging\nMemory 1 array 2 arrays 2-4 arrays\nHigh-freq rolloff -20 dB/decade -40 dB/decade Depends on type\nAttenuation at ω=10α 1% passes 0.01% passes -\nComplexity Simplest Moderate Most complex\n\n","category":"section"},{"location":"pages/temporal_filters/#The-Key-Parameter:-α","page":"Temporal Filters for Lagrangian Averaging","title":"The Key Parameter: α","text":"The parameter α (alpha) is the inverse averaging timescale:\n\nalpha = frac1T_textavg","category":"section"},{"location":"pages/temporal_filters/#How-to-Choose-α","page":"Temporal Filters for Lagrangian Averaging","title":"How to Choose α","text":"Rule of thumb: Set α much smaller than the frequency of oscillations you want to remove.\n\nα << ω_wave    (α should be much less than wave frequency)\n\nPractical guidance:\n\nWave period Suggested α Averaging time\n1 hour 0.05/hour 20 hours\n10 minutes 0.005/min 200 min\n1 second 0.05/s 20 s\n\nExample: If you have internal waves with period T=1 hour (ω = 2π/hour ≈ 6.28/hour):\n\nα = 0.1  # per hour → averages over 10 hours → filters waves with ω >> 0.1\n\ntip: Quick rule\nFor Butterworth: waves with ω > 20α are effectively filtered out. For Exponential: waves with ω > 50α are effectively filtered out.\n\n","category":"section"},{"location":"pages/temporal_filters/#API-Reference","page":"Temporal Filters for Lagrangian Averaging","title":"API Reference","text":"","category":"section"},{"location":"pages/temporal_filters/#ExponentialMean","page":"Temporal Filters for Lagrangian Averaging","title":"ExponentialMean","text":"First-order filter. Simple and memory-efficient.\n\n# Constructor\nfilter = ExponentialMean((Nx, Ny); α=0.5, dtype=Float64)\n\n# Key ODE: dh̄/dt = α(h - h̄)\n# Transfer function: H(s) = α/(s + α)\n\nFunctions:\n\nupdate!(filter, h, dt)           # Update with new data (forward Euler)\nupdate!(filter, h, dt, Val(:RK2)) # Update with RK2 (more accurate)\nget_mean(filter)                 # Get filtered mean h̄\nreset!(filter)                   # Reset to zero\nset_α!(filter, new_α)            # Change α dynamically\neffective_averaging_time(filter) # Returns 1/α\nfilter_response(filter, ω)       # Returns |H(iω)|² at frequency ω","category":"section"},{"location":"pages/temporal_filters/#ButterworthFilter","page":"Temporal Filters for Lagrangian Averaging","title":"ButterworthFilter","text":"Second-order filter. Sharper cutoff, recommended for wave-mean separation.\n\n# Constructor\nfilter = ButterworthFilter((Nx, Ny); α=0.5, dtype=Float64)\n\n# Key ODEs (coupled system):\n#   dh̃/dt = α[h - (√2-1)h̃ - (2-√2)h̄]\n#   dh̄/dt = α(h̃ - h̄)\n# Transfer function: K(s) = α²/(s² + √2αs + α²)\n\nFunctions:\n\nupdate!(filter, h, dt)           # Update with new data\nupdate!(filter, h, dt, Val(:RK2)) # Update with RK2\nget_mean(filter)                 # Get filtered mean h̄\nget_auxiliary(filter)            # Get auxiliary field h̃\nreset!(filter)                   # Reset to zero\nset_α!(filter, new_α)            # Change α\neffective_averaging_time(filter) # Returns 1/α\nfilter_response(filter, ω)       # Returns |K(iω)|²","category":"section"},{"location":"pages/temporal_filters/#LagrangianFilter","page":"Temporal Filters for Lagrangian Averaging","title":"LagrangianFilter","text":"Full Lagrangian averaging with displacement field tracking.\n\n# Constructor\nfilter = LagrangianFilter((Nx, Ny);\n    α=0.5,\n    filter_type=:butterworth,  # or :exponential\n    dtype=Float64\n)\n\n# Key relations:\n#   Mean velocity: ū = α·ξ (exponential) or ū = α·ξ̃ (Butterworth)\n#   Displacement PDE: ∂ξ/∂t + ū·∇ξ = u∘(id+ξ) - ū\n\nFunctions:\n\nupdate_displacement!(filter, velocity, dt)  # Update displacement ξ\nget_mean_velocity(filter)                   # Get ū\nget_displacement(filter)                    # Get ξ\nlagrangian_mean!(filter, gᴸ, g, dt)         # Compute Lagrangian mean of scalar g\nreset!(filter)                              # Reset all fields\nset_α!(filter, new_α)                       # Change α\n\n","category":"section"},{"location":"pages/temporal_filters/#Detailed-Examples","page":"Temporal Filters for Lagrangian Averaging","title":"Detailed Examples","text":"","category":"section"},{"location":"pages/temporal_filters/#Example-1:-Filtering-Oscillations-from-a-Time-Series","page":"Temporal Filters for Lagrangian Averaging","title":"Example 1: Filtering Oscillations from a Time Series","text":"using Tarang\n\n# Problem: Extract slowly-varying part from noisy oscillating signal\nNx = 100\nα = 1.0      # Filter frequencies >> 1\ndt = 0.01\nT_final = 10.0\n\n# Compare exponential vs Butterworth\nexp_filter = ExponentialMean((Nx,); α=α)\nbut_filter = ButterworthFilter((Nx,); α=α)\n\nt = 0.0\nwhile t < T_final\n    # Signal: mean=2.0, slow variation, fast noise\n    signal = fill(2.0 + 0.5*sin(0.1*t) + 0.3*sin(50.0*t), Nx)\n    #              ↑         ↑                ↑\n    #           constant   slow (keep)    fast (remove)\n\n    update!(exp_filter, signal, dt)\n    update!(but_filter, signal, dt)\n    t += dt\nend\n\nexp_mean = get_mean(exp_filter)[1]\nbut_mean = get_mean(but_filter)[1]\n\nprintln(\"Exponential mean: \", round(exp_mean, digits=3))  # Some fast oscillation leaks through\nprintln(\"Butterworth mean: \", round(but_mean, digits=3))  # Cleaner result","category":"section"},{"location":"pages/temporal_filters/#Example-2:-Wave-Mean-Flow-Decomposition","page":"Temporal Filters for Lagrangian Averaging","title":"Example 2: Wave-Mean Flow Decomposition","text":"using Tarang\n\n# Setup domain (simplified - not using full Tarang fields)\nNx, Ny = 64, 64\nα = 0.2      # Average over 5 time units\ndt = 0.02\n\n# Filter for each velocity component\nu_filter = ButterworthFilter((Nx, Ny); α=α)\nv_filter = ButterworthFilter((Nx, Ny); α=α)\n\n# Simulation loop\nfor step in 1:1000\n    t = step * dt\n\n    # Synthetic velocity: mean jet + inertia-gravity waves\n    u = zeros(Nx, Ny)\n    v = zeros(Nx, Ny)\n    for i in 1:Nx, j in 1:Ny\n        x, y = (i-1)/Nx * 2π, (j-1)/Ny * 2π\n\n        # Mean zonal jet (slow)\n        u[i,j] = sin(y)\n\n        # Wave perturbations (fast)\n        ω = 10.0  # wave frequency >> α\n        u[i,j] += 0.1 * cos(2x + 3y - ω*t)\n        v[i,j] = 0.1 * sin(2x + 3y - ω*t)\n    end\n\n    # Update filters\n    update!(u_filter, u, dt)\n    update!(v_filter, v, dt)\nend\n\n# Get mean flow\nū = get_mean(u_filter)\nv̄ = get_mean(v_filter)\n\n# Wave fluctuations\nu_wave = u - ū\nv_wave = v - v̄\n\nprintln(\"Mean u max: \", maximum(abs.(ū)))     # ≈ 1.0 (the jet)\nprintln(\"Mean v max: \", maximum(abs.(v̄)))     # ≈ 0.0 (waves filtered)","category":"section"},{"location":"pages/temporal_filters/#Example-3:-Comparing-Filter-Frequency-Response","page":"Temporal Filters for Lagrangian Averaging","title":"Example 3: Comparing Filter Frequency Response","text":"using Tarang\n\nα = 1.0\n\nexp_filter = ExponentialMean((10,); α=α)\nbut_filter = ButterworthFilter((10,); α=α)\n\nprintln(\"Frequency Response |H(iω)|²\")\nprintln(\"=\"^50)\nprintln(\"ω/α      Exponential    Butterworth\")\nprintln(\"-\"^50)\n\nfor ω_ratio in [0.1, 0.5, 1.0, 2.0, 5.0, 10.0, 20.0]\n    ω = ω_ratio * α\n    exp_resp = filter_response(exp_filter, ω)\n    but_resp = filter_response(but_filter, ω)\n\n    @printf(\"%4.1f     %10.6f     %10.6f\\n\", ω_ratio, exp_resp, but_resp)\nend\n\nOutput:\n\nω/α      Exponential    Butterworth\n--------------------------------------------------\n 0.1       0.990099       0.999800\n 0.5       0.800000       0.941176\n 1.0       0.500000       0.500000  ← half-power point\n 2.0       0.200000       0.058824\n 5.0       0.038462       0.001575\n10.0       0.009901       0.000100\n20.0       0.002494       0.000006\n\nnote: Key observation\nAt ω = 10α, Butterworth passes only 0.01% vs Exponential's 1% — that's 100x better filtering!\n\n","category":"section"},{"location":"pages/temporal_filters/#Background-Theory","page":"Temporal Filters for Lagrangian Averaging","title":"Background Theory","text":"This section explains the physics behind temporal filters. Skip if you just want to use the filters.","category":"section"},{"location":"pages/temporal_filters/#The-Wave-Mean-Flow-Problem","page":"Temporal Filters for Lagrangian Averaging","title":"The Wave-Mean Flow Problem","text":"Geophysical flows contain both:\n\nSlow mean flows: jets, eddies, large-scale circulation\nFast waves: gravity waves, inertial oscillations, acoustic waves\n\nu(x,t) = ū(x,t) + u'(x,t)\n         ↑          ↑\n      mean flow   wave fluctuation\n\nThe challenge: How do we define and compute the \"mean\" efficiently?","category":"section"},{"location":"pages/temporal_filters/#Eulerian-vs-Lagrangian-Averaging","page":"Temporal Filters for Lagrangian Averaging","title":"Eulerian vs Lagrangian Averaging","text":"Eulerian (fixed point): baru^E(mathbfx) = frac1T int_0^T u(mathbfx t)  dt\n\nProblem: Misses Stokes drift! A wave with zero Eulerian mean can still transport particles.\n\nLagrangian (following particles): baru^L = frac1T int_0^T u(mathbfX(t) t)  dt\n\nAdvantage: Captures actual material transport.","category":"section"},{"location":"pages/temporal_filters/#Why-Exponential-Filters?","page":"Temporal Filters for Lagrangian Averaging","title":"Why Exponential Filters?","text":"Traditional averaging requires storing entire time history. Exponential filters use a weighted average:\n\nbarh(t) = alpha int_0^infty e^-alphatau h(t-tau)  dtau\n\nThis satisfies a simple ODE:\n\nfracdbarhdt = alpha(h - barh)\n\nNo storage needed — just update the current mean at each timestep!","category":"section"},{"location":"pages/temporal_filters/#The-Butterworth-Advantage","page":"Temporal Filters for Lagrangian Averaging","title":"The Butterworth Advantage","text":"The exponential filter has slow rolloff (-20 dB/decade). The second-order Butterworth filter has:\n\nK(s) = fracalpha^2s^2 + sqrt2alpha s + alpha^2\n\nThis gives -40 dB/decade rolloff — much sharper separation between waves and mean flow.","category":"section"},{"location":"pages/temporal_filters/#The-Lifting-Map-(Advanced)","page":"Temporal Filters for Lagrangian Averaging","title":"The Lifting Map (Advanced)","text":"For true Lagrangian averaging, we need the lifting map boldsymbolXi(mathbfx t):\n\nboldsymbolXi(mathbfx t)= position at time t of the parcel whose mean position is mathbfx\n\nThe displacement is: boldsymbolxi = boldsymbolXi - mathbfx\n\nKey result from Minz et al.:\n\nFor exponential mean: barmathbfu = alpha boldsymbolxi\nFor Butterworth: barmathbfu = alpha tildeboldsymbolxi\n\nThis is implemented in LagrangianFilter.\n\n","category":"section"},{"location":"pages/temporal_filters/#Mathematical-Details","page":"Temporal Filters for Lagrangian Averaging","title":"Mathematical Details","text":"","category":"section"},{"location":"pages/temporal_filters/#Exponential-Filter","page":"Temporal Filters for Lagrangian Averaging","title":"Exponential Filter","text":"Kernel: k(tau) = alpha e^-alphatau Theta(tau)\n\nODE: fracdbarhdt = alpha(h - barh)\n\nTransfer function: H(s) = fracalphas + alpha\n\nFrequency response: H(iomega)^2 = fracalpha^2alpha^2 + omega^2","category":"section"},{"location":"pages/temporal_filters/#Butterworth-Filter","page":"Temporal Filters for Lagrangian Averaging","title":"Butterworth Filter","text":"Kernel: k(tau) = sqrt2alpha e^-alphatausqrt2 sin(alphatausqrt2) Theta(tau)\n\nCoupled ODEs: fracdtildehdt = alphalefth - (sqrt2-1)tildeh - (2-sqrt2)barhright fracdbarhdt = alpha(tildeh - barh)\n\nTransfer function: K(s) = fracalpha^2s^2 + sqrt2alpha s + alpha^2\n\nFrequency response: K(iomega)^2 = fracalpha^4(alpha^2 - omega^2)^2 + 2alpha^2omega^2","category":"section"},{"location":"pages/temporal_filters/#Filter-Matrix","page":"Temporal Filters for Lagrangian Averaging","title":"Filter Matrix","text":"The Butterworth system can be written as: fracddtbeginpmatrixtildehbarhendpmatrix = -alphamathbfAbeginpmatrixtildehbarhendpmatrix + alphabeginpmatrixh0endpmatrix\n\nwhere: mathbfA = beginpmatrixsqrt2-1  2-sqrt2-1  1endpmatrix approx beginpmatrix0414  0586-1  1endpmatrix","category":"section"},{"location":"pages/temporal_filters/#Lagrangian-Mean-Equations","page":"Temporal Filters for Lagrangian Averaging","title":"Lagrangian Mean Equations","text":"Displacement evolution: fracpartialboldsymbolxipartial t + barmathbfucdotnablaboldsymbolxi = mathbfucirc(mathbfid+boldsymbolxi) - barmathbfu\n\nScalar Lagrangian mean (exponential): fracpartial g^Lpartial t + barmathbfucdotnabla g^L = alpha(gcircboldsymbolXi - g^L)\n\nScalar Lagrangian mean (Butterworth): fracpartialtildegpartial t + barmathbfucdotnablatildeg = alphaleftgcircboldsymbolXi - (sqrt2-1)tildeg - (2-sqrt2)g^Lright fracpartial g^Lpartial t + barmathbfucdotnabla g^L = alpha(tildeg - g^L)\n\n","category":"section"},{"location":"pages/temporal_filters/#Advanced-Time-Integration-Methods","page":"Temporal Filters for Lagrangian Averaging","title":"Advanced Time Integration Methods","text":"The basic update! function uses Forward Euler, which has a stability limit. For larger timesteps or coupling with implicit PDE solvers, use these advanced methods.","category":"section"},{"location":"pages/temporal_filters/#Stability-Limits-(Explicit-Methods)","page":"Temporal Filters for Lagrangian Averaging","title":"Stability Limits (Explicit Methods)","text":"Filter Forward Euler RK2\nExponentialMean Delta t leq 2alpha Delta t leq 4alpha\nButterworthFilter Delta t leq sqrt2alpha Delta t leq 2sqrt2alpha\n\n# Check maximum stable timestep\ndt_max = max_stable_timestep(filter)           # Forward Euler\ndt_max_rk2 = max_stable_timestep(filter; method=:RK2)  # RK2","category":"section"},{"location":"pages/temporal_filters/#ETD-(Exponential-Time-Differencing)-Recommended","page":"Temporal Filters for Lagrangian Averaging","title":"ETD (Exponential Time Differencing) - Recommended","text":"Unconditionally stable for any timestep. Treats the linear decay term exactly.\n\n# Precompute coefficients once (per α, dt pair)\ncoeffs = precompute_etd_coefficients(filter, dt)\n\n# In time loop - no stability limit!\nfor step in 1:nsteps\n    # ... your PDE timestepping ...\n    update_etd!(filter, field_data, coeffs)\nend\n\nHow it works:\n\nFor the filter ODE dbarhdt = -alphabarh + alpha h, ETD computes:\n\nbarh^n+1 = e^-alphaDelta tbarh^n + (1 - e^-alphaDelta t)h^n\n\nThis is exact when h is constant over the timestep, and unconditionally stable otherwise.","category":"section"},{"location":"pages/temporal_filters/#IMEX/SBDF-Integration","page":"Temporal Filters for Lagrangian Averaging","title":"IMEX/SBDF Integration","text":"For coupling with implicit PDE solvers using SBDF2 or SBDF3 timestepping.\n\n# Precompute IMEX coefficients\ncoeffs = precompute_imex_coefficients(filter, dt; scheme=:SBDF2)\n\n# Store field history for multistep method\nh_prev = copy(h)\nh_curr = copy(h)\n\n# In time loop - unconditionally stable!\nfor step in 1:nsteps\n    # ... your SBDF2 PDE timestepping ...\n    h_new = # ... compute new field value ...\n\n    # Update filter with field history\n    update_imex!(filter, (h_curr, h_prev), coeffs)\n\n    h_prev .= h_curr\n    h_curr .= h_new\nend\n\nAvailable schemes:\n\n:SBDF1 (Backward Euler): First-order, most stable\n:SBDF2: Second-order, recommended\n:SBDF3: Third-order, highest accuracy","category":"section"},{"location":"pages/temporal_filters/#Accessing-Linear-Operator-for-External-Solvers","page":"Temporal Filters for Lagrangian Averaging","title":"Accessing Linear Operator for External Solvers","text":"If you're using your own IMEX framework:\n\n# Get the linear operator coefficient\nL = linear_operator_coefficients(filter)\n# Returns -α (scalar) for ExponentialMean\n# Returns -α·A (2×2 matrix) for ButterworthFilter\n\n","category":"section"},{"location":"pages/temporal_filters/#Troubleshooting","page":"Temporal Filters for Lagrangian Averaging","title":"Troubleshooting","text":"","category":"section"},{"location":"pages/temporal_filters/#Common-Issues","page":"Temporal Filters for Lagrangian Averaging","title":"Common Issues","text":"1. Filter not converging to expected mean\n\nCause: Not enough spinup time.\n\nSolution: Run for at least 5alpha time units before trusting results.\n\nT_spinup = 5 / α  # Minimum spinup time\n\n2. Oscillations in filtered output\n\nCause: Timestep too large for stability.\n\nSolution: Use ETD integration (unconditionally stable):\n\ncoeffs = precompute_etd_coefficients(filter, dt)\nupdate_etd!(filter, h, coeffs)  # Always stable!\n\nOr use RK2 for explicit methods:\n\nupdate!(filter, h, dt, Val(:RK2))  # 2× larger stability region\n\n3. High frequencies leaking through\n\nCause: Using ExponentialMean when ButterworthFilter is needed.\n\nSolution: Switch to Butterworth for sharper cutoff.\n\n4. Memory issues with large 3D fields\n\nCause: ButterworthFilter uses 2x memory.\n\nSolution: Use ExponentialMean if memory is critical:\n\n# ButterworthFilter: 2 arrays\n# ExponentialMean: 1 array (half the memory)\nfilter = ExponentialMean((Nx, Ny, Nz); α=α)\n\n5. Need to couple with implicit timestepper\n\nSolution: Use IMEX integration:\n\ncoeffs = precompute_imex_coefficients(filter, dt; scheme=:SBDF2)\nupdate_imex!(filter, (h_n, h_nm1), coeffs)\n\n","category":"section"},{"location":"pages/temporal_filters/#Tutorials","page":"Temporal Filters for Lagrangian Averaging","title":"Tutorials","text":"Rotating Shallow Water with Lagrangian Averaging - Complete example of wave-mean separation in a rotating flow\n\n","category":"section"},{"location":"pages/temporal_filters/#References","page":"Temporal Filters for Lagrangian Averaging","title":"References","text":"Minz, C., Baker, L. E., Kafiabad, H. A., & Vanneste, J. (2025). Efficient Lagrangian averaging with exponential filters. Physical Review Fluids, 10, 074902. DOI\nAndrews, D. G., & McIntyre, M. E. (1978). An exact theory of nonlinear waves on a Lagrangian-mean flow. J. Fluid Mech., 89(4), 609-646.\nBühler, O. (2014). Waves and Mean Flows (2nd ed.). Cambridge University Press.\nGilbert, A. D., & Vanneste, J. (2018). Geometric generalised Lagrangian-mean theories. J. Fluid Mech., 839, 95-134.\n\n\n\nDocument version 2.0 | December 2024 | Tarang.jl","category":"section"},{"location":"pages/tau_method/#The-Tau-Method-for-Boundary-Conditions","page":"The Tau Method for Boundary Conditions","title":"The Tau Method for Boundary Conditions","text":"The tau method is a powerful spectral technique for enforcing boundary conditions in differential equations. This page provides a detailed explanation accessible to those new to spectral methods.","category":"section"},{"location":"pages/tau_method/#Why-Do-We-Need-the-Tau-Method?","page":"The Tau Method for Boundary Conditions","title":"Why Do We Need the Tau Method?","text":"","category":"section"},{"location":"pages/tau_method/#The-Boundary-Condition-Problem-in-Spectral-Methods","page":"The Tau Method for Boundary Conditions","title":"The Boundary Condition Problem in Spectral Methods","text":"Consider solving a differential equation like the heat equation:\n\nfracpartial upartial t = kappa fracpartial^2 upartial z^2 quad z in 0 1\n\nwith boundary conditions u(0,t) = 0 and u(1,t) = 0.\n\nIn finite difference methods, applying boundary conditions is straightforward: you simply set the values at the boundary grid points:\n\nu[1] = 0      # at z = 0\nu[N] = 0      # at z = 1\n\nIn spectral methods, we represent the solution as a sum of basis functions:\n\nu(z) = sum_n=0^N-1 a_n T_n(z)\n\nwhere T_n(z) are Chebyshev polynomials and a_n are the spectral coefficients we need to find.\n\nThe challenge: The spectral coefficients a_n are global—they affect the solution everywhere, not just at specific points. We cannot simply \"set\" boundary values; instead, we must find coefficients that simultaneously:\n\nSatisfy the PDE in the interior\nSatisfy the boundary conditions at the edges","category":"section"},{"location":"pages/tau_method/#The-Core-Idea-of-the-Tau-Method","page":"The Tau Method for Boundary Conditions","title":"The Core Idea of the Tau Method","text":"The tau method solves this by a clever trade-off:\n\nKey Insight: We have N unknowns (spectral coefficients a_0, a_1, ..., a_N-1) and need N equations. Instead of using N equations from the PDE, we use (N-k) equations from the PDE and k equations from the boundary conditions.\n\nFor a second-order equation with 2 boundary conditions (k=2):\n\nEquations 0 through N-3: Come from the PDE\nEquations N-2 and N-1: Come from the boundary conditions","category":"section"},{"location":"pages/tau_method/#Understanding-Through-a-Simple-Example","page":"The Tau Method for Boundary Conditions","title":"Understanding Through a Simple Example","text":"","category":"section"},{"location":"pages/tau_method/#Step-1:-The-Continuous-Problem","page":"The Tau Method for Boundary Conditions","title":"Step 1: The Continuous Problem","text":"Solve the steady diffusion equation:\n\nfracd^2 ud z^2 = f(z) quad u(0) = 0 quad u(1) = 0","category":"section"},{"location":"pages/tau_method/#Step-2:-Spectral-Representation","page":"The Tau Method for Boundary Conditions","title":"Step 2: Spectral Representation","text":"Expand u(z) in Chebyshev polynomials:\n\nu(z) = sum_n=0^N-1 a_n T_n(z)\n\nRecall key properties of Chebyshev polynomials:\n\nT_n(z) = cos(n  arccos(z))\nfor z ∈ [-1, 1]\nT_n(1) = 1\nfor all n\nT_n(-1) = (-1)^n","category":"section"},{"location":"pages/tau_method/#Step-3:-The-Differentiation-Matrix","page":"The Tau Method for Boundary Conditions","title":"Step 3: The Differentiation Matrix","text":"Taking derivatives in spectral space:\n\nfracd^2 udz^2 = sum_n=0^N-1 a_n fracd^2 T_ndz^2 = sum_n=0^N-1 b_n T_n(z)\n\nThe coefficients b_n are related to a_n through the differentiation matrix D²:\n\nmathbfb = D^(2) mathbfa","category":"section"},{"location":"pages/tau_method/#Step-4:-The-PDE-in-Spectral-Space-(Without-Tau)","page":"The Tau Method for Boundary Conditions","title":"Step 4: The PDE in Spectral Space (Without Tau)","text":"Matching coefficients of T_n(z) on both sides of the PDE gives N equations:\n\nsum_m=0^N-1 D^(2)_nm a_m = f_n quad n = 0 1  N-1\n\nwhere f_n are the spectral coefficients of f(z).\n\nProblem: These N equations determine all N coefficients, leaving no freedom to satisfy boundary conditions!","category":"section"},{"location":"pages/tau_method/#Step-5:-The-Tau-Modification","page":"The Tau Method for Boundary Conditions","title":"Step 5: The Tau Modification","text":"Replace the last two equations with boundary conditions:\n\nOriginal system:\n\nRow 0:   D²₀₀·a₀ + D²₀₁·a₁ + ... = f₀    ← PDE\nRow 1:   D²₁₀·a₀ + D²₁₁·a₁ + ... = f₁    ← PDE\n  ⋮\nRow N-3: D²_{N-3,0}·a₀ + ... = f_{N-3}   ← PDE\nRow N-2: D²_{N-2,0}·a₀ + ... = f_{N-2}   ← PDE  ✗ REPLACE\nRow N-1: D²_{N-1,0}·a₀ + ... = f_{N-1}   ← PDE  ✗ REPLACE\n\nModified system (tau method):\n\nRow 0:   D²₀₀·a₀ + D²₀₁·a₁ + ... = f₀    ← PDE\nRow 1:   D²₁₀·a₀ + D²₁₁·a₁ + ... = f₁    ← PDE\n  ⋮\nRow N-3: D²_{N-3,0}·a₀ + ... = f_{N-3}   ← PDE\nRow N-2: T₀(-1)·a₀ + T₁(-1)·a₁ + ... = 0  ← BC at z=0\nRow N-1: T₀(1)·a₀ + T₁(1)·a₁ + ... = 0   ← BC at z=1\n\nSince T_n(1) = 1 and T_n(-1) = (-1)^n:\n\nRow N-2: a₀ - a₁ + a₂ - a₃ + ... = 0     ← u(-1) = 0\nRow N-1: a₀ + a₁ + a₂ + a₃ + ... = 0     ← u(+1) = 0","category":"section"},{"location":"pages/tau_method/#Visual-Representation","page":"The Tau Method for Boundary Conditions","title":"Visual Representation","text":"┌─────────────────────────────────────────┐\n│           Original System               │\n│  ┌─────────────────────────────────┐   │\n│  │  PDE Row 0                      │   │\n│  │  PDE Row 1                      │   │\n│  │  PDE Row 2                      │   │\n│  │       ⋮                         │   │\n│  │  PDE Row N-3                    │   │\n│  │  PDE Row N-2  ─────┐            │   │\n│  │  PDE Row N-1  ─────┤            │   │\n│  └────────────────────┼────────────┘   │\n│                       │                 │\n│                       ▼                 │\n│           Tau Modified System           │\n│  ┌─────────────────────────────────┐   │\n│  │  PDE Row 0                      │   │\n│  │  PDE Row 1                      │   │\n│  │  PDE Row 2                      │   │\n│  │       ⋮                         │   │\n│  │  PDE Row N-3                    │   │\n│  │  BC at z = 0  (replaces N-2)    │   │\n│  │  BC at z = 1  (replaces N-1)    │   │\n│  └─────────────────────────────────┘   │\n└─────────────────────────────────────────┘","category":"section"},{"location":"pages/tau_method/#Why-Replace-the-*Highest*-Order-Equations?","page":"The Tau Method for Boundary Conditions","title":"Why Replace the Highest Order Equations?","text":"The spectral coefficients a_n for large n correspond to fine-scale (high-frequency) features of the solution. By modifying these high-order equations:\n\nSmooth solutions are preserved: Low-order coefficients (capturing the main shape) are determined by the PDE\nBoundary conditions are enforced: High-order coefficients adjust to match boundaries\nSpectral accuracy maintained: For smooth solutions, high-order coefficients are already small\n\nThis is related to the concept of tau error: the residual in the original PDE equations that we replaced. For smooth solutions, this error is spectrally small (decays faster than any polynomial).","category":"section"},{"location":"pages/tau_method/#Comparison-with-Other-Methods","page":"The Tau Method for Boundary Conditions","title":"Comparison with Other Methods","text":"","category":"section"},{"location":"pages/tau_method/#Tau-Method-vs.-Collocation-Method","page":"The Tau Method for Boundary Conditions","title":"Tau Method vs. Collocation Method","text":"Aspect Tau Method Collocation Method\nWhere BCs applied In spectral space At physical grid points\nMatrix structure Modified rows Natural incorporation\nImplementation Replace equations Evaluate at boundaries\nAccuracy Spectral Spectral\nConditioning Can be challenging Generally better\n\nCollocation evaluates the PDE at specific grid points (e.g., Gauss-Lobatto points) and applies BCs directly at boundary points. It's often easier to implement but mathematically equivalent for many problems.","category":"section"},{"location":"pages/tau_method/#Tau-Method-vs.-Galerkin-Method","page":"The Tau Method for Boundary Conditions","title":"Tau Method vs. Galerkin Method","text":"Aspect Tau Method Galerkin Method\nBasis functions Standard (Chebyshev, etc.) Modified to satisfy BCs\nBC handling Via tau equations Built into basis\nFlexibility Any BC type Requires basis construction\nCommon use General purpose Specific BC types\n\nGalerkin uses basis functions that inherently satisfy the boundary conditions. For example, using sin(nπz) automatically satisfies u(0) = u(1) = 0. This is elegant but requires constructing appropriate bases for each BC type.","category":"section"},{"location":"pages/tau_method/#Types-of-Boundary-Conditions","page":"The Tau Method for Boundary Conditions","title":"Types of Boundary Conditions","text":"","category":"section"},{"location":"pages/tau_method/#Dirichlet-(Value-Specified)","page":"The Tau Method for Boundary Conditions","title":"Dirichlet (Value Specified)","text":"u(z_boundary) = g\n\nTau equation:\n\nsum_n=0^N-1 a_n T_n(z_boundary) = g","category":"section"},{"location":"pages/tau_method/#Neumann-(Derivative-Specified)","page":"The Tau Method for Boundary Conditions","title":"Neumann (Derivative Specified)","text":"fracdudzbigg_z_boundary = g\n\nTau equation:\n\nsum_n=0^N-1 a_n T_n(z_boundary) = g\n\nwhere T_n(z) is the derivative of the Chebyshev polynomial.","category":"section"},{"location":"pages/tau_method/#Robin-(Mixed)","page":"The Tau Method for Boundary Conditions","title":"Robin (Mixed)","text":"alpha u(z_boundary) + beta fracdudzbigg_z_boundary = g\n\nTau equation:\n\nalpha sum_n=0^N-1 a_n T_n(z_boundary) + beta sum_n=0^N-1 a_n T_n(z_boundary) = g","category":"section"},{"location":"pages/tau_method/#Implementation-in-Tarang.jl","page":"The Tau Method for Boundary Conditions","title":"Implementation in Tarang.jl","text":"Tarang.jl follows the Dedalus approach: users must explicitly create tau fields and add them to equations using the lift() operator. This design provides full transparency and control over how boundary conditions interact with your equations.","category":"section"},{"location":"pages/tau_method/#Required-Steps","page":"The Tau Method for Boundary Conditions","title":"Required Steps","text":"To apply boundary conditions in Tarang.jl, you must:\n\nCreate tau fields - One for each boundary condition\nAdd tau fields to the problem - Include them as variables\nAdd lift(tau) terms to equations - Use the lift() operator\nSpecify tau_field in boundary conditions - Link BCs to their tau fields","category":"section"},{"location":"pages/tau_method/#Complete-Example","page":"The Tau Method for Boundary Conditions","title":"Complete Example","text":"using Tarang\n\n# Create domain\ncoords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords)\n\nxbasis = RealFourier(coords[\"x\"]; size=64, bounds=(0, 2π))\nzbasis = ChebyshevT(coords[\"z\"]; size=64, bounds=(0, 1))\n\n# Main field\nu = ScalarField(dist, \"u\", (xbasis, zbasis))\n\n# Step 1: Create tau fields (one per boundary condition)\n# Tau fields live on the \"other\" bases (here: xbasis only, not zbasis)\ntau_u1 = ScalarField(dist, \"tau_u1\", (xbasis,))  # For BC at z=0\ntau_u2 = ScalarField(dist, \"tau_u2\", (xbasis,))  # For BC at z=1\n\n# Step 2: Add all fields (including tau) to problem\nproblem = LBVP([u, tau_u1, tau_u2])\n\n# Step 3: Add equation with lift() operators\n# The lift() terms place tau values at specific spectral modes\nadd_equation!(problem,\n    lap(u) + lift(tau_u1, zbasis, -1) + lift(tau_u2, zbasis, -2) - f\n)\n\n# Step 4: Add boundary conditions\nadd_equation!(problem, \"u(z=0) = 0\")\nadd_equation!(problem, \"u(z=1) = 0\")\n\n# Solve\nsolver = BoundaryValueSolver(problem)\nsolve!(solver)","category":"section"},{"location":"pages/tau_method/#The-lift()-Operator","page":"The Tau Method for Boundary Conditions","title":"The lift() Operator","text":"The lift() operator \"lifts\" a lower-dimensional tau field into the full domain by placing its values at specific spectral modes:\n\nlift(tau_field, basis, n)\n\nArguments:\n\ntau_field - The tau field (lives on reduced bases)\nbasis - The basis along which to lift (typically the non-periodic direction)\nn - Which spectral mode to modify\n\nMode indexing (n):\n\nn = 0 → First mode (mode 0)\nn = -1 → Last mode (N-1)\nn = -2 → Second-to-last mode (N-2)\n\nWhy specific modes? The tau method works by replacing the highest-order spectral equations with boundary conditions. The lift() operator places tau contributions at these modes.","category":"section"},{"location":"pages/tau_method/#Comparison:-Tarang-vs.-Dedalus","page":"The Tau Method for Boundary Conditions","title":"Comparison: Tarang vs. Dedalus","text":"Tarang.jl closely follows the Dedalus design pattern:\n\nFeature Dedalus (Python) Tarang.jl (Julia)\nCreate tau field tau_p = dist.Field(name='tau_p', bases=xbasis) tau_p = ScalarField(dist, \"tau_p\", (xbasis,))\nLift operator lift(tau_p, -1) lift(tau_p, zbasis, -1)\nAdd to equation \"lap(u) + lift(tau_p, -1) = f\" lap(u) + lift(tau_p, zbasis, -1) - f\nAdd BC problem.add_bc(\"u(z=0) = 0\") add_equation!(problem, \"u(z=0) = 0\")\n\nDedalus example:\n\n# Dedalus (Python)\ntau_u1 = dist.Field(name='tau_u1', bases=xbasis)\ntau_u2 = dist.Field(name='tau_u2', bases=xbasis)\n\nproblem.add_equation(\"lap(u) + lift(tau_u1, -1) + lift(tau_u2, -2) = f\")\nproblem.add_bc(\"u(z=0) = 0\")\nproblem.add_bc(\"u(z=1) = 0\")\n\nTarang.jl equivalent:\n\n# Tarang.jl (Julia)\ntau_u1 = ScalarField(dist, \"tau_u1\", (xbasis,))\ntau_u2 = ScalarField(dist, \"tau_u2\", (xbasis,))\n\nproblem = LBVP([u, tau_u1, tau_u2])\nadd_equation!(problem, lap(u) + lift(tau_u1, zbasis, -1) + lift(tau_u2, zbasis, -2) - f)\nadd_equation!(problem, \"u(z=0) = 0\")\nadd_equation!(problem, \"u(z=1) = 0\")","category":"section"},{"location":"pages/tau_method/#Why-Explicit-Tau-Fields?","page":"The Tau Method for Boundary Conditions","title":"Why Explicit Tau Fields?","text":"The Dedalus approach (explicit tau fields) has several advantages:\n\nTransparency: You see exactly how BCs interact with equations\nDebugging: Easy to inspect tau field values after solving\nFlexibility: Custom tau arrangements for coupled systems\nConsistency: Same pattern for all problem types (IVP, BVP, EVP)\nDocumentation: Code is self-documenting about BC structure","category":"section"},{"location":"pages/tau_method/#What-Happens-Internally","page":"The Tau Method for Boundary Conditions","title":"What Happens Internally","text":"Build PDE matrix: Constructs differentiation matrices for all operators\nProcess lift operators: Inserts tau contributions at specified spectral modes\nBuild BC equations: Constructs boundary condition rows linking to tau fields\nAssemble system: Combines PDE + lift + BC into linear system\nSolve: Standard linear algebra solve\nExtract solution: Both u and tau values are solved simultaneously","category":"section"},{"location":"pages/tau_method/#Checking-Boundary-Condition-Satisfaction","page":"The Tau Method for Boundary Conditions","title":"Checking Boundary Condition Satisfaction","text":"# After solving, verify BCs are satisfied\nu_at_left = evaluate(u, z=0.0)\nu_at_right = evaluate(u, z=1.0)\n\n@assert abs(u_at_left - 0.0) < 1e-10 \"Left BC not satisfied\"\n@assert abs(u_at_right - 0.0) < 1e-10 \"Right BC not satisfied\"\n\n# You can also inspect tau field values\nprintln(\"tau_u1 values: \", tau_u1.data_c)\nprintln(\"tau_u2 values: \", tau_u2.data_c)","category":"section"},{"location":"pages/tau_method/#Number-of-Tau-Terms-Required","page":"The Tau Method for Boundary Conditions","title":"Number of Tau Terms Required","text":"The number of tau terms equals the number of boundary conditions, which depends on the order of the differential operator:\n\nOperator Order BCs Needed Tau Terms\n∂u/∂z 1st 1 1\n∂²u/∂z² 2nd 2 2\n∂⁴u/∂z⁴ 4th 4 4\n∇² (2D) 2nd in each 2 per direction 2 per direction","category":"section"},{"location":"pages/tau_method/#Pressure-in-Incompressible-Flows","page":"The Tau Method for Boundary Conditions","title":"Pressure in Incompressible Flows","text":"When solving incompressible Navier-Stokes equations, the pressure requires special treatment because it appears only as a gradient. The divergence equation div(u) = 0 becomes degenerate at the mean Fourier mode (k=0).","category":"section"},{"location":"pages/tau_method/#The-Tau-Solution","page":"The Tau Method for Boundary Conditions","title":"The Tau Solution","text":"Add a tau_p term to the continuity equation to remove the mathematical degeneracy:\n\n# Continuity equation with tau_p\nadd_equation!(problem, \"div(u) + tau_p = 0\")\n\n# Boundary conditions\nadd_bc!(problem, \"u(z=0) = 0\")\nadd_bc!(problem, \"u(z=1) = 0\")\n\nWhy tau_p is needed:\n\nThe divergence equation div(u) = 0 has a null space at k=0\ntau_p is a scalar constant that absorbs this degeneracy\nWithout it, the system matrix becomes singular","category":"section"},{"location":"pages/tau_method/#Complete-Example-2","page":"The Tau Method for Boundary Conditions","title":"Complete Example","text":"# Vector velocity field\nu = VectorField(dist, coords, \"u\", (x_basis, z_basis))\np = ScalarField(dist, \"p\", (x_basis, z_basis))\n\n# Tau fields\ntau_u1 = VectorField(dist, coords, \"tau_u1\", (x_basis,))\ntau_u2 = VectorField(dist, coords, \"tau_u2\", (x_basis,))\ntau_p = ScalarField(dist, \"tau_p\", ())  # Scalar constant\n\n# Problem with all fields\nproblem = IVP([u, p, tau_u1, tau_u2, tau_p])\n\n# Equations\nadd_equation!(problem, \"div(u) + tau_p = 0\")  # tau_p removes degeneracy\nadd_equation!(problem, \"∂t(u) - nu*Δ(u) + ∇(p) + lift(tau_u2) = -u⋅∇(u)\")\n\n# Boundary conditions\nadd_bc!(problem, \"u(z=0) = 0\")\nadd_bc!(problem, \"u(z=1) = 0\")\n\nNote: The pressure is determined up to an arbitrary constant. For most simulations, only the pressure gradient matters, so this ambiguity doesn't affect the physics. If you need absolute pressure values, you can manually subtract the mean after solving.","category":"section"},{"location":"pages/tau_method/#First-Order-Formulation-with-Derivative-Basis","page":"The Tau Method for Boundary Conditions","title":"First-Order Formulation with Derivative Basis","text":"For better conditioning and stability, Dedalus recommends converting second-order equations to first-order form using auxiliary gradient variables with tau corrections.","category":"section"},{"location":"pages/tau_method/#The-Derivative-Basis","page":"The Tau Method for Boundary Conditions","title":"The Derivative Basis","text":"When differentiating Chebyshev T polynomials, the result is expressed in terms of Chebyshev U polynomials (the \"derivative basis\"):\n\n# Get the derivative basis for ChebyshevT\nz_basis = ChebyshevT(coords[\"z\"]; size=64, bounds=(0.0, 1.0))\nlift_basis = derivative_basis(z_basis)  # Returns ChebyshevU\n\nThis is mathematically rigorous: ∂/∂z(Tn) is proportional to U{n-1}.","category":"section"},{"location":"pages/tau_method/#First-Order-Formulation-(Dedalus-Style)","page":"The Tau Method for Boundary Conditions","title":"First-Order Formulation (Dedalus Style)","text":"Instead of directly using the Laplacian, introduce an auxiliary gradient variable with tau correction:\n\n# Tau fields\ntau_u1 = VectorField(dist, coords, \"tau_u1\", (x_basis,))  # For gradient substitution\ntau_u2 = VectorField(dist, coords, \"tau_u2\", (x_basis,))  # For evolution equation\n\n# Lift basis from derivative basis\nlift_basis = derivative_basis(z_basis)\n\n# First-order gradient substitution with tau correction\n# grad_u = ∇(u) + ez*lift(tau_u1, lift_basis, -1)\nadd_substitution!(problem, \"grad_u\", \"∇(u) + ez*lift(tau_u1)\")\n\n# Continuity: trace(grad_u) + tau_p = 0\nadd_equation!(problem, \"trace(grad_u) + tau_p = 0\")\n\n# Momentum using div(grad_u) instead of Δ(u)\nadd_equation!(problem, \"∂t(u) - nu*div(grad_u) + ∇(p) + lift(tau_u2) = -u⋅∇(u)\")","category":"section"},{"location":"pages/tau_method/#Why-First-Order-is-Better","page":"The Tau Method for Boundary Conditions","title":"Why First-Order is Better","text":"Aspect Second-Order (Δ) First-Order (div(grad))\nTau fields needed 1 per equation 2 per equation\nMatrix conditioning Can be poor for high N Better conditioning\nBC flexibility Standard More control\nDedalus default No Yes","category":"section"},{"location":"pages/tau_method/#When-to-Use-Each","page":"The Tau Method for Boundary Conditions","title":"When to Use Each","text":"Second-Order (simpler):\n\nQuick prototyping\nModerate resolution (N < 128)\nLow-order problems (2nd order PDEs)\n\nFirst-Order (recommended):\n\nProduction runs\nHigh resolution (N > 128)\nHigh-order problems (4th order, biharmonic)\nWhen conditioning issues arise","category":"section"},{"location":"pages/tau_method/#Mathematical-Details","page":"The Tau Method for Boundary Conditions","title":"Mathematical Details","text":"","category":"section"},{"location":"pages/tau_method/#The-Tau-Error","page":"The Tau Method for Boundary Conditions","title":"The Tau Error","text":"By replacing PDE equations with BCs, we introduce a \"tau error\" in the original equations. The modified solution u_τ satisfies:\n\nmathcalLu_tau = f + sum_k=1^K tau_k phi_k(z)\n\nwhere:\n\nL is the differential operator\nτ_k are the tau corrections (unknown)\nφ_k(z) are basis functions (typically highest-order Chebyshev polynomials)\n\nThe key result: For smooth solutions, the tau error is spectrally small—it decays faster than any polynomial in N.","category":"section"},{"location":"pages/tau_method/#Condition-Number-Considerations","page":"The Tau Method for Boundary Conditions","title":"Condition Number Considerations","text":"The tau method can lead to ill-conditioned matrices, especially for:\n\nHigh-order problems (4th order and above)\nLarge N (many spectral modes)\nStiff problems\n\nStrategies to improve conditioning:\n\nRow scaling: Scale tau rows to have similar magnitude to PDE rows\nPreconditioning: Use appropriate preconditioners\nAlternative formulations: Use integral formulations or different bases","category":"section"},{"location":"pages/tau_method/#Worked-Example:-Heat-Equation","page":"The Tau Method for Boundary Conditions","title":"Worked Example: Heat Equation","text":"","category":"section"},{"location":"pages/tau_method/#Problem-Setup","page":"The Tau Method for Boundary Conditions","title":"Problem Setup","text":"fracpartial upartial t = nu fracpartial^2 upartial z^2 quad z in -1 1\n\nwith:\n\nu(-1, t) = 0 (left boundary)\nu(+1, t) = 0 (right boundary)\nu(z, 0) = sin(πz) (initial condition)","category":"section"},{"location":"pages/tau_method/#Spectral-Formulation","page":"The Tau Method for Boundary Conditions","title":"Spectral Formulation","text":"Expand: u(z,t) = Σ aₙ(t) Tₙ(z)\nGalerkin projection of PDE:\n\nfracd a_ndt = nu sum_m D^(2)_nm a_m quad n = 0  N-3\n\nBoundary conditions (tau):\n\nsum_m a_m T_m(-1) = 0 quad text(row N-2)\n\nsum_m a_m T_m(+1) = 0 quad text(row N-1)","category":"section"},{"location":"pages/tau_method/#Matrix-Form","page":"The Tau Method for Boundary Conditions","title":"Matrix Form","text":"fracdmathbfadt = mathbfM^-1 mathbfL mathbfa\n\nwhere M is the tau-modified mass matrix and L is the tau-modified operator.","category":"section"},{"location":"pages/tau_method/#Common-Pitfalls-and-Solutions","page":"The Tau Method for Boundary Conditions","title":"Common Pitfalls and Solutions","text":"","category":"section"},{"location":"pages/tau_method/#Pitfall-1:-Wrong-Number-of-BCs","page":"The Tau Method for Boundary Conditions","title":"Pitfall 1: Wrong Number of BCs","text":"Problem: Specifying too few or too many boundary conditions.\n\nSolution: Match the number of BCs to the operator order in each direction.","category":"section"},{"location":"pages/tau_method/#Pitfall-2:-Incompatible-BCs","page":"The Tau Method for Boundary Conditions","title":"Pitfall 2: Incompatible BCs","text":"Problem: Boundary conditions that are inconsistent with the PDE.\n\nSolution: Check physical consistency; ensure BCs don't over-constrain the problem.","category":"section"},{"location":"pages/tau_method/#Pitfall-3:-Ill-Conditioning","page":"The Tau Method for Boundary Conditions","title":"Pitfall 3: Ill-Conditioning","text":"Problem: Matrix becomes nearly singular for large N.\n\nSolution: Use row scaling, consider alternative formulations, or reduce N.","category":"section"},{"location":"pages/tau_method/#Pitfall-4:-Tau-Error-Accumulation","page":"The Tau Method for Boundary Conditions","title":"Pitfall 4: Tau Error Accumulation","text":"Problem: In time-dependent problems, tau errors can accumulate.\n\nSolution: Use appropriate time-stepping schemes; IMEX methods handle this well.","category":"section"},{"location":"pages/tau_method/#Historical-Note","page":"The Tau Method for Boundary Conditions","title":"Historical Note","text":"The tau method was introduced by Cornelius Lanczos in 1938 as a way to obtain approximate solutions to differential equations using polynomial expansions. It was later refined and popularized in the context of spectral methods by researchers including Steven Orszag and David Gottlieb in the 1970s-80s.\n\nThe name \"tau\" (τ) comes from Lanczos's notation for the error terms introduced by truncating the polynomial expansion and enforcing boundary conditions.","category":"section"},{"location":"pages/tau_method/#References","page":"The Tau Method for Boundary Conditions","title":"References","text":"","category":"section"},{"location":"pages/tau_method/#Textbooks","page":"The Tau Method for Boundary Conditions","title":"Textbooks","text":"Canuto, C., Hussaini, M.Y., Quarteroni, A., & Zang, T.A. (2006). Spectral Methods: Fundamentals in Single Domains. Springer.\nChapter 3: Tau and Galerkin methods in detail\nExcellent mathematical rigor\nBoyd, J.P. (2001). Chebyshev and Fourier Spectral Methods (2nd ed.). Dover.\nChapter 6: Boundary conditions\nFreely available online, very accessible\nTrefethen, L.N. (2000). Spectral Methods in MATLAB. SIAM.\nChapter 7: Boundary value problems\nPractical implementation focus\nPeyret, R. (2002). Spectral Methods for Incompressible Viscous Flow. Springer.\nApplication to fluid dynamics\nDetailed treatment of Navier-Stokes","category":"section"},{"location":"pages/tau_method/#Key-Papers","page":"The Tau Method for Boundary Conditions","title":"Key Papers","text":"Lanczos, C. (1938). \"Trigonometric interpolation of empirical and analytical functions.\" Journal of Mathematics and Physics, 17(1-4), 123-199.\nOriginal tau method paper\nGottlieb, D., & Orszag, S.A. (1977). Numerical Analysis of Spectral Methods: Theory and Applications. SIAM.\nClassic reference for spectral methods\nOrszag, S.A. (1971). \"Accurate solution of the Orr-Sommerfeld stability equation.\" Journal of Fluid Mechanics, 50(4), 689-703.\nInfluential application to hydrodynamic stability","category":"section"},{"location":"pages/tau_method/#Online-Resources","page":"The Tau Method for Boundary Conditions","title":"Online Resources","text":"Dedalus Project Documentation: https://dedalus-project.readthedocs.io/\nModern spectral solver using tau method\nExcellent tutorials and examples\nLloyd N. Trefethen's Spectral Methods Course Notes: Available at https://people.maths.ox.ac.uk/trefethen/","category":"section"},{"location":"pages/tau_method/#See-Also","page":"The Tau Method for Boundary Conditions","title":"See Also","text":"Boundary Conditions Tutorial: Practical BC examples\nBases: Spectral bases (Chebyshev, Fourier, etc.)\nSolvers: Using the tau method in solvers\nAPI: Problems: Adding boundary conditions programmatically","category":"section"},{"location":"pages/timesteppers/#Time-Steppers","page":"Time Steppers","title":"Time Steppers","text":"Time steppers integrate PDEs forward in time.","category":"section"},{"location":"pages/timesteppers/#Overview","page":"Time Steppers","title":"Overview","text":"Tarang.jl provides several families of time integration schemes:\n\nFamily Type Best For\nRK IMEX Runge-Kutta General problems\nCNAB Multistep IMEX Moderately stiff\nSBDF Multistep IMEX Stiff problems\nETD Exponential Time Differencing Very stiff linear terms","category":"section"},{"location":"pages/timesteppers/#IMEX-Runge-Kutta","page":"Time Steppers","title":"IMEX Runge-Kutta","text":"Following Dedalus convention, all RK methods use Additive Runge-Kutta (ARK) schemes:\n\nLinear terms (LHS) are treated implicitly\nNonlinear terms (RHS) are treated explicitly\n\nThis allows stable integration of stiff problems with larger timesteps.","category":"section"},{"location":"pages/timesteppers/#RK111","page":"Time Steppers","title":"RK111","text":"First-order IMEX method (Backward Euler / Forward Euler).\n\ntimestepper = RK111()\n\nImplicit part: Backward Euler (linear terms)\nExplicit part: Forward Euler (nonlinear terms)\nAccuracy: O(Δt)\nUse case: Testing, simple problems","category":"section"},{"location":"pages/timesteppers/#RK222","page":"Time Steppers","title":"RK222","text":"Second-order, 2-stage IMEX Runge-Kutta (Ascher, Ruuth, Spiteri 1997).\n\ntimestepper = RK222()\n\nImplicit part: 2-stage SDIRK (γ = 1 - 1/√2)\nExplicit part: 2-stage explicit RK\nAccuracy: O(Δt²)\nStability: L-stable\nUse case: General purpose (recommended)","category":"section"},{"location":"pages/timesteppers/#RK443","page":"Time Steppers","title":"RK443","text":"Third-order, 4-stage IMEX Runge-Kutta (Kennedy & Carpenter ARK3(2)4L[2]SA).\n\ntimestepper = RK443()\n\nImplicit part: 4-stage ESDIRK (γ ≈ 0.4359)\nExplicit part: 4-stage explicit RK\nAccuracy: O(Δt³)\nStability: L-stable\nUse case: High accuracy requirements, stiff problems","category":"section"},{"location":"pages/timesteppers/#Multistep-IMEX-Methods","page":"Time Steppers","title":"Multistep IMEX Methods","text":"Implicit-Explicit methods treat stiff (linear) terms implicitly and non-stiff (nonlinear) terms explicitly.","category":"section"},{"location":"pages/timesteppers/#CNAB-(Crank-Nicolson-Adams-Bashforth)","page":"Time Steppers","title":"CNAB (Crank-Nicolson Adams-Bashforth)","text":"CNAB1()  # 1st order\nCNAB2()  # 2nd order (recommended)\n\nLinear terms: Crank-Nicolson (implicit)\nNonlinear terms: Adams-Bashforth (explicit)\nUse case: Diffusion-dominated flows","category":"section"},{"location":"pages/timesteppers/#SBDF-(Semi-implicit-BDF)","page":"Time Steppers","title":"SBDF (Semi-implicit BDF)","text":"SBDF1()  # 1st order\nSBDF2()  # 2nd order (recommended)\nSBDF3()  # 3rd order\nSBDF4()  # 4th order\n\nLinear terms: BDF (implicit)\nNonlinear terms: Extrapolation (explicit)\nUse case: Stiff problems, high Re flows","category":"section"},{"location":"pages/timesteppers/#Exponential-Time-Differencing-(ETD)","page":"Time Steppers","title":"Exponential Time Differencing (ETD)","text":"Exponential integrators solve the linear part of the ODE exactly using matrix exponentials, while treating nonlinear terms explicitly. This is fundamentally different from IMEX methods.","category":"section"},{"location":"pages/timesteppers/#How-ETD-Works","page":"Time Steppers","title":"How ETD Works","text":"For the semi-linear ODE:\n\nfracdudt = Lu + N(u)\n\nwhere L is the linear operator and N(u) is the nonlinear term, ETD methods use the variation of constants formula:\n\nu(t_n+1) = e^h L u(t_n) + int_0^h e^(h-tau)L N(u(t_n + tau)) dtau\n\nThe key insight is that exp(hL) propagates the linear part exactly, eliminating stability constraints from stiff linear terms entirely.","category":"section"},{"location":"pages/timesteppers/#ETD-vs-IMEX","page":"Time Steppers","title":"ETD vs IMEX","text":"Aspect IMEX ETD\nLinear terms Implicit (approximate) Exponential (exact)\nLinear solve Yes, every step No (but needs exp(hL))\nStiffness Limited by approximation No limit from L\nBest for General stiff problems Diagonal L (Fourier)","category":"section"},{"location":"pages/timesteppers/#ETD_RK222","page":"Time Steppers","title":"ETD_RK222","text":"Second-order exponential Runge-Kutta method (Cox-Matthews 2002).\n\ntimestepper = ETD_RK222()\n\nAlgorithm:\n\nStage 1 (predictor): a_n = exp(hL) * u_n\n                     c = a_n + h * phi_1(hL) * N(u_n)\nStage 2 (corrector): u_{n+1} = a_n + h * phi_1(hL) * N(c)\n\nwhere phi_1(z) = (exp(z) - 1) / z\n\nLinear part: Exact via exp(hL) and phi functions\nNonlinear part: Explicit 2-stage Runge-Kutta\nAccuracy: O(dt^2)\nStability: Unconditionally stable for linear terms\nUse case: Very stiff diffusion, reaction-diffusion","category":"section"},{"location":"pages/timesteppers/#ETD_CNAB2","page":"Time Steppers","title":"ETD_CNAB2","text":"Second-order exponential Adams-Bashforth method.\n\ntimestepper = ETD_CNAB2()\n\nAlgorithm:\n\nu_{n+1} = exp(hL) * u_n + h * phi_1(hL) * N_AB2\nN_AB2 = (3/2) * N(u_n) - (1/2) * N(u_{n-1})\n\nLinear part: Exact via exponential propagator\nNonlinear part: Adams-Bashforth extrapolation\nAccuracy: O(dt^2)\nStartup: Uses ETD_RK222 for first step\nUse case: Long time integrations with stiff diffusion","category":"section"},{"location":"pages/timesteppers/#ETD_SBDF2","page":"Time Steppers","title":"ETD_SBDF2","text":"Second-order exponential multistep method.\n\ntimestepper = ETD_SBDF2()\n\nAlgorithm: Uses proper 2-step exponential integration with phi1 and phi2 functions:\n\nu_{n+1} = exp(hL) * u_n + h * phi_1(hL) * N_n + h^2 * phi_2(hL) * (N_n - N_{n-1}) / h\n\nLinear part: Exact via exponential + phi functions\nNonlinear part: BDF-style extrapolation\nAccuracy: O(dt^2)\nStartup: Uses ETD_RK222 for first step\nUse case: Stiff problems requiring multistep efficiency","category":"section"},{"location":"pages/timesteppers/#Phi-Functions","page":"Time Steppers","title":"Phi Functions","text":"ETD methods use phi functions defined as:\n\nphi_0(z) = e^z\n\nphi_1(z) = frace^z - 1z\n\nphi_2(z) = frace^z - 1 - zz^2\n\nThese are computed stably even for small z using Taylor series or Krylov methods.","category":"section"},{"location":"pages/timesteppers/#When-to-Use-ETD","page":"Time Steppers","title":"When to Use ETD","text":"Ideal for:\n\nFourier-based spectral methods (L is diagonal)\nVery stiff diffusion (high viscosity/diffusivity)\nReaction-diffusion equations\nProblems where IMEX requires very small dt\n\nLess suitable for:\n\nNon-diagonal L (Chebyshev with BCs) - use IMEX instead\nLarge dense systems (exp(hL) is expensive)\nProblems with complex boundary conditions","category":"section"},{"location":"pages/timesteppers/#Requirements","page":"Time Steppers","title":"Requirements","text":"ETD methods require:\n\nThe linear operator L stored as \"L_matrix\" in problem parameters\nOptionally, mass matrix M as \"M_matrix\"\n\n# Setup L matrix for ETD\nproblem.parameters[\"L_matrix\"] = build_linear_operator(domain)\n\n# Use ETD solver\nsolver = InitialValueSolver(problem, ETD_RK222(); dt=1e-2)","category":"section"},{"location":"pages/timesteppers/#Example:-1D-Heat-Equation-with-ETD","page":"Time Steppers","title":"Example: 1D Heat Equation with ETD","text":"using Tarang\n\n# Setup Fourier domain (L is diagonal)\ncoords = CartesianCoordinates(\"x\")\ndist = Distributor(coords; mesh=(1,))\nx_basis = RealFourier(coords[\"x\"]; size=128, bounds=(0.0, 2*pi))\ndomain = Domain(dist, (x_basis,))\n\n# Temperature field\nT = ScalarField(dist, \"T\", domain.bases, Float64)\n\n# Build diagonal diffusion operator in Fourier space\n# For Fourier: d^2/dx^2 -> -k^2\nkx = wavenumbers(x_basis)\nL_diag = -nu * kx.^2  # Diagonal in spectral space\nproblem.parameters[\"L_matrix\"] = Diagonal(L_diag)\n\n# ETD solver - no stability limit from diffusion!\nsolver = InitialValueSolver(problem, ETD_RK222(); dt=0.1)\n\nwhile solver.sim_time < t_end\n    step!(solver)\nend","category":"section"},{"location":"pages/timesteppers/#References","page":"Time Steppers","title":"References","text":"Cox, S. M., & Matthews, P. C. (2002). \"Exponential Time Differencing for Stiff Systems\". J. Comput. Phys. 176, 430-455.\nHochbruck, M., & Ostermann, A. (2010). \"Exponential integrators\". Acta Numerica 19, 209-286.\nKassam, A.-K., & Trefethen, L. N. (2005). \"Fourth-Order Time Stepping for Stiff PDEs\". SIAM J. Sci. Comput. 26(4), 1214-1233.","category":"section"},{"location":"pages/timesteppers/#Choosing-a-Timestepper","page":"Time Steppers","title":"Choosing a Timestepper","text":"","category":"section"},{"location":"pages/timesteppers/#By-Problem-Stiffness","page":"Time Steppers","title":"By Problem Stiffness","text":"Stiffness Indicator Recommended\nMild Moderate Re RK222, RK443\nModerate Higher Re CNAB2, SBDF2\nStiff High Re, requires tiny Δt SBDF3, SBDF4\nVery stiff (diagonal L) Extreme diffusion ETDRK222, ETDSBDF2","category":"section"},{"location":"pages/timesteppers/#By-Physics","page":"Time Steppers","title":"By Physics","text":"Problem Type Recommended\nGeneral purpose RK222, RK443\nDiffusion-dominated CNAB2, SBDF2\nHigh Rayleigh number SBDF2, SBDF3\nTurbulence RK443 or SBDF2\nReaction-diffusion (Fourier) ETD_RK222\nVery stiff diffusion (Fourier) ETD_SBDF2","category":"section"},{"location":"pages/timesteppers/#Stability-Analysis","page":"Time Steppers","title":"Stability Analysis","text":"","category":"section"},{"location":"pages/timesteppers/#CFL-Condition-(Explicit)","page":"Time Steppers","title":"CFL Condition (Explicit)","text":"For explicit methods, the timestep is limited by:\n\nDelta t  fracC cdot Delta xu_max\n\nwhere C is the CFL number (typically 0.5-1.0).","category":"section"},{"location":"pages/timesteppers/#Diffusive-Stability-(IMEX)","page":"Time Steppers","title":"Diffusive Stability (IMEX)","text":"IMEX methods allow larger timesteps by treating diffusion implicitly:\n\nDelta t  fracC cdot Delta xu_max\n\nonly constrained by advection, not diffusion.","category":"section"},{"location":"pages/timesteppers/#Adaptive-Time-Stepping","page":"Time Steppers","title":"Adaptive Time Stepping","text":"","category":"section"},{"location":"pages/timesteppers/#With-CFL","page":"Time Steppers","title":"With CFL","text":"cfl = CFL(problem, safety=0.5)\nadd_velocity!(cfl, u)\n\nwhile solver.sim_time < t_end\n    dt = compute_timestep(cfl)\n    step!(solver, dt)\nend","category":"section"},{"location":"pages/timesteppers/#Manual-Adjustment","page":"Time Steppers","title":"Manual Adjustment","text":"# Reduce timestep if solver becomes unstable\nif any(isnan, field.data_g)\n    solver.dt *= 0.5\n    error(\"NaN detected, reduce timestep\")\nend","category":"section"},{"location":"pages/timesteppers/#Multi-Step-Methods","page":"Time Steppers","title":"Multi-Step Methods","text":"SBDF and CNAB methods require previous time level data:\n\n# First step uses lower order\n# SBDF2 uses SBDF1 for first step\n# Automatic in Tarang\n\nsolver = InitialValueSolver(problem, SBDF2(); dt=0.001)\n# First step: SBDF1\n# Subsequent steps: SBDF2","category":"section"},{"location":"pages/timesteppers/#Performance-Comparison","page":"Time Steppers","title":"Performance Comparison","text":"Method Evaluations/Step Memory Stability\nRK111 1 + solve Medium Good (L-stable)\nRK222 2 + solve Medium Very good (L-stable)\nRK443 4 + solve Higher Best (L-stable)\nCNAB2 1 + solve Medium Very good\nSBDF2 1 + solve Medium Excellent\nETD_RK222 2 + exp(hL) Medium Exact (linear)\nETD_CNAB2 1 + exp(hL) Medium Exact (linear)\nETD_SBDF2 1 + exp(hL) Medium Exact (linear)","category":"section"},{"location":"pages/timesteppers/#Example-Usage","page":"Time Steppers","title":"Example Usage","text":"","category":"section"},{"location":"pages/timesteppers/#Runge-Kutta-IMEX","page":"Time Steppers","title":"Runge-Kutta IMEX","text":"using Tarang\n\n# Problem setup\nproblem = IVP([u, p])\n# ... add equations ...\n\n# IMEX RK solver - handles stiff diffusion implicitly\nsolver = InitialValueSolver(problem, RK443(); dt=1e-3)\n\n# Larger timestep possible due to implicit treatment of linear terms\nwhile solver.sim_time < t_end\n    step!(solver)\nend","category":"section"},{"location":"pages/timesteppers/#Multistep-IMEX-(SBDF)","page":"Time Steppers","title":"Multistep IMEX (SBDF)","text":"# Same problem, multistep IMEX solver\nsolver = InitialValueSolver(problem, SBDF2(); dt=1e-3)\n\n# Larger timestep possible\nwhile solver.sim_time < t_end\n    step!(solver)\nend","category":"section"},{"location":"pages/timesteppers/#Exponential-Time-Differencing-(ETD)-2","page":"Time Steppers","title":"Exponential Time Differencing (ETD)","text":"using LinearAlgebra\n\n# For Fourier-based problems with diagonal L\n# Build the linear operator matrix\nL_matrix = build_diffusion_operator(domain)  # Diagonal in spectral space\nproblem.parameters[\"L_matrix\"] = L_matrix\n\n# ETD solver - no stability limit from stiff linear terms!\nsolver = InitialValueSolver(problem, ETD_RK222(); dt=0.1)\n\n# Can use much larger timesteps when L is very stiff\nwhile solver.sim_time < t_end\n    step!(solver)\nend","category":"section"},{"location":"pages/timesteppers/#Stochastic-Forcing","page":"Time Steppers","title":"Stochastic Forcing","text":"For turbulence simulations requiring external energy injection, see Stochastic Forcing.\n\nKey points:\n\nForcing is generated once per timestep, constant across substeps\nRequired for proper Stratonovich calculus treatment\nSupports ring, isotropic, and custom forcing spectra\n\n# Quick example\nforcing = StochasticForcing(\n    field_size = (64, 64),\n    forcing_rate = 0.1,\n    k_forcing = 4.0,\n    dt = solver.dt\n)\nset_forcing!(solver.timestepper_state, forcing)","category":"section"},{"location":"pages/timesteppers/#See-Also","page":"Time Steppers","title":"See Also","text":"Solvers: Using time steppers with solvers\nCFL and Analysis: Adaptive time stepping\nStochastic Forcing: External forcing for turbulence\nAPI: Timesteppers: Complete reference","category":"section"},{"location":"pages/domains/#Domains","page":"Domains","title":"Domains","text":"Domains combine spectral bases with the MPI distributor to define the computational space.","category":"section"},{"location":"pages/domains/#Creating-a-Domain","page":"Domains","title":"Creating a Domain","text":"using Tarang\n\n# Setup coordinates and distributor\ncoords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords; mesh=(2, 2), dtype=Float64)\n\n# Define spectral bases\nx_basis = RealFourier(coords[\"x\"]; size=128, bounds=(0.0, 2π))\nz_basis = ChebyshevT(coords[\"z\"]; size=64, bounds=(0.0, 1.0))\n\n# Create domain\ndomain = Domain(dist, (x_basis, z_basis))","category":"section"},{"location":"pages/domains/#Domain-Properties","page":"Domains","title":"Domain Properties","text":"domain.distributor    # MPI distributor\ndomain.bases          # Tuple of spectral bases\ndomain.ndim           # Number of dimensions\ndomain.shape          # Global grid shape\ndomain.local_shape    # Local grid shape on this process","category":"section"},{"location":"pages/domains/#Quick-Domain-Creation","page":"Domains","title":"Quick Domain Creation","text":"Tarang provides convenience functions for common domain types:","category":"section"},{"location":"pages/domains/#Periodic-Box","page":"Domains","title":"Periodic Box","text":"# 2D doubly-periodic domain\ndomain, dist = create_2d_periodic_domain(\n    Lx=2π, Ly=2π,    # Domain size\n    Nx=128, Ny=128,   # Resolution\n    mesh=(2, 2)       # MPI processes\n)\n\n# 3D triply-periodic domain\ndomain, dist = create_3d_periodic_domain(\n    Lx=2π, Ly=2π, Lz=2π,\n    Nx=64, Ny=64, Nz=64,\n    mesh=(2, 2, 2)\n)","category":"section"},{"location":"pages/domains/#Channel-Domain","page":"Domains","title":"Channel Domain","text":"# Periodic in x, bounded in z\ndomain, dist = create_channel_domain(\n    Lx=4.0, Lz=1.0,\n    Nx=256, Nz=64,\n    mesh=(2, 2)\n)","category":"section"},{"location":"pages/domains/#Box-Domain","page":"Domains","title":"Box Domain","text":"# Bounded in all directions\ndomain, dist = create_box_domain(\n    Lx=1.0, Ly=1.0, Lz=1.0,\n    Nx=64, Ny=64, Nz=64,\n    mesh=(2, 2, 2)\n)","category":"section"},{"location":"pages/domains/#Working-with-Domains","page":"Domains","title":"Working with Domains","text":"","category":"section"},{"location":"pages/domains/#Creating-Fields","page":"Domains","title":"Creating Fields","text":"# ScalarField\nT = ScalarField(dist, \"T\", domain.bases, Float64)\n\n# VectorField\nu = VectorField(dist, coords, \"u\", domain.bases, Float64)","category":"section"},{"location":"pages/domains/#Grid-Information","page":"Domains","title":"Grid Information","text":"# Get global grid points for each axis\nfor (i, basis) in enumerate(domain.bases)\n    grid = get_grid(basis)\n    println(\"Axis $i: $(length(grid)) points\")\nend\n\n# Get local grid portion\nlocal_grid = get_local_grid(domain, axis)","category":"section"},{"location":"pages/domains/#Domain-Dimensions","page":"Domains","title":"Domain Dimensions","text":"# Total number of grid points\ntotal_points = prod(domain.shape)\n\n# Number of spectral modes\ntotal_modes = prod(basis.size for basis in domain.bases)\n\n# Domain volume\nvolume = prod(basis.bounds[2] - basis.bounds[1] for basis in domain.bases)","category":"section"},{"location":"pages/domains/#Multi-Dimensional-Layouts","page":"Domains","title":"Multi-Dimensional Layouts","text":"","category":"section"},{"location":"pages/domains/#Grid-Space-(:g)","page":"Domains","title":"Grid Space (:g)","text":"Data stored as real values at collocation points:\n\nTarang.ensure_layout!(field, :g)\n# field.data_g contains real grid values\n# Shape: (Nx, Nz) for 2D","category":"section"},{"location":"pages/domains/#Coefficient-Space-(:c)","page":"Domains","title":"Coefficient Space (:c)","text":"Data stored as spectral coefficients:\n\nTarang.ensure_layout!(field, :c)\n# field.data_c contains spectral coefficients\n# Shape depends on basis types","category":"section"},{"location":"pages/domains/#Layout-Transforms","page":"Domains","title":"Layout Transforms","text":"# Grid to spectral\nTarang.ensure_layout!(field, :c)\n\n# Spectral to grid\nTarang.ensure_layout!(field, :g)\n\n# Check current layout\ncurrent_layout = field.current_layout  # :g or :c","category":"section"},{"location":"pages/domains/#Domain-Decomposition","page":"Domains","title":"Domain Decomposition","text":"The domain is distributed across MPI processes:\n\n2D Domain (128 × 64) on 4 processes (2×2 mesh):\n\nProcess 0: x ∈ [0:64], z ∈ [0:32]\nProcess 1: x ∈ [64:128], z ∈ [0:32]\nProcess 2: x ∈ [0:64], z ∈ [32:64]\nProcess 3: x ∈ [64:128], z ∈ [32:64]","category":"section"},{"location":"pages/domains/#Accessing-Local-Data","page":"Domains","title":"Accessing Local Data","text":"# Local data array\nlocal_data = field.data_g\n\n# Local array size\nlocal_size = size(local_data)\n\n# Global index range for this process (internal function)\nstart_idx, end_idx = Tarang.local_indices(dist, axis, global_size)","category":"section"},{"location":"pages/domains/#Coordinate-Systems","page":"Domains","title":"Coordinate Systems","text":"","category":"section"},{"location":"pages/domains/#Cartesian","page":"Domains","title":"Cartesian","text":"coords = CartesianCoordinates(\"x\", \"y\", \"z\")\n# dx, dy, dz derivatives\n# grad, div, curl, lap in standard form","category":"section"},{"location":"pages/domains/#Future-Support","page":"Domains","title":"Future Support","text":"Spherical and cylindrical coordinates are planned:\n\n# Planned API (not yet implemented)\ncoords = SphericalCoordinates(\"r\", \"θ\", \"φ\")\ncoords = CylindricalCoordinates(\"r\", \"θ\", \"z\")","category":"section"},{"location":"pages/domains/#Performance-Considerations","page":"Domains","title":"Performance Considerations","text":"","category":"section"},{"location":"pages/domains/#Mesh-Selection","page":"Domains","title":"Mesh Selection","text":"Match mesh to domain aspect ratio:\n\nDomain Aspect Mesh\nSquare (Lx ≈ Lz) (n, n)\nWide (Lx > Lz) (2n, n)\nTall (Lx < Lz) (n, 2n)","category":"section"},{"location":"pages/domains/#Resolution-Balance","page":"Domains","title":"Resolution Balance","text":"More modes in directions with:\nSmaller scales\nSharper gradients\nMore active dynamics","category":"section"},{"location":"pages/domains/#Memory-Usage","page":"Domains","title":"Memory Usage","text":"# Estimate memory per field\nbytes_per_element = 8  # Float64\ntotal_elements = prod(domain.shape)\nmemory_per_field = total_elements * bytes_per_element\n\n# Per process\nmemory_per_process = memory_per_field / dist.size","category":"section"},{"location":"pages/domains/#See-Also","page":"Domains","title":"See Also","text":"Coordinates: Coordinate systems\nBases: Spectral basis types\nFields: Creating fields on domains\nAPI: Domains: Complete reference","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Tutorial:-3D-Turbulence-Simulation","page":"Tutorial: 3D Turbulence Simulation","title":"Tutorial: 3D Turbulence Simulation","text":"This tutorial demonstrates setting up and running a 3D turbulent flow simulation using Tarang.jl.","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Physical-Problem","page":"Tutorial: 3D Turbulence Simulation","title":"Physical Problem","text":"We simulate decaying turbulence in a triply-periodic box, governed by the incompressible Navier-Stokes equations:\n\nbeginaligned\nfracpartial mathbfupartial t + mathbfu cdot nabla mathbfu = -nabla p + nu nabla^2 mathbfu + mathbff \nnabla cdot mathbfu = 0\nendaligned\n\nwhere:\n\nmathbfu = (u v w)\nis the velocity field\np\nis the pressure (divided by density)\nnu\nis the kinematic viscosity\nmathbff\nis an optional forcing term","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Domain-Setup","page":"Tutorial: 3D Turbulence Simulation","title":"Domain Setup","text":"","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Coordinates-and-Distribution","page":"Tutorial: 3D Turbulence Simulation","title":"Coordinates and Distribution","text":"using Tarang\nusing MPI\n\nMPI.Init()\nrank = MPI.Comm_rank(MPI.COMM_WORLD)\n\n# 3D Cartesian coordinates\ncoords = CartesianCoordinates(\"x\", \"y\", \"z\")\n\n# Distribute across MPI processes\n# For 8 processes: mesh=(2, 2, 2)\n# For 16 processes: mesh=(4, 2, 2) or (2, 4, 2)\ndist = Distributor(coords, mesh=(2, 2, 2))","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Spectral-Bases","page":"Tutorial: 3D Turbulence Simulation","title":"Spectral Bases","text":"All directions are periodic, so we use Fourier bases:\n\n# Domain size (typically 2π for convenience)\nL = 2π\n\n# Resolution (power of 2 for optimal FFT)\nN = 128  # 128^3 grid points\n\n# Fourier bases for all directions\nx_basis = RealFourier(coords[\"x\"]; size=N, bounds=(0.0, L), dealias=2/3)\ny_basis = RealFourier(coords[\"y\"]; size=N, bounds=(0.0, L), dealias=2/3)\nz_basis = RealFourier(coords[\"z\"]; size=N, bounds=(0.0, L), dealias=2/3)\n\ndomain = Domain(dist, (x_basis, y_basis, z_basis))\n\nnote: Dealiasing\nThe dealias=2/3 parameter enables the 3/2 rule for dealiasing nonlinear terms, essential for accurate turbulence simulations.\n\ninfo: No Tau Fields Needed\nSince all directions use periodic Fourier bases, no tau fields or boundary conditions are required. The Fourier representation automatically enforces periodicity. Tau fields and the lift() operator are only needed for non-periodic directions (e.g., Chebyshev bases with walls). See Boundary Conditions Tutorial for problems with walls.","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Fields-and-Problem-Definition","page":"Tutorial: 3D Turbulence Simulation","title":"Fields and Problem Definition","text":"# Velocity field (3 components)\nu = VectorField(dist, coords, \"u\", (x_basis, y_basis, z_basis))\n\n# Pressure field\np = ScalarField(dist, \"p\", (x_basis, y_basis, z_basis))\n\n# Problem definition (use the vector field directly)\nproblem = IVP([u, p])\n\n# Parameters\nRe = 1000.0  # Reynolds number (based on domain scale)\nnu = 1.0 / Re\n\n# Add parameter substitutions (Dedalus-style)\nadd_substitution!(problem, \"nu\", nu)\n\n# Momentum equation (single vector equation)\nadd_equation!(problem, \"∂t(u) - nu*Δ(u) + ∇(p) = -u⋅∇(u)\")\n\n# Continuity equation\nadd_equation!(problem, \"div(u) = 0\")\n\nnote: Vector Equation Syntax\nTarang.jl uses Dedalus-style string equations with full vector support:∂t(u) - time derivative of vector field\nΔ(u) - Laplacian of vector field (component-wise)\n∇(p) - gradient of scalar (returns vector)\ndiv(u) - divergence of vector (returns scalar)\nu⋅∇(u) - advection term (u·∇)u","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Initial-Conditions","page":"Tutorial: 3D Turbulence Simulation","title":"Initial Conditions","text":"","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Taylor-Green-Vortex","page":"Tutorial: 3D Turbulence Simulation","title":"Taylor-Green Vortex","text":"A classic test case for turbulence codes:\n\nfunction initialize_taylor_green!(u, L)\n    ux, uy, uz = u.components\n\n    # Get grid data\n    ux_grid = get_grid_data(ux)\n    uy_grid = get_grid_data(uy)\n    uz_grid = get_grid_data(uz)\n\n    # Get local grid coordinates\n    x = get_grid(ux.bases[1])\n    y = get_grid(ux.bases[2])\n    z = get_grid(ux.bases[3])\n\n    # Taylor-Green initial condition\n    for i in eachindex(x), j in eachindex(y), k in eachindex(z)\n        ux_grid[i,j,k] =  sin(x[i]) * cos(y[j]) * cos(z[k])\n        uy_grid[i,j,k] = -cos(x[i]) * sin(y[j]) * cos(z[k])\n        uz_grid[i,j,k] = 0.0\n    end\n\n    # Transform to spectral space\n    to_spectral!(ux)\n    to_spectral!(uy)\n    to_spectral!(uz)\nend\n\ninitialize_taylor_green!(u, L)","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Random-Initial-Conditions","page":"Tutorial: 3D Turbulence Simulation","title":"Random Initial Conditions","text":"For studying developed turbulence:\n\nusing Random\n\nfunction initialize_random!(u, energy_spectrum; seed=42)\n    Random.seed!(seed + MPI.Comm_rank(MPI.COMM_WORLD))\n\n    for component in u.components\n        data = get_grid_data(component)\n        data .= randn(size(data))\n        to_spectral!(component)\n    end\n\n    # Project to divergence-free (optional, done by solver)\n    # Scale to desired energy level\n    # ... energy scaling code ...\nend","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Solver-Setup","page":"Tutorial: 3D Turbulence Simulation","title":"Solver Setup","text":"# Timestepper selection\n# - RK443 for IMEX Runge-Kutta integration\n# - SBDF2/SBDF3 for very stiff problems at high Re\ntimestepper = RK443()\n\n# Create solver\nsolver = InitialValueSolver(problem, timestepper, dt=1e-3)\n\n# CFL condition for adaptive timestep\ncfl = CFL(problem, safety=0.5, max_change=1.5)\nadd_velocity!(cfl, u)\ncfl.max_dt = 0.01","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Analysis-and-Output","page":"Tutorial: 3D Turbulence Simulation","title":"Analysis and Output","text":"","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Energy-Spectrum","page":"Tutorial: 3D Turbulence Simulation","title":"Energy Spectrum","text":"function compute_energy_spectrum(u)\n    # Compute kinetic energy in spectral space\n    E_k = zeros(N÷2)\n\n    for component in u.components\n        data = get_spectral_data(component)\n        # Bin by wavenumber shell\n        # ... spectral binning code ...\n    end\n\n    return E_k\nend","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Enstrophy-and-Dissipation","page":"Tutorial: 3D Turbulence Simulation","title":"Enstrophy and Dissipation","text":"function compute_enstrophy(u)\n    # ω = ∇ × u\n    omega = curl(u)\n\n    # Ω = ∫ |ω|² dV\n    enstrophy = 0.0\n    for component in omega.components\n        data = get_grid_data(component)\n        enstrophy += sum(data.^2)\n    end\n\n    return enstrophy / (N^3)\nend\n\nfunction compute_dissipation(u, nu)\n    # ε = 2ν Ω\n    return 2 * nu * compute_enstrophy(u)\nend","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#File-Output","page":"Tutorial: 3D Turbulence Simulation","title":"File Output","text":"# NetCDF output\noutput = add_netcdf_handler(\n    solver, \"turbulence_output\",\n    fields=[ux, uy, uz, p],\n    write_interval=0.5\n)\n\n# Analysis output (scalars)\nanalysis = add_netcdf_handler(\n    solver, \"turbulence_analysis\",\n    write_interval=0.1\n)\n\n# Add computed quantities\nadd_task!(analysis, () -> compute_kinetic_energy(u), name=\"kinetic_energy\")\nadd_task!(analysis, () -> compute_enstrophy(u), name=\"enstrophy\")\nadd_task!(analysis, () -> compute_dissipation(u, nu), name=\"dissipation\")","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Time-Integration","page":"Tutorial: 3D Turbulence Simulation","title":"Time Integration","text":"# Simulation parameters\nt_end = 10.0\noutput_interval = 0.5\nnext_output = output_interval\n\n# Diagnostic output\nif rank == 0\n    println(\"=\" ^ 60)\n    println(\"3D Turbulence Simulation\")\n    println(\"Re = $Re, N = $N\")\n    println(\"=\" ^ 60)\nend\n\n# Main loop\nwhile solver.sim_time < t_end\n    # Adaptive timestep\n    dt = compute_timestep(cfl)\n\n    # Advance solution\n    step!(solver, dt)\n\n    # Periodic output\n    if solver.sim_time >= next_output\n        KE = compute_kinetic_energy(u)\n        eps = compute_dissipation(u, nu)\n\n        if rank == 0\n            @printf(\"t = %.3f, KE = %.6e, ε = %.6e, dt = %.2e\\n\",\n                    solver.sim_time, KE, eps, dt)\n        end\n\n        next_output += output_interval\n    end\nend\n\nMPI.Finalize()","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Performance-Considerations","page":"Tutorial: 3D Turbulence Simulation","title":"Performance Considerations","text":"","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Resolution-Requirements","page":"Tutorial: 3D Turbulence Simulation","title":"Resolution Requirements","text":"Reynolds Number Minimum Grid Recommended Grid\nRe ~ 100 32³ 64³\nRe ~ 1000 64³ 128³\nRe ~ 10000 128³ 256³\nRe ~ 100000 256³ 512³+","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#MPI-Scaling","page":"Tutorial: 3D Turbulence Simulation","title":"MPI Scaling","text":"For 3D simulations:\n\nProcesses Recommended Mesh Notes\n8 (2, 2, 2) Basic\n64 (4, 4, 4) Good scaling\n512 (8, 8, 8) Large scale","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Memory-Usage","page":"Tutorial: 3D Turbulence Simulation","title":"Memory Usage","text":"Estimate: ~100 bytes per grid point (double precision, 3D velocity + pressure + work arrays)\n\n# Memory estimate\nN = 256\nbytes_per_point = 100\ntotal_memory = N^3 * bytes_per_point / 1e9  # GB\nprintln(\"Estimated memory: $(total_memory) GB\")","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Running-the-Simulation","page":"Tutorial: 3D Turbulence Simulation","title":"Running the Simulation","text":"# Set environment\nexport OMP_NUM_THREADS=1\n\n# Run with MPI\nmpiexec -n 8 julia --project turbulence_3d.jl","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#Visualization","page":"Tutorial: 3D Turbulence Simulation","title":"Visualization","text":"","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#ParaView-Export","page":"Tutorial: 3D Turbulence Simulation","title":"ParaView Export","text":"# Write VTK files for ParaView\nwrite_vtk(solver, \"turbulence\", iteration=solver.iteration)","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#In-situ-Visualization","page":"Tutorial: 3D Turbulence Simulation","title":"In-situ Visualization","text":"using GLMakie\n\n# Extract slice for visualization\nfunction visualize_slice(u, plane=\"xy\", position=0.5)\n    data = get_grid_data(u.components[1])\n    # ... slice extraction ...\n    heatmap(slice_data)\nend","category":"section"},{"location":"tutorials/ivp_3d_turbulence/#References","page":"Tutorial: 3D Turbulence Simulation","title":"References","text":"Taylor, G. I., & Green, A. E. (1937). Mechanism of the production of small eddies from large ones.\nPope, S. B. (2000). Turbulent Flows. Cambridge University Press.\nCanuto, C., et al. (2007). Spectral Methods: Fundamentals in Single Domains.","category":"section"},{"location":"examples/gpu_solvers_preconditioning/#GPU-Solvers:-Preconditioning","page":"GPU Solvers: Preconditioning","title":"GPU Solvers: Preconditioning","text":"CuIterativeCG and CuIterativeGMRES support multiple preconditioner options to accelerate convergence on GPU.","category":"section"},{"location":"examples/gpu_solvers_preconditioning/#Available-Preconditioners","page":"GPU Solvers: Preconditioning","title":"Available Preconditioners","text":"Preconditioner Symbol Best For\nJacobi (diagonal) :jacobi Diagonally dominant matrices\nILU(0) :ilu0 Ill-conditioned matrices, strong off-diagonal coupling\nIC(0) :ic0 Symmetric positive definite (SPD) matrices\nNone :none Well-conditioned problems\nCustom Function Specialized applications","category":"section"},{"location":"examples/gpu_solvers_preconditioning/#Jacobi-Preconditioner-(Default)","page":"GPU Solvers: Preconditioning","title":"Jacobi Preconditioner (Default)","text":"Simple diagonal scaling using the inverse of the matrix diagonal:\n\nusing CUDA, SparseArrays, Tarang\n\nA = sprand(10_000, 10_000, 1e-3)\nA = A + A' + 10I  # Make SPD\n\n# Jacobi preconditioner (default)\nsolver = CuIterativeCG(A; preconditioner=:jacobi, tol=1e-10)\nx = solve(solver, b)\n\nGood for diagonally dominant matrices where the diagonal captures most of the matrix structure.","category":"section"},{"location":"examples/gpu_solvers_preconditioning/#ILU(0)-Preconditioner-(Recommended-for-Tough-Problems)","page":"GPU Solvers: Preconditioning","title":"ILU(0) Preconditioner (Recommended for Tough Problems)","text":"Incomplete LU factorization with zero fill-in. Uses cuSPARSE for GPU-accelerated factorization and triangular solves.\n\nusing CUDA, SparseArrays, Tarang\n\n# Create a challenging problem (2D Laplacian)\nn = 100\nN = n^2\nfunction laplacian_2d(n)\n    I_n = sparse(I, n, n)\n    D = spdiagm(-1 => -ones(n-1), 0 => 2*ones(n), 1 => -ones(n-1))\n    return kron(I_n, D) + kron(D, I_n)\nend\n\nA = laplacian_2d(n)\nb = rand(N)\n\n# ILU(0) preconditioner - much better for ill-conditioned matrices\nsolver = CuIterativeCG(A; preconditioner=:ilu0, tol=1e-10)\nx = solve(solver, b)\n\nBenefits of ILU(0):\n\nSignificantly reduces iteration count (often 5-10x fewer iterations than Jacobi)\nCaptures matrix structure beyond just the diagonal\nEfficient GPU implementation via cuSPARSE\nSame memory footprint as original matrix (zero fill-in)\n\nWhen to use ILU(0):\n\nIll-conditioned matrices\nProblems with strong off-diagonal coupling\nWhen Jacobi converges slowly or not at all\nLarge sparse systems from PDE discretizations","category":"section"},{"location":"examples/gpu_solvers_preconditioning/#IC(0)-Preconditioner-(Optimal-for-SPD-Matrices)","page":"GPU Solvers: Preconditioning","title":"IC(0) Preconditioner (Optimal for SPD Matrices)","text":"Incomplete Cholesky factorization with zero fill-in. The symmetric variant of ILU(0), specifically optimized for symmetric positive definite (SPD) matrices.\n\nusing CUDA, SparseArrays, Tarang\n\n# Create an SPD matrix (e.g., from 2D Laplacian)\nn = 100\nN = n^2\nfunction laplacian_2d(n)\n    I_n = sparse(I, n, n)\n    D = spdiagm(-1 => -ones(n-1), 0 => 2*ones(n), 1 => -ones(n-1))\n    return kron(I_n, D) + kron(D, I_n)\nend\n\nA = laplacian_2d(n)  # This is SPD\nb = rand(N)\n\n# IC(0) preconditioner - optimal for SPD matrices\nsolver = CuIterativeCG(A; preconditioner=:ic0, tol=1e-10)\nx = solve(solver, b)\n\nBenefits of IC(0) over ILU(0) for SPD matrices:\n\nUses half the memory (stores only L, not L and U)\nBetter numerical stability for symmetric systems\nSlightly faster factorization and application\nPreserves symmetry properties\n\nWhen to use IC(0):\n\nMatrix is known to be symmetric positive definite\nUsing Conjugate Gradient solver (CG requires SPD matrix anyway)\nMemory is a concern (half the storage of ILU(0))\nPoisson/Laplacian problems, diffusion equations, mass matrices\n\nImportant: IC(0) requires the matrix to be SPD. Using it on a non-SPD matrix may produce incorrect results or fail. If unsure about SPD property, use ILU(0) instead.","category":"section"},{"location":"examples/gpu_solvers_preconditioning/#GMRES-with-ILU(0)","page":"GPU Solvers: Preconditioning","title":"GMRES with ILU(0)","text":"For non-symmetric systems, use CuIterativeGMRES:\n\nusing CUDA, SparseArrays, Tarang\n\n# Non-symmetric convection-diffusion problem\nA = # ... your non-symmetric matrix ...\nb = rand(size(A, 1))\n\n# GMRES with ILU(0) preconditioning\nsolver = CuIterativeGMRES(A;\n    preconditioner=:ilu0,\n    tol=1e-10,\n    restart=50,    # Restart parameter\n    maxiter=500\n)\nx = solve(solver, b)","category":"section"},{"location":"examples/gpu_solvers_preconditioning/#Custom-Preconditioners","page":"GPU Solvers: Preconditioning","title":"Custom Preconditioners","text":"For specialized applications, provide a custom function:\n\nusing CUDA, SparseArrays, Tarang\n\nA = sprand(10_000, 10_000, 1e-3)\nA = A + A' + 10I\n\n# Custom preconditioner: in-place function on CuArrays\nfunction my_preconditioner!(out, r)\n    # Example: scale by a user-defined factor\n    @. out = r / 10\nend\n\nsolver = CuIterativeCG(A; preconditioner=my_preconditioner!)\nx = solve(solver, b)\n\nCustom preconditioner requirements:\n\nFunction signature: (out::CuVector, r::CuVector) -> Nothing\nOperates in-place on GPU arrays\nShould approximate out = M⁻¹ * r where M ≈ A","category":"section"},{"location":"examples/gpu_solvers_preconditioning/#Explicit-Diagonal-Preconditioner","page":"GPU Solvers: Preconditioning","title":"Explicit Diagonal Preconditioner","text":"Provide your own diagonal inverse values:\n\nusing CUDA, SparseArrays, Tarang\n\nA = # ... your matrix ...\n\n# Compute custom diagonal inverse\nd = diag(A)\nd_inv = 1.0 ./ d\n\n# Use as preconditioner\nsolver = CuIterativeCG(A; preconditioner=d_inv)","category":"section"},{"location":"examples/gpu_solvers_preconditioning/#Performance-Comparison","page":"GPU Solvers: Preconditioning","title":"Performance Comparison","text":"Typical iteration counts for a 2D Poisson problem (N=10,000):\n\nPreconditioner Iterations Relative Time Memory\nNone 500+ Baseline 1x\nJacobi 150-200 ~0.4x 1x\nILU(0) 20-40 ~0.1x 2x\nIC(0) 15-35 ~0.08x 1x\n\nNote: Actual performance depends on matrix structure and condition number. IC(0) is only valid for SPD matrices but offers similar convergence to ILU(0) with half the memory.","category":"section"},{"location":"examples/gpu_solvers_preconditioning/#Preconditioner-Summary","page":"GPU Solvers: Preconditioning","title":"Preconditioner Summary","text":"# Allowed preconditioner values:\nsolver = CuIterativeCG(A; preconditioner=...)\n\n# :none      - No preconditioning\n# :jacobi    - Diagonal inverse from diag(A) [default]\n# :ilu0      - ILU(0) via cuSPARSE (recommended for tough non-SPD problems)\n# :ic0       - IC(0) via cuSPARSE (optimal for SPD matrices, half memory of ILU)\n# Vector     - Explicit diagonal inverse values (copied to GPU)\n# Function   - Custom (out, r) -> out = M⁻¹*r on GPU arrays\n\nQuick selection guide:\n\nSPD matrix + CG solver: Use :ic0 (best performance and memory)\nNon-symmetric matrix + GMRES: Use :ilu0\nUnsure if SPD: Use :ilu0 (works for all matrices)\nSimple/well-conditioned: Use :jacobi (fastest setup)","category":"section"},{"location":"examples/gpu_solvers_preconditioning/#See-Also","page":"GPU Solvers: Preconditioning","title":"See Also","text":"GPU Solvers Overview: Solver types and selection\nOptimization: Performance tuning","category":"section"},{"location":"pages/architecture/#Architecture","page":"Architecture","title":"Architecture","text":"Overview of Tarang.jl's internal architecture.","category":"section"},{"location":"pages/architecture/#Package-Structure","page":"Architecture","title":"Package Structure","text":"Tarang.jl/\n├── src/\n│   ├── Tarang.jl          # Main module\n│   ├── core/              # Core functionality\n│   │   ├── coordinates.jl\n│   │   ├── basis.jl\n│   │   ├── domain.jl\n│   │   ├── field.jl\n│   │   ├── distributor.jl\n│   │   ├── operators.jl\n│   │   ├── transforms.jl\n│   │   ├── problems.jl\n│   │   ├── boundary_conditions.jl\n│   │   ├── solvers.jl\n│   │   └── evaluator.jl\n│   ├── tools/             # Utilities and I/O\n│   │   ├── array.jl         # Array manipulation utilities\n│   │   ├── cache.jl         # Caching utilities\n│   │   ├── config.jl        # Configuration management\n│   │   ├── dispatch.jl      # Multiple dispatch helpers\n│   │   ├── exceptions.jl    # Custom exception types\n│   │   ├── general.jl       # General utilities\n│   │   ├── logging.jl       # MPI-aware logging\n│   │   ├── matsolvers.jl    # Matrix solvers\n│   │   ├── netcdf_merge.jl  # NetCDF merging\n│   │   ├── netcdf_output.jl # NetCDF output handlers\n│   │   ├── parallel.jl      # Parallel utilities\n│   │   ├── parsing.jl       # Expression parsing\n│   │   ├── progress.jl      # Progress tracking\n│   │   ├── random_arrays.jl # Random array generation\n│   │   └── temporal_filters.jl # Time integration filters\n│   └── extras/            # Convenience functions\n│       ├── flow_tools.jl\n│       └── quick_domains.jl\n├── test/                  # Tests\n└── docs/                  # Documentation","category":"section"},{"location":"pages/architecture/#Core-Components","page":"Architecture","title":"Core Components","text":"","category":"section"},{"location":"pages/architecture/#Coordinates","page":"Architecture","title":"Coordinates","text":"abstract type Coordinates end\n\nstruct CartesianCoordinates <: Coordinates\n    names::Vector{String}\n    coords::Vector{Coordinate}\nend","category":"section"},{"location":"pages/architecture/#Bases","page":"Architecture","title":"Bases","text":"abstract type SpectralBasis end\n\nstruct RealFourier <: SpectralBasis\n    coord::Coordinate\n    size::Int\n    bounds::Tuple{Float64, Float64}\n    dealias::Float64\nend\n\nstruct ChebyshevT <: SpectralBasis\n    coord::Coordinate\n    size::Int\n    bounds::Tuple{Float64, Float64}\nend","category":"section"},{"location":"pages/architecture/#Fields","page":"Architecture","title":"Fields","text":"abstract type AbstractField end\n\nmutable struct ScalarField <: AbstractField\n    dist::Distributor\n    name::String\n    bases::Tuple\n    dtype::Type\n    data_g::Union{Array, Nothing}\n    data_c::Union{Array, Nothing}\n    current_layout::Symbol\nend","category":"section"},{"location":"pages/architecture/#Distributor","page":"Architecture","title":"Distributor","text":"struct Distributor\n    coords::Coordinates\n    comm::MPI.Comm\n    rank::Int\n    size::Int\n    mesh::Tuple\nend","category":"section"},{"location":"pages/architecture/#Data-Flow","page":"Architecture","title":"Data Flow","text":"","category":"section"},{"location":"pages/architecture/#Simulation-Lifecycle","page":"Architecture","title":"Simulation Lifecycle","text":"1. Setup\n   Coordinates → Distributor → Bases → Domain → Fields\n\n2. Problem Definition\n   Fields → Problem → Equations + BCs\n\n3. Solving\n   Problem → Solver → Time stepping loop\n\n4. Output\n   Fields → Handler → Files","category":"section"},{"location":"pages/architecture/#Transform-Flow","page":"Architecture","title":"Transform Flow","text":"Grid Space (physical)\n    ↓ forward transform\nCoefficient Space (spectral)\n    ↓ apply operators\nCoefficient Space\n    ↓ inverse transform\nGrid Space","category":"section"},{"location":"pages/architecture/#MPI-Parallelism","page":"Architecture","title":"MPI Parallelism","text":"","category":"section"},{"location":"pages/architecture/#Pencil-Decomposition","page":"Architecture","title":"Pencil Decomposition","text":"Global Array         Local Arrays (4 processes)\n┌──────────┐        ┌────┬────┐\n│          │        │ P0 │ P1 │\n│          │   →    ├────┼────┤\n│          │        │ P2 │ P3 │\n└──────────┘        └────┴────┘","category":"section"},{"location":"pages/architecture/#Communication-Patterns","page":"Architecture","title":"Communication Patterns","text":"All-to-all: Layout transforms\nAllreduce: Global reductions\nGather: Output to single file","category":"section"},{"location":"pages/architecture/#Transform-Architecture","page":"Architecture","title":"Transform Architecture","text":"","category":"section"},{"location":"pages/architecture/#Layout-Management","page":"Architecture","title":"Layout Management","text":"function ensure_layout!(field, target_layout)\n    if field.current_layout != target_layout\n        transform!(field, target_layout)\n    end\nend","category":"section"},{"location":"pages/architecture/#Transform-Types","page":"Architecture","title":"Transform Types","text":"Forward: Grid → Spectral\nInverse: Spectral → Grid","category":"section"},{"location":"pages/architecture/#Problem-Architecture","page":"Architecture","title":"Problem Architecture","text":"","category":"section"},{"location":"pages/architecture/#Problem-Types","page":"Architecture","title":"Problem Types","text":"abstract type Problem end\n\nstruct IVP <: Problem\n    fields::Vector{ScalarField}\n    equations::Vector{Equation}\n    boundary_conditions::Vector{BC}\n    parameters::Dict{String, Any}\nend","category":"section"},{"location":"pages/architecture/#Equation-Parsing","page":"Architecture","title":"Equation Parsing","text":"String → Tokenize → Parse → AST → Evaluation","category":"section"},{"location":"pages/architecture/#Solver-Architecture","page":"Architecture","title":"Solver Architecture","text":"","category":"section"},{"location":"pages/architecture/#Time-Steppers","page":"Architecture","title":"Time Steppers","text":"abstract type TimeStepper end\n\nstruct RK222 <: TimeStepper end\nstruct SBDF2 <: TimeStepper end","category":"section"},{"location":"pages/architecture/#Solver-State","page":"Architecture","title":"Solver State","text":"struct InitialValueSolver\n    problem::IVP\n    timestepper::TimeStepper\n    state::Vector\n    sim_time::Float64\n    iteration::Int\nend","category":"section"},{"location":"pages/architecture/#Extension-Points","page":"Architecture","title":"Extension Points","text":"","category":"section"},{"location":"pages/architecture/#Custom-Bases","page":"Architecture","title":"Custom Bases","text":"Implement SpectralBasis interface:\n\nsize(basis)\nget_grid(basis)\nforward_transform(data, basis)\ninverse_transform(data, basis)","category":"section"},{"location":"pages/architecture/#Custom-Timesteppers","page":"Architecture","title":"Custom Timesteppers","text":"Implement TimeStepper interface:\n\nstep!(solver, dt)\nstages(stepper)","category":"section"},{"location":"pages/architecture/#Design-Principles","page":"Architecture","title":"Design Principles","text":"Separation of concerns: Coordinates, bases, fields, problems\nLazy transforms: Transform only when needed\nMPI transparency: Users don't manage communication\nExtensibility: Abstract types for customization\nJulia idioms: Multiple dispatch, type stability","category":"section"},{"location":"pages/architecture/#See-Also","page":"Architecture","title":"See Also","text":"Contributing: Development guidelines\nTesting: Test architecture","category":"section"},{"location":"api/problems/#Problems-API","page":"Problems API","title":"Problems API","text":"Problems define the PDE systems to be solved, including equations, parameters, and boundary conditions. Tarang.jl supports Initial Value Problems (IVP), Boundary Value Problems (LBVP/NLBVP), and Eigenvalue Problems (EVP).","category":"section"},{"location":"api/problems/#Problem-Types","page":"Problems API","title":"Problem Types","text":"","category":"section"},{"location":"api/problems/#Initial-Value-Problems-(IVP)","page":"Problems API","title":"Initial Value Problems (IVP)","text":"Time-evolution problems where PDEs are integrated forward in time from initial conditions.\n\nConstructor:\n\nIVP(fields::Vector{<:AbstractField})\n\nArguments:\n\nfields: Vector of fields to solve for\n\nExamples:\n\n# 2D Navier-Stokes\nproblem = IVP([ux, uz, p])\n\n# With additional scalars\nproblem = IVP([ux, uz, p, T, S])\n\nUse cases:\n\nFluid dynamics (Navier-Stokes)\nHeat/mass diffusion\nWave propagation\nReaction-diffusion systems\nTurbulence simulations\n\n","category":"section"},{"location":"api/problems/#Linear-Boundary-Value-Problems-(LBVP)","page":"Problems API","title":"Linear Boundary Value Problems (LBVP)","text":"Steady-state linear problems with boundary conditions.\n\nConstructor:\n\nLBVP(fields::Vector{<:AbstractField})\n\nArguments:\n\nfields: Vector of fields to solve for\n\nExamples:\n\n# Poisson equation\nproblem = LBVP([phi])\nadd_equation!(problem, \"Δ(phi) = rho\")\n\n# Stokes flow\nproblem = LBVP([u, v, p])\nadd_equation!(problem, \"-nu*Δ(u) + ∂x(p) = fx\")\nadd_equation!(problem, \"-nu*Δ(v) + ∂z(p) = fz\")\nadd_equation!(problem, \"∂x(u) + ∂z(v) = 0\")\n\nUse cases:\n\nSteady heat conduction\nPoisson/Laplace equations\nStokes flow\nElectrostatics\n\n","category":"section"},{"location":"api/problems/#Nonlinear-Boundary-Value-Problems-(NLBVP)","page":"Problems API","title":"Nonlinear Boundary Value Problems (NLBVP)","text":"Steady-state nonlinear problems with boundary conditions.\n\nConstructor:\n\nNLBVP(fields::Vector{<:AbstractField})\n\nArguments:\n\nfields: Vector of fields to solve for\n\nExamples:\n\n# Steady Navier-Stokes\nproblem = NLBVP([u, v, p])\nadd_equation!(problem, \"u*∂x(u) + v*∂z(u) = -∂x(p) + nu*Δ(u)\")\nadd_equation!(problem, \"u*∂x(v) + v*∂z(v) = -∂z(p) + nu*Δ(v)\")\nadd_equation!(problem, \"∂x(u) + ∂z(v) = 0\")\n\nUse cases:\n\nSteady nonlinear flows\nBifurcation analysis\nMultiple steady states\n\nSolution method: Newton iteration or similar nonlinear solvers\n\n","category":"section"},{"location":"api/problems/#Eigenvalue-Problems-(EVP)","page":"Problems API","title":"Eigenvalue Problems (EVP)","text":"Linear eigenvalue problems for stability analysis and normal modes.\n\nConstructor:\n\nEVP(fields::Vector{<:AbstractField}; eigenvalue::Symbol)\n\nArguments:\n\nfields: Vector of fields to solve for\neigenvalue: Symbol for eigenvalue (e.g., :sigma, :lambda, :omega)\n\nExamples:\n\n# Rayleigh-Bénard stability\nproblem = EVP([u, v, p, T], eigenvalue=:sigma)\nadd_equation!(problem, \"sigma*u = -u0*∂x(u) - v*∂x(u0) - ∂x(p) + Pr*Δ(u) + Pr*Ra*T\")\nadd_equation!(problem, \"sigma*v = -u0*∂x(v) - v*∂z(u0) - ∂z(p) + Pr*Δ(v)\")\nadd_equation!(problem, \"sigma*T = -u0*∂x(T) - v + Δ(T)\")\nadd_equation!(problem, \"∂x(u) + ∂z(v) = 0\")\n\nUse cases:\n\nLinear stability analysis\nGrowth rates and frequencies\nNormal mode decomposition\nCritical parameter values\n\n","category":"section"},{"location":"api/problems/#Adding-Equations","page":"Problems API","title":"Adding Equations","text":"","category":"section"},{"location":"api/problems/#add_equation!","page":"Problems API","title":"add_equation!","text":"Add a PDE to the problem.\n\nSyntax:\n\nadd_equation!(problem, equation_string::String)\n\nArguments:\n\nproblem: Problem object (IVP, LBVP, NLBVP, or EVP)\nequation_string: String equation using symbolic syntax\n\nExamples:","category":"section"},{"location":"api/problems/#Simple-Equations","page":"Problems API","title":"Simple Equations","text":"# Diffusion\nadd_equation!(problem, \"∂t(T) = kappa*Δ(T)\")\n\n# Wave equation\nadd_equation!(problem, \"∂t(∂t(u)) = c^2*Δ(u)\")\n\n# Poisson\nadd_equation!(problem, \"Δ(phi) = rho\")","category":"section"},{"location":"api/problems/#Complex-Equations","page":"Problems API","title":"Complex Equations","text":"# Navier-Stokes momentum\nadd_equation!(problem, \"∂t(u) + u*∂x(u) + w*∂z(u) = -∂x(p) + nu*Δ(u)\")\n\n# Energy equation with dissipation\nadd_equation!(problem, \"∂t(T) + u*∂x(T) + w*∂z(T) = kappa*Δ(T) + Q\")\n\n# With parameters\nadd_equation!(problem, \"∂t(T) = kappa*Δ(T) + Ra*Pr*w\")","category":"section"},{"location":"api/problems/#Using-Fields-and-Parameters","page":"Problems API","title":"Using Fields and Parameters","text":"# Fields are referenced by name\nadd_equation!(problem, \"∂t(u) = -u*∂x(u)\")  # u is a field\n\n# Parameters from problem.parameters\nproblem.parameters[\"nu\"] = 0.01\nproblem.parameters[\"Ra\"] = 1e6\nadd_equation!(problem, \"∂t(u) = nu*Δ(u) + Ra*T\")\n\n","category":"section"},{"location":"api/problems/#Parameters","page":"Problems API","title":"Parameters","text":"","category":"section"},{"location":"api/problems/#Setting-Parameters","page":"Problems API","title":"Setting Parameters","text":"# Create problem\nproblem = IVP([u, p, T])\n\n# Set dimensionless parameters\nproblem.parameters[\"Re\"] = 1000.0      # Reynolds number\nproblem.parameters[\"Pr\"] = 0.7         # Prandtl number\nproblem.parameters[\"Ra\"] = 1e6         # Rayleigh number\n\n# Set physical parameters\nproblem.parameters[\"nu\"] = 1e-3        # Kinematic viscosity\nproblem.parameters[\"kappa\"] = 1e-3     # Thermal diffusivity\nproblem.parameters[\"g\"] = 9.81         # Gravitational acceleration","category":"section"},{"location":"api/problems/#Using-Parameters-in-Equations","page":"Problems API","title":"Using Parameters in Equations","text":"# Reference by name in equations\nadd_equation!(problem, \"∂t(u) = -u*∂x(u) + nu*Δ(u)\")\nadd_equation!(problem, \"∂t(T) = -u*∂x(T) + kappa*Δ(T)\")\n\n# Dimensionless formulation\nadd_equation!(problem, \"∂t(u) = -u*∂x(u) + (1/Re)*Δ(u)\")\nadd_equation!(problem, \"∂t(T) = -u*∂x(T) + (1/(Re*Pr))*Δ(T) + Ra*Pr*w\")","category":"section"},{"location":"api/problems/#Modifying-Parameters","page":"Problems API","title":"Modifying Parameters","text":"# Change parameter value\nproblem.parameters[\"Ra\"] = 1e7\n\n# Access parameter\nRa = problem.parameters[\"Ra\"]\n\n# Iterate over parameters\nfor (name, value) in problem.parameters\n    println(\"$name = $value\")\nend\n\n","category":"section"},{"location":"api/problems/#Boundary-Conditions","page":"Problems API","title":"Boundary Conditions","text":"Boundary conditions in Tarang.jl use the same add_equation! function as PDEs. The Dedalus-style syntax field(coord=value) is auto-detected and converted to the appropriate Interpolate operator.","category":"section"},{"location":"api/problems/#Dirichlet-(Fixed-Value)","page":"Problems API","title":"Dirichlet (Fixed Value)","text":"# Constant value\nadd_equation!(problem, \"T(z=0) = 1\")\nadd_equation!(problem, \"T(z=1) = 0\")\n\n# No-slip velocity\nadd_equation!(problem, \"u(z=0) = 0\")\n\n# Time-dependent\nadd_equation!(problem, \"u(x=0) = sin(omega*t)\")\n\n# Space-dependent\nadd_equation!(problem, \"T(z=0) = 1.0 - x^2\")\n\n","category":"section"},{"location":"api/problems/#Neumann-(Fixed-Derivative)","page":"Problems API","title":"Neumann (Fixed Derivative)","text":"# Insulating boundary (zero heat flux)\nadd_equation!(problem, \"∂z(T)(z=0) = 0\")  # ∂T/∂z(z=0) = 0\n\n# Fixed flux\nadd_equation!(problem, \"∂z(T)(z=1) = -1\")  # ∂T/∂z(z=1) = -1\n\n# Time-dependent flux\nadd_equation!(problem, \"∂x(phi)(x=0) = sin(omega*t)\")\n\n","category":"section"},{"location":"api/problems/#Robin-(Mixed)","page":"Problems API","title":"Robin (Mixed)","text":"Robin boundary condition: αf + βdf/dn = value\n\n# Convective heat transfer: h*T + k*∂T/∂n = h*T_ambient\nh, k = 10.0, 1.0\nT_ambient = 300.0\nadd_equation!(problem, \"$(h)*T(z=1) + $(k)*∂z(T)(z=1) = $(h*T_ambient)\")\n\n# Radiation boundary: T + ε*∂T/∂n = 0\nadd_equation!(problem, \"1.0*T(x=0) + $(epsilon)*∂x(T)(x=0) = 0\")\n\n","category":"section"},{"location":"api/problems/#Stress-Free","page":"Problems API","title":"Stress-Free","text":"Stress-free boundary condition for fluid mechanics: unormal = 0, ∂utangential/∂n = 0\n\n# Stress-free top and bottom (free-slip)\nadd_equation!(problem, \"w(z=0) = 0\")\nadd_equation!(problem, \"∂z(u)(z=0) = 0\")\nadd_equation!(problem, \"∂z(v)(z=0) = 0\")\nadd_equation!(problem, \"w(z=1) = 0\")\nadd_equation!(problem, \"∂z(u)(z=1) = 0\")\nadd_equation!(problem, \"∂z(v)(z=1) = 0\")\n\n","category":"section"},{"location":"api/problems/#No-Slip","page":"Problems API","title":"No-Slip","text":"No-slip boundary condition for fluid mechanics: all velocity components = 0 at the boundary.\n\n# No-slip at walls\nadd_equation!(problem, \"u(z=0) = 0\")\nadd_equation!(problem, \"v(z=0) = 0\")\nadd_equation!(problem, \"w(z=0) = 0\")\nadd_equation!(problem, \"u(z=1) = 0\")\nadd_equation!(problem, \"v(z=1) = 0\")\nadd_equation!(problem, \"w(z=1) = 0\")\n\n","category":"section"},{"location":"api/problems/#Custom-Boundary-Conditions","page":"Problems API","title":"Custom Boundary Conditions","text":"Use add_equation! for any custom boundary condition:\n\n# Custom combinations\nadd_equation!(problem, \"u(z=0) + 2*∂z(u)(z=0) = 1\")\n\n# Coupling between fields\nadd_equation!(problem, \"T(x=0) = 2*S(x=0)\")\n\n# Complex expressions\nadd_equation!(problem, \"∂x(p)(z=0) + omega^2*u(z=0) = 0\")\n\n","category":"section"},{"location":"api/problems/#Problem-Properties","page":"Problems API","title":"Problem Properties","text":"","category":"section"},{"location":"api/problems/#Accessing-Fields","page":"Problems API","title":"Accessing Fields","text":"# Get list of fields\nfields = problem.fields\n\n# Iterate over fields\nfor field in problem.fields\n    println(field.name)\nend\n\n# Find field by name\nu = find_field(problem, \"u\")","category":"section"},{"location":"api/problems/#Accessing-Equations","page":"Problems API","title":"Accessing Equations","text":"# Get equations\nequations = problem.equations\n\n# Number of equations\nn_eqs = length(problem.equations)\n\n# Print equations\nfor (i, eq) in enumerate(problem.equations)\n    println(\"Equation $i: $eq\")\nend","category":"section"},{"location":"api/problems/#Accessing-Boundary-Conditions","page":"Problems API","title":"Accessing Boundary Conditions","text":"# Get boundary conditions\nbcs = problem.boundary_conditions\n\n# Number of BCs\nn_bcs = length(problem.boundary_conditions)\n\n# Print BCs\nfor bc in problem.boundary_conditions\n    println(\"$(bc.field) at $(bc.coord)=$(bc.position): $(bc.type)\")\nend\n\n","category":"section"},{"location":"api/problems/#Problem-Validation","page":"Problems API","title":"Problem Validation","text":"","category":"section"},{"location":"api/problems/#validate_problem","page":"Problems API","title":"validate_problem","text":"Check problem for consistency and completeness.\n\nSyntax:\n\nvalidate_problem(problem)\n\nChecks:\n\nNumber of equations matches number of unknowns\nBoundary conditions are sufficient\nParameters are defined\nField dimensions match\nOperator applications are valid\n\nExample:\n\nproblem = IVP([u, v, p])\nadd_equation!(problem, \"∂t(u) = -u*∂x(u) - v*∂z(u) - ∂x(p) + nu*Δ(u)\")\nadd_equation!(problem, \"∂t(v) = -u*∂x(v) - v*∂z(v) - ∂z(p) + nu*Δ(v)\")\nadd_equation!(problem, \"∂x(u) + ∂z(v) = 0\")\n\n# Add boundary conditions\nadd_equation!(problem, \"u(z=0) = 0\")\nadd_equation!(problem, \"v(z=0) = 0\")\n# ... more BCs\n\n# Validate\nvalidate_problem(problem)  # Throws error if invalid\n\n","category":"section"},{"location":"api/problems/#Problem-Substitutions","page":"Problems API","title":"Problem Substitutions","text":"","category":"section"},{"location":"api/problems/#Substitution-Variables","page":"Problems API","title":"Substitution Variables","text":"Define intermediate variables for readability:\n\n# Define substitution\nadd_substitution!(problem, \"omega\", \"∂x(v) - ∂z(u)\")\n\n# Use in equations\nadd_equation!(problem, \"∂t(omega) = -u*∂x(omega) - v*∂z(omega) + nu*Δ(omega)\")","category":"section"},{"location":"api/problems/#Common-Substitutions","page":"Problems API","title":"Common Substitutions","text":"# Vorticity\nadd_substitution!(problem, \"omega\", \"∂x(v) - ∂z(u)\")\n\n# Kinetic energy\nadd_substitution!(problem, \"KE\", \"0.5*(u^2 + v^2 + w^2)\")\n\n# Strain rate\nadd_substitution!(problem, \"S11\", \"∂x(u)\")\nadd_substitution!(problem, \"S12\", \"0.5*(∂x(v) + ∂z(u))\")\n\n","category":"section"},{"location":"api/problems/#Advanced-Features","page":"Problems API","title":"Advanced Features","text":"","category":"section"},{"location":"api/problems/#Tau-Method-for-Boundary-Conditions","page":"Problems API","title":"Tau Method for Boundary Conditions","text":"Tarang.jl uses the tau method for enforcing boundary conditions in spectral methods:\n\n# Tau fields are created automatically\n# Lift operations handle boundary condition enforcement\n\n# User typically doesn't interact with tau fields directly\n# But they appear in the linear operator for non-periodic bases","category":"section"},{"location":"api/problems/#Constraints","page":"Problems API","title":"Constraints","text":"Add algebraic constraints to the system:\n\n# Mean value constraint\nadd_constraint!(problem, \"mean(p) = 0\")\n\n# Integral constraint\nadd_constraint!(problem, \"integral(T) = 1.0\")\n\n","category":"section"},{"location":"api/problems/#Complete-Examples","page":"Problems API","title":"Complete Examples","text":"","category":"section"},{"location":"api/problems/#2D-Rayleigh-Bénard-Convection","page":"Problems API","title":"2D Rayleigh-Bénard Convection","text":"# Create fields\ncoords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords, mesh=(2, 2))\n\nx_basis = RealFourier(coords[\"x\"], size=256, bounds=(0.0, 4.0))\nz_basis = ChebyshevT(coords[\"z\"], size=64, bounds=(0.0, 1.0))\n\ndomain = Domain(dist, (x_basis, z_basis))\n\nu = VectorField(dist, coords, \"u\", (x_basis, z_basis))\np = ScalarField(dist, \"p\", (x_basis, z_basis))\nT = ScalarField(dist, \"T\", (x_basis, z_basis))\n\n# Create problem\nproblem = IVP([u.components[1], u.components[2], p, T])\n\n# Parameters\nproblem.parameters[\"Ra\"] = 1e6\nproblem.parameters[\"Pr\"] = 1.0\n\n# Equations\nadd_equation!(problem, \"∂t(u) + u*∂x(u) + w*∂z(u) + ∂x(p) = Pr*Δ(u)\")\nadd_equation!(problem, \"∂t(w) + u*∂x(w) + w*∂z(w) + ∂z(p) = Pr*Δ(w) + Ra*Pr*T\")\nadd_equation!(problem, \"∂x(u) + ∂z(w) = 0\")\nadd_equation!(problem, \"∂t(T) + u*∂x(T) + w*∂z(T) = Δ(T)\")\n\n# Boundary conditions\nadd_equation!(problem, \"u(z=0) = 0\")\nadd_equation!(problem, \"w(z=0) = 0\")\nadd_equation!(problem, \"T(z=0) = 1\")\n\nadd_equation!(problem, \"u(z=1) = 0\")\nadd_equation!(problem, \"w(z=1) = 0\")\nadd_equation!(problem, \"T(z=1) = 0\")\n\n# Validate\nvalidate_problem(problem)\n\n","category":"section"},{"location":"api/problems/#See-Also","page":"Problems API","title":"See Also","text":"Solvers: Solving problems with different algorithms\nOperators: Mathematical operators for equations\nFields: Field types used in problems\nTimesteppers: Time integration schemes","category":"section"},{"location":"pages/optimization/#Performance-Optimization","page":"Performance Optimization","title":"Performance Optimization","text":"Guide to optimizing Tarang.jl simulations.","category":"section"},{"location":"pages/optimization/#Profiling","page":"Performance Optimization","title":"Profiling","text":"","category":"section"},{"location":"pages/optimization/#Julia-Profiler","page":"Performance Optimization","title":"Julia Profiler","text":"using Profile\n\n@profile begin\n    for i in 1:100\n        step!(solver)\n    end\nend\n\nProfile.print()","category":"section"},{"location":"pages/optimization/#Timing","page":"Performance Optimization","title":"Timing","text":"using BenchmarkTools\n\n@btime step!($solver)","category":"section"},{"location":"pages/optimization/#Memory-Optimization","page":"Performance Optimization","title":"Memory Optimization","text":"","category":"section"},{"location":"pages/optimization/#Minimize-Allocations","page":"Performance Optimization","title":"Minimize Allocations","text":"# Bad: Creates new arrays\nfield.data_g = field.data_g .+ other.data_g\n\n# Good: In-place operation\nfield.data_g .+= other.data_g","category":"section"},{"location":"pages/optimization/#Pre-allocate-Work-Arrays","page":"Performance Optimization","title":"Pre-allocate Work Arrays","text":"# Once at setup\nwork = similar(field.data_g)\n\n# Reuse in loop\nfor step in 1:nsteps\n    work .= compute_rhs(field)\n    field.data_g .+= dt .* work\nend","category":"section"},{"location":"pages/optimization/#Minimize-Transforms","page":"Performance Optimization","title":"Minimize Transforms","text":"# Bad: Transform for each operation\nTarang.ensure_layout!(field, :g)\noperation1(field)\nTarang.ensure_layout!(field, :c)\nTarang.ensure_layout!(field, :g)\noperation2(field)\n\n# Good: Batch operations\nTarang.ensure_layout!(field, :g)\noperation1(field)\noperation2(field)\nTarang.ensure_layout!(field, :c)","category":"section"},{"location":"pages/optimization/#FFT-Optimization","page":"Performance Optimization","title":"FFT Optimization","text":"","category":"section"},{"location":"pages/optimization/#Power-of-2-Sizes","page":"Performance Optimization","title":"Power-of-2 Sizes","text":"# Fast\nN = 256  # 2^8\n\n# Slower\nN = 250\n\n# Much slower\nN = 251  # Prime","category":"section"},{"location":"pages/optimization/#FFTW-Planning","page":"Performance Optimization","title":"FFTW Planning","text":"# Set planning rigor (before first transform)\nENV[\"FFTW_PLANNING_RIGOR\"] = \"FFTW_PATIENT\"\n\n# Options:\n# FFTW_ESTIMATE - fast planning, may be suboptimal\n# FFTW_MEASURE - balanced (default)\n# FFTW_PATIENT - thorough search\n# FFTW_EXHAUSTIVE - very thorough (slow startup)","category":"section"},{"location":"pages/optimization/#FFTW-Wisdom","page":"Performance Optimization","title":"FFTW Wisdom","text":"Save and reuse FFT plans:\n\nusing FFTW\n\n# Save wisdom after first run\nFFTW.export_wisdom(\"fftw_wisdom.txt\")\n\n# Load on subsequent runs\nFFTW.import_wisdom(\"fftw_wisdom.txt\")","category":"section"},{"location":"pages/optimization/#MPI-Optimization","page":"Performance Optimization","title":"MPI Optimization","text":"","category":"section"},{"location":"pages/optimization/#Process-Mesh","page":"Performance Optimization","title":"Process Mesh","text":"Match mesh to domain:\n\n# Square domain\ndist = Distributor(coords; mesh=(4, 4))\n\n# Wide domain (Lx > Lz)\ndist = Distributor(coords; mesh=(8, 2))","category":"section"},{"location":"pages/optimization/#Load-Balance","page":"Performance Optimization","title":"Load Balance","text":"# Good: Even division\nN = 256  # 256 / 4 = 64 per process\n\n# Bad: Uneven\nN = 250  # Some processes get more","category":"section"},{"location":"pages/optimization/#Communication","page":"Performance Optimization","title":"Communication","text":"# Minimize synchronization points\n# Batch MPI operations\n# Use non-blocking where possible","category":"section"},{"location":"pages/optimization/#Threading","page":"Performance Optimization","title":"Threading","text":"","category":"section"},{"location":"pages/optimization/#Set-Threads","page":"Performance Optimization","title":"Set Threads","text":"# For FFTW (usually 1 is best with MPI)\nexport OMP_NUM_THREADS=1\n\n# Or in Julia\nBLAS.set_num_threads(1)","category":"section"},{"location":"pages/optimization/#Julia-Threads","page":"Performance Optimization","title":"Julia Threads","text":"# Check available\nThreads.nthreads()\n\n# Threaded loops\nThreads.@threads for i in 1:N\n    # ...\nend","category":"section"},{"location":"pages/optimization/#Resolution-Guidelines","page":"Performance Optimization","title":"Resolution Guidelines","text":"","category":"section"},{"location":"pages/optimization/#Minimum-Resolution","page":"Performance Optimization","title":"Minimum Resolution","text":"Feature Modes Needed\nSmooth profile ~10\nModerate gradient ~30\nSharp gradient ~100\nBoundary layer ~50-100","category":"section"},{"location":"pages/optimization/#Check-Convergence","page":"Performance Optimization","title":"Check Convergence","text":"# Compare solutions at different N\n# Should converge exponentially for spectral methods","category":"section"},{"location":"pages/optimization/#Timestepping","page":"Performance Optimization","title":"Timestepping","text":"","category":"section"},{"location":"pages/optimization/#CFL-Optimization","page":"Performance Optimization","title":"CFL Optimization","text":"# Tune safety factor\ncfl = CFL(problem; safety=0.4)  # Conservative\ncfl = CFL(problem; safety=0.6)  # Aggressive\n\n# Limit timestep changes\ncfl.max_change = 1.2  # Smooth","category":"section"},{"location":"pages/optimization/#Implicit-Methods","page":"Performance Optimization","title":"Implicit Methods","text":"For stiff problems, IMEX methods allow larger timesteps:\n\n# Explicit (requires small dt for diffusion)\nsolver = InitialValueSolver(problem, RK222(); dt=1e-5)\n\n# IMEX (diffusion implicit, larger dt)\nsolver = InitialValueSolver(problem, SBDF2(); dt=1e-3)","category":"section"},{"location":"pages/optimization/#Benchmarking","page":"Performance Optimization","title":"Benchmarking","text":"","category":"section"},{"location":"pages/optimization/#Standard-Benchmark","page":"Performance Optimization","title":"Standard Benchmark","text":"function benchmark_solver(solver, nsteps)\n    start = time()\n    for i in 1:nsteps\n        step!(solver)\n    end\n    elapsed = time() - start\n\n    println(\"Time per step: $(elapsed/nsteps * 1000) ms\")\n    println(\"Grid points/sec: $(prod(solver.problem.shape) * nsteps / elapsed)\")\nend","category":"section"},{"location":"pages/optimization/#Scaling-Test","page":"Performance Optimization","title":"Scaling Test","text":"# Strong scaling: fixed problem, vary processes\n# Weak scaling: fixed work per process\n\nfor np in [1, 2, 4, 8, 16]\n    # Run with mpiexec -n $np\n    # Record time\nend","category":"section"},{"location":"pages/optimization/#Common-Bottlenecks","page":"Performance Optimization","title":"Common Bottlenecks","text":"FFT transforms: Use optimal sizes, FFTW wisdom\nMPI communication: Balance mesh, minimize syncs\nMemory allocation: Pre-allocate, use in-place ops\nI/O: Write less frequently, use parallel I/O","category":"section"},{"location":"pages/optimization/#See-Also","page":"Performance Optimization","title":"See Also","text":"Parallelism: MPI optimization\nTimesteppers: Choosing methods\nDomains: Resolution guidelines","category":"section"},{"location":"getting_started/first_steps/#First-Steps-with-Tarang.jl","page":"First Steps with Tarang.jl","title":"First Steps with Tarang.jl","text":"This tutorial introduces the basic workflow for setting up and solving PDEs with Tarang.jl. We'll build a simple 2D diffusion problem step by step.","category":"section"},{"location":"getting_started/first_steps/#The-Tarang.jl-Workflow","page":"First Steps with Tarang.jl","title":"The Tarang.jl Workflow","text":"Every Tarang.jl simulation follows these steps:\n\nInitialize MPI for parallel computing\nDefine coordinates and create a distributor for MPI processes\nChoose spectral bases for each coordinate direction\nCreate a domain combining the bases\nDefine fields (scalar, vector, or tensor)\nSet up a problem (IVP, BVP, or EVP)\nAdd equations using symbolic syntax\nSpecify boundary conditions\nCreate a solver with a timestepper\nRun the simulation with time stepping\nAnalyze and output results\n\nLet's walk through each step with a concrete example.","category":"section"},{"location":"getting_started/first_steps/#Example:-2D-Heat-Diffusion","page":"First Steps with Tarang.jl","title":"Example: 2D Heat Diffusion","text":"We'll solve the 2D heat equation:\n\nfracpartial Tpartial t = kappa nabla^2 T\n\non a rectangular domain with Dirichlet boundary conditions.","category":"section"},{"location":"getting_started/first_steps/#Step-1:-Initialize-MPI","page":"First Steps with Tarang.jl","title":"Step 1: Initialize MPI","text":"Every Tarang.jl script starts by initializing MPI:\n\nusing Tarang\nusing MPI\n\nMPI.Init()","category":"section"},{"location":"getting_started/first_steps/#Step-2:-Define-Coordinates-and-Distributor","page":"First Steps with Tarang.jl","title":"Step 2: Define Coordinates and Distributor","text":"Coordinates define the dimension names and the MPI process distribution:\n\n# Create 2D Cartesian coordinates\ncoords = CartesianCoordinates(\"x\", \"z\")\n\n# Create distributor with 2×2 process mesh (4 MPI processes total)\ndist = Distributor(coords, mesh=(2, 2))\n\nThe mesh=(2, 2) means we'll use 4 MPI processes arranged in a 2×2 grid. This enables parallelization in both horizontal (x) and vertical (z) directions.\n\ntip: Choosing Process Mesh\nThe product of mesh dimensions should equal your MPI process count:mesh=(2, 2) → 4 processes\nmesh=(4, 2) → 8 processes\nmesh=(4, 4) → 16 processes","category":"section"},{"location":"getting_started/first_steps/#Step-3:-Choose-Spectral-Bases","page":"First Steps with Tarang.jl","title":"Step 3: Choose Spectral Bases","text":"Bases define the spectral representation in each direction:\n\n# Periodic direction (x) - use Fourier basis\nx_basis = RealFourier(coords[\"x\"], size=128, bounds=(0.0, 2π))\n\n# Bounded direction (z) - use Chebyshev basis\nz_basis = ChebyshevT(coords[\"z\"], size=64, bounds=(0.0, 1.0))\n\nBasis selection guide:\n\nFourier: Periodic boundaries (e.g., horizontal directions in atmospheric flows)\nChebyshev: Non-periodic with high accuracy (e.g., vertical direction with walls)\nLegendre: Non-periodic, alternative to Chebyshev\n\nThe size parameter determines the spectral resolution.","category":"section"},{"location":"getting_started/first_steps/#Step-4:-Create-Domain","page":"First Steps with Tarang.jl","title":"Step 4: Create Domain","text":"Combine the bases into a domain:\n\ndomain = Domain(dist, (x_basis, z_basis))\n\nThe domain handles the spatial discretization and MPI distribution.","category":"section"},{"location":"getting_started/first_steps/#Step-5:-Define-Fields","page":"First Steps with Tarang.jl","title":"Step 5: Define Fields","text":"Create a scalar field for temperature:\n\nT = ScalarField(dist, \"T\", (x_basis, z_basis))\n\nFor vector fields (like velocity):\n\nu = VectorField(dist, coords, \"u\", (x_basis, z_basis))","category":"section"},{"location":"getting_started/first_steps/#Step-6:-Set-Up-Problem","page":"First Steps with Tarang.jl","title":"Step 6: Set Up Problem","text":"Create an Initial Value Problem (IVP):\n\nproblem = IVP([T])\n\n# Add the heat equation\nadd_equation!(problem, \"∂t(T) = kappa*lap(T)\")\n\n# Set diffusion coefficient\nproblem.parameters[\"kappa\"] = 1.0\n\nThe equation uses symbolic notation:\n\n∂t(T): time derivative ∂T/∂t\nlap(T): Laplacian ∇²T\nkappa: a parameter we can easily modify","category":"section"},{"location":"getting_started/first_steps/#Step-7:-Add-Boundary-Conditions","page":"First Steps with Tarang.jl","title":"Step 7: Add Boundary Conditions","text":"Specify boundary conditions at the domain edges:\n\n# Bottom wall (z=0): hot, T=1\nadd_equation!(problem, \"T(z=0) = 1\")\n\n# Top wall (z=1): cold, T=0\nadd_equation!(problem, \"T(z=1) = 0\")\n\nThe x-direction is periodic (RealFourier basis), so no boundary conditions are needed there.","category":"section"},{"location":"getting_started/first_steps/#Step-8:-Create-Solver","page":"First Steps with Tarang.jl","title":"Step 8: Create Solver","text":"Choose a timestepper and create the solver:\n\n# RK222 is a good general-purpose IMEX timestepper\ntimestepper = RK222()\nsolver = InitialValueSolver(problem, timestepper, dt=0.001)\n\nPopular timesteppers:\n\nRK222, RK443: IMEX Runge-Kutta (good for most problems)\nCNAB2, SBDF2: IMEX multistep methods (for stiff problems)","category":"section"},{"location":"getting_started/first_steps/#Step-9:-Set-Initial-Conditions","page":"First Steps with Tarang.jl","title":"Step 9: Set Initial Conditions","text":"Initialize the temperature field:\n\n# Get the grid space representation\nT_grid = get_grid_data(T)\n\n# Set a Gaussian perturbation\nfor i in 1:size(T_grid, 1), j in 1:size(T_grid, 2)\n    x = (i-1) * 2π / 128\n    z = (j-1) / 64\n    T_grid[i, j] = 0.5 + 0.1 * exp(-((x-π)^2 + (z-0.5)^2) / 0.1)\nend\n\n# Transform to spectral space\nto_spectral!(T)","category":"section"},{"location":"getting_started/first_steps/#Step-10:-Run-Simulation","page":"First Steps with Tarang.jl","title":"Step 10: Run Simulation","text":"Time-step the solver:\n\nt_end = 1.0\niteration = 0\n\nwhile solver.sim_time < t_end\n    step!(solver)\n    iteration += 1\n\n    # Print progress every 100 steps\n    if iteration % 100 == 0 && MPI.Comm_rank(MPI.COMM_WORLD) == 0\n        println(\"Iteration: $iteration, Time: $(solver.sim_time)\")\n    end\nend","category":"section"},{"location":"getting_started/first_steps/#Step-11:-Finalize-MPI","page":"First Steps with Tarang.jl","title":"Step 11: Finalize MPI","text":"Always finalize MPI at the end:\n\nMPI.Finalize()","category":"section"},{"location":"getting_started/first_steps/#Complete-Example","page":"First Steps with Tarang.jl","title":"Complete Example","text":"Here's the full script:\n\nusing Tarang, MPI\n\nMPI.Init()\n\n# Setup\ncoords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords, mesh=(2, 2))\n\nx_basis = RealFourier(coords[\"x\"], size=128, bounds=(0.0, 2π))\nz_basis = ChebyshevT(coords[\"z\"], size=64, bounds=(0.0, 1.0))\n\ndomain = Domain(dist, (x_basis, z_basis))\nT = ScalarField(dist, \"T\", (x_basis, z_basis))\n\n# Problem\nproblem = IVP([T])\nadd_equation!(problem, \"∂t(T) = kappa*lap(T)\")\nproblem.parameters[\"kappa\"] = 0.01\n\n# Boundary conditions (Dedalus-style syntax auto-detected)\nadd_equation!(problem, \"T(z=0) = 1\")\nadd_equation!(problem, \"T(z=1) = 0\")\n\n# Solver\nsolver = InitialValueSolver(problem, RK222(), dt=0.001)\n\n# Initial conditions\nT_grid = get_grid_data(T)\nfor i in 1:size(T_grid, 1), j in 1:size(T_grid, 2)\n    x = (i-1) * 2π / 128\n    z = (j-1) / 64\n    T_grid[i, j] = 0.5 + 0.1 * exp(-((x-π)^2 + (z-0.5)^2) / 0.1)\nend\nto_spectral!(T)\n\n# Time stepping\nwhile solver.sim_time < 1.0\n    step!(solver)\nend\n\nMPI.Finalize()\n\nSave this as heat_diffusion.jl and run:\n\nmpiexec -n 4 julia heat_diffusion.jl","category":"section"},{"location":"getting_started/first_steps/#What's-Next?","page":"First Steps with Tarang.jl","title":"What's Next?","text":"Now that you understand the basic workflow, explore:\n\nRunning with MPI: Details on parallel execution\n2D Rayleigh-Bénard Tutorial: More complex fluid dynamics example\nBoundary Conditions: Advanced boundary condition types\nAnalysis and Output: Saving data and computing diagnostics","category":"section"},{"location":"getting_started/first_steps/#Common-Patterns","page":"First Steps with Tarang.jl","title":"Common Patterns","text":"","category":"section"},{"location":"getting_started/first_steps/#Multiple-Fields","page":"First Steps with Tarang.jl","title":"Multiple Fields","text":"For coupled PDEs with multiple fields:\n\nu = VectorField(dist, coords, \"u\", (x_basis, z_basis))\np = ScalarField(dist, \"p\", (x_basis, z_basis))\nT = ScalarField(dist, \"T\", (x_basis, z_basis))\n\nproblem = IVP([u.components[1], u.components[2], p, T])","category":"section"},{"location":"getting_started/first_steps/#Parameters","page":"First Steps with Tarang.jl","title":"Parameters","text":"Add and modify parameters easily:\n\nproblem.parameters[\"Ra\"] = 1e6  # Rayleigh number\nproblem.parameters[\"Pr\"] = 0.7  # Prandtl number\nproblem.parameters[\"kappa\"] = 0.01  # Thermal diffusivity","category":"section"},{"location":"getting_started/first_steps/#Adaptive-Time-Stepping","page":"First Steps with Tarang.jl","title":"Adaptive Time Stepping","text":"Use CFL condition for adaptive time steps:\n\ncfl = CFL(problem, safety=0.5)\nadd_velocity!(cfl, u)\n\nwhile solver.sim_time < t_end\n    dt = compute_timestep(cfl)\n    step!(solver, dt)\nend","category":"section"},{"location":"getting_started/first_steps/#Key-Takeaways","page":"First Steps with Tarang.jl","title":"Key Takeaways","text":"MPI must be initialized before creating any Tarang objects\nChoose bases appropriate for your boundary conditions (Fourier for periodic, Chebyshev/Legendre for bounded)\nProcess mesh should match your MPI process count\nSymbolic equations use natural mathematical notation\nBoundary conditions are specified separately from equations\nAlways finalize MPI at the end of your script","category":"section"},{"location":"pages/stochastic_forcing/#Stochastic-Forcing","page":"Stochastic Forcing","title":"Stochastic Forcing","text":"This page demonstrates how to set up a forced-dissipative 2D turbulence simulation, following the approach from GeophysicalFlows.jl.\n\n","category":"section"},{"location":"pages/stochastic_forcing/#TL;DR-Automatic-Forcing-(Recommended)","page":"Stochastic Forcing","title":"TL;DR - Automatic Forcing (Recommended)","text":"The simplest way to add stochastic forcing is using add_stochastic_forcing!:\n\n# 1. Create forcing\nforcing = StochasticForcing(\n    field_size = (256, 256),\n    energy_injection_rate = 0.1,\n    k_forcing = 10.0,\n    dt = dt\n)\n\n# 2. Register with problem by variable symbol - forcing is handled automatically!\nadd_stochastic_forcing!(problem, :ω, forcing)\n\n# 3. Just call step! - no manual forcing management needed\nfor step in 1:nsteps\n    step!(solver)  # Forcing generated & applied internally\nend\n\nThe timestepper automatically:\n\nGenerates forcing ONCE at the start of each timestep\nUses the SAME forcing value across all RK substeps\nAdds forcing to the RHS of the specified equation\n\nThis ensures correct Stratonovich calculus without any manual intervention.\n\n","category":"section"},{"location":"pages/stochastic_forcing/#Why-Stochastic-Forcing-Needs-Special-Handling","page":"Stochastic Forcing","title":"Why Stochastic Forcing Needs Special Handling","text":"White-in-time noise requires careful handling for correct statistics:\n\nStratonovich vs Itô: Physical systems use Stratonovich calculus where the chain rule works normally\nConstant within timestep: For Stratonovich correctness, forcing must be constant across all RK substeps\n√dt scaling: Discrete forcing needs F = √(Q̂/dt) · noise to give correct variance\n\nIf you wrote forcing as a regular RHS term, it would be evaluated at each RK stage with different random values - this gives wrong statistics (Itô instead of Stratonovich).\n\n","category":"section"},{"location":"pages/stochastic_forcing/#Complete-Example:-Forced-2D-Turbulence","page":"Stochastic Forcing","title":"Complete Example: Forced 2D Turbulence","text":"We simulate the 2D vorticity equation with stochastic forcing and linear drag:\n\nfracpartial omegapartial t + J(psi omega) = -mu omega + nu nabla^2 omega + xi\n\nwhere ξ is white-in-time, spatially-correlated stochastic forcing.\n\nusing Tarang\nusing Random\nusing Printf\n\n# ============================================================\n# 1. Physical and Numerical Parameters\n# ============================================================\n\n# Grid\nn = 256                     # Resolution\nL = 2π                      # Domain size\ndt = 0.005                  # Timestep\nnsteps = 4000               # Total steps\n\n# Dissipation\nν = 2e-7                    # Viscosity (hyperviscosity coefficient)\nμ = 1e-1                    # Linear drag coefficient\n\n# Forcing parameters\nforcing_wavenumber = 14.0 * 2π/L    # k_f: force at this scale\nforcing_bandwidth = 1.5 * 2π/L      # δ_f: width of forcing ring\nε = 0.1                              # Energy injection rate\n\n# ============================================================\n# 2. Set Up Domain and Fields\n# ============================================================\n\ncoords = CartesianCoordinates(\"x\", \"y\")\ndist = Distributor(coords; mesh=(1, 1))\n\nxbasis = RealFourier(coords[\"x\"]; size=n, bounds=(0.0, L))\nybasis = RealFourier(coords[\"y\"]; size=n, bounds=(0.0, L))\ndomain = Domain(dist, (xbasis, ybasis))\n\n# Vorticity field\nω = ScalarField(dist, \"omega\", (xbasis, ybasis))\n\n# ============================================================\n# 3. Create Stochastic Forcing\n# ============================================================\n\n# The forcing is concentrated in a ring around |k| = k_f\n# with Gaussian profile: exp(-(|k| - k_f)² / 2δ_f²)\n\nforcing = StochasticForcing(\n    field_size = (n, n),\n    domain_size = (L, L),\n    energy_injection_rate = ε,\n    k_forcing = forcing_wavenumber,\n    dk_forcing = forcing_bandwidth,\n    dt = dt,\n    spectrum_type = :ring,\n    rng = MersenneTwister(1234)     # For reproducibility\n)\n\nprintln(\"Forcing setup:\")\nprintln(\"  k_forcing = $(forcing_wavenumber) (mode ≈ $(forcing_wavenumber * L / 2π))\")\nprintln(\"  bandwidth = $(forcing_bandwidth)\")\nprintln(\"  ε = $(ε)\")\n\n# ============================================================\n# 4. Set Up Problem and Solver\n# ============================================================\n\nproblem = IVP([ω])\n\n# Vorticity equation: ∂ω/∂t = -μω + ν∇²ω - J(ψ,ω) + ξ\n# Note: Forcing ξ is NOT in the equation string - it's added automatically!\nadd_equation!(problem, \"∂t(ω) + μ*ω - ν*Δ(ω) = -J(ψ, ω)\")\nproblem.parameters[\"ν\"] = ν\nproblem.parameters[\"μ\"] = μ\n\n# Register stochastic forcing - it will be added to ω's RHS automatically\nadd_stochastic_forcing!(problem, :ω, forcing)\n\nsolver = InitialValueSolver(problem, RK443(); dt=dt, device=\"cpu\")\n\n# ============================================================\n# 5. Diagnostics: Energy and Enstrophy\n# ============================================================\n\nfunction compute_energy(ω_hat, grid)\n    # E = ½⟨|∇ψ|²⟩ = ½ ∑_k |ω̂_k|² / |k|²\n    E = 0.0\n    for j in 1:size(ω_hat, 2), i in 1:size(ω_hat, 1)\n        k2 = grid.kx[i]^2 + grid.ky[j]^2\n        if k2 > 0\n            E += abs2(ω_hat[i,j]) / k2\n        end\n    end\n    return 0.5 * E / prod(size(ω_hat))\nend\n\nfunction compute_enstrophy(ω_hat)\n    # Z = ½⟨ω²⟩ = ½ ∑_k |ω̂_k|²\n    return 0.5 * sum(abs2, ω_hat) / prod(size(ω_hat))\nend\n\n# ============================================================\n# 6. Time Integration Loop\n# ============================================================\n\n# Storage for diagnostics\nt_save = Float64[]\nE_save = Float64[]\nZ_save = Float64[]\nwork_save = Float64[]\n\nprintln(\"\\nStarting simulation...\")\nprintln(\"=\" ^ 60)\n\nfor step in 1:nsteps\n    # Store previous solution for Stratonovich work calculation (optional diagnostic)\n    store_prevsol!(forcing, ω.data_c)\n\n    # Advance one timestep - forcing is generated and applied automatically!\n    step!(solver)\n\n    # Compute work done by forcing (Stratonovich) - optional diagnostic\n    W = work_stratonovich(forcing, ω.data_c)\n\n    # Periodic diagnostics\n    if step % 100 == 0 || step == 1\n        E = compute_energy(ω.data_c, domain.grid)\n        Z = compute_enstrophy(ω.data_c)\n\n        push!(t_save, solver.sim_time)\n        push!(E_save, E)\n        push!(Z_save, Z)\n        push!(work_save, W)\n\n        @printf(\"step %4d, t = %6.3f, E = %.2e, Z = %.2e, W = %+.2e\\n\",\n                step, solver.sim_time, E, Z, W)\n    end\nend\n\nprintln(\"=\" ^ 60)\nprintln(\"Simulation complete!\")\nprintln(\"Final time: $(solver.sim_time)\")\nprintln(\"Mean energy injection rate: $(mean(work_save ./ dt))\")\n\n","category":"section"},{"location":"pages/stochastic_forcing/#Understanding-the-Example","page":"Stochastic Forcing","title":"Understanding the Example","text":"","category":"section"},{"location":"pages/stochastic_forcing/#Forcing-Spectrum","page":"Stochastic Forcing","title":"Forcing Spectrum","text":"The forcing concentrates energy input around a specific wavenumber:\n\n          │\n    Q̂(k)  │      ╱╲\n          │    ╱    ╲\n          │  ╱        ╲\n          │╱            ╲\n          └──────────────────► |k|\n                k_f\n               ←─────→\n              2*δ_f (width)\n\nModes with |k| ≈ k_f receive most of the energy. This creates a dual cascade:\n\nEnergy cascades to large scales (inverse cascade)\nEnstrophy cascades to small scales (forward cascade)","category":"section"},{"location":"pages/stochastic_forcing/#Energy-Balance","page":"Stochastic Forcing","title":"Energy Balance","text":"In steady state:\n\nvarepsilon_textforcing = varepsilon_textdrag + varepsilon_textviscous\n\nThe linear drag μ removes energy at large scales, preventing condensation.\n\n","category":"section"},{"location":"pages/stochastic_forcing/#Step-by-Step-Breakdown","page":"Stochastic Forcing","title":"Step-by-Step Breakdown","text":"","category":"section"},{"location":"pages/stochastic_forcing/#Step-1:-Choose-Forcing-Parameters","page":"Stochastic Forcing","title":"Step 1: Choose Forcing Parameters","text":"# Where to inject energy (wavenumber)\nforcing_wavenumber = 14.0 * 2π/L  # Mode k ≈ 14\n\n# How spread out the forcing is\nforcing_bandwidth = 1.5 * 2π/L    # A few modes wide\n\n# How much energy to inject per unit time\nε = 0.1\n\nGuidelines:\n\nk_forcing: Set to intermediate scales (not too large, not too small)\ndk_forcing: Usually 1-3 in mode units; too narrow causes intermittency\nε: Balance with dissipation; if energy grows unbounded, increase μ or ν","category":"section"},{"location":"pages/stochastic_forcing/#Step-2:-Create-the-Forcing-Object","page":"Stochastic Forcing","title":"Step 2: Create the Forcing Object","text":"forcing = StochasticForcing(\n    field_size = (n, n),              # Match your grid\n    domain_size = (L, L),             # Match your domain\n    energy_injection_rate = ε,        # Normalized automatically\n    k_forcing = forcing_wavenumber,\n    dk_forcing = forcing_bandwidth,\n    dt = dt,                          # For √dt scaling\n    spectrum_type = :ring,            # Isotropic ring\n    rng = MersenneTwister(1234)       # Reproducibility\n)","category":"section"},{"location":"pages/stochastic_forcing/#Step-3:-Apply-Forcing-in-Time-Loop","page":"Stochastic Forcing","title":"Step 3: Apply Forcing in Time Loop","text":"for step in 1:nsteps\n    # 1. Store ψⁿ for Stratonovich work\n    store_prevsol!(forcing, ω.data_c)\n\n    # 2. Generate F̂ (new forcing each timestep)\n    F_hat = generate_forcing!(forcing, t, 1)\n\n    # 3. Add to your RHS: rhs .+= F_hat\n    apply_forcing!(rhs, forcing, t, 1)\n\n    # 4. Advance your solution\n    step!(solver)\n\n    # 5. Compute work done\n    W = work_stratonovich(forcing, ω.data_c)\nend","category":"section"},{"location":"pages/stochastic_forcing/#Step-4:-Verify-Energy-Budget","page":"Stochastic Forcing","title":"Step 4: Verify Energy Budget","text":"# Average over many timesteps in steady state\nε_measured = mean(work_array) / dt\n\n# Should match target\n@assert abs(ε_measured - ε) / ε < 0.1  \"Energy budget not balanced!\"\n\n","category":"section"},{"location":"pages/stochastic_forcing/#Spectrum-Types","page":"Stochastic Forcing","title":"Spectrum Types","text":"","category":"section"},{"location":"pages/stochastic_forcing/#Ring-Forcing-(:ring)-Default","page":"Stochastic Forcing","title":"Ring Forcing (:ring) - Default","text":"Forces modes in a Gaussian ring around |k| = k_f:\n\nforcing = StochasticForcing(\n    field_size = (256, 256),\n    k_forcing = 10.0,\n    dk_forcing = 2.0,\n    spectrum_type = :ring\n)\n\nBest for: Standard 2D/3D turbulence, dual cascade studies","category":"section"},{"location":"pages/stochastic_forcing/#Band-Forcing-(:band)","page":"Stochastic Forcing","title":"Band Forcing (:band)","text":"Sharp cutoff band |k| ∈ [k_f - δ_f, k_f + δ_f]:\n\nforcing = StochasticForcing(\n    field_size = (256, 256),\n    k_forcing = 10.0,\n    dk_forcing = 2.0,\n    spectrum_type = :band\n)\n\nBest for: Controlled experiments with exact spectral support","category":"section"},{"location":"pages/stochastic_forcing/#Low-k-Forcing-(:lowk)","page":"Stochastic Forcing","title":"Low-k Forcing (:lowk)","text":"Force all modes with |k| < k_f:\n\nforcing = StochasticForcing(\n    field_size = (256, 256),\n    k_forcing = 5.0,\n    spectrum_type = :lowk\n)\n\nBest for: Large-scale forcing, simple turbulence setups","category":"section"},{"location":"pages/stochastic_forcing/#Kolmogorov-Forcing-(:kolmogorov)","page":"Stochastic Forcing","title":"Kolmogorov Forcing (:kolmogorov)","text":"Smooth large-scale forcing for Kolmogorov cascade:\n\nforcing = StochasticForcing(\n    field_size = (256, 256),\n    k_forcing = 4.0,\n    spectrum_type = :kolmogorov\n)\n\nBest for: Kolmogorov-Obukhov theory verification\n\n","category":"section"},{"location":"pages/stochastic_forcing/#Mathematical-Background","page":"Stochastic Forcing","title":"Mathematical Background","text":"","category":"section"},{"location":"pages/stochastic_forcing/#Forcing-Statistics","page":"Stochastic Forcing","title":"Forcing Statistics","text":"The forcing ξ(x,t) is a random field with:\n\nProperty Formula\nZero mean ⟨ξ(x,t)⟩ = 0\nWhite in time ⟨ξ(x,t) ξ(x',t')⟩ = Q(x-x') δ(t-t')\nPower spectrum ⟨ξ̂(k) ξ̂*(k')⟩ = Q̂(k) δ(k-k')","category":"section"},{"location":"pages/stochastic_forcing/#Numerical-Implementation","page":"Stochastic Forcing","title":"Numerical Implementation","text":"For discrete time with step dt:\n\nhatF(k) = sqrtfrachatQ(k)dt cdot e^2pi i cdot textrand()\n\nThe √dt scaling gives correct variance: ⟨|F̂|²⟩ · dt = Q̂(k)","category":"section"},{"location":"pages/stochastic_forcing/#Energy-Injection-Rate","page":"Stochastic Forcing","title":"Energy Injection Rate","text":"varepsilon = int fracd^2 k(2pi)^2  frachatQ(k)2k^2\n\nTarang normalizes the spectrum to achieve the requested energy_injection_rate.","category":"section"},{"location":"pages/stochastic_forcing/#Stratonovich-vs-Itô","page":"Stochastic Forcing","title":"Stratonovich vs Itô","text":"Why Stratonovich?\n\nChain rule works normally: d(f(X)) = f'(X) dX\nPhysical limit of colored noise with τ→0\nSame formulas for stochastic and deterministic forcing\n\nWork calculation:\n\nCalculus Formula\nStratonovich W = -⟨(ψⁿ + ψⁿ⁺¹)/2 · F̂*⟩\nItô W = -⟨ψⁿ · F̂*⟩ + ε·dt\n\n","category":"section"},{"location":"pages/stochastic_forcing/#Multi-Stage-Timesteppers","page":"Stochastic Forcing","title":"Multi-Stage Timesteppers","text":"For RK4, SBDF, and other multi-stage methods, forcing must stay constant within a timestep:\n\nTimestep n:     [stage 1] → [stage 2] → [stage 3] → [stage 4]\nForcing:           F_n         F_n         F_n         F_n\n\nTimestep n+1:   [stage 1] → [stage 2] → [stage 3] → [stage 4]\nForcing:         F_{n+1}     F_{n+1}     F_{n+1}     F_{n+1}\n\nTarang handles this via the substep argument:\n\n# Substep 1: generates NEW forcing\ngenerate_forcing!(forcing, t, 1)\n\n# Substeps 2-4: returns CACHED forcing\ngenerate_forcing!(forcing, t, 2)  # Same as substep 1\ngenerate_forcing!(forcing, t, 3)  # Same as substep 1\ngenerate_forcing!(forcing, t, 4)  # Same as substep 1\n\n","category":"section"},{"location":"pages/stochastic_forcing/#Adaptive-Timestepping","page":"Stochastic Forcing","title":"Adaptive Timestepping","text":"When dt changes, update the forcing:\n\ndt_new = compute_timestep(cfl)\nset_dt!(forcing, dt_new)\ngenerate_forcing!(forcing, t, 1)\n\n","category":"section"},{"location":"pages/stochastic_forcing/#Troubleshooting","page":"Stochastic Forcing","title":"Troubleshooting","text":"Problem Cause Solution\nEnergy grows unbounded ε too high or dissipation too low Increase μ or ν, or decrease ε\nNo turbulence develops ε too low Increase energy_injection_rate\nForcing at wrong scales k_f mismatched Check units: k_f should be in radians, not mode number\nResults not reproducible RNG not seeded Pass rng = MersenneTwister(seed)\nJerky dynamics dt too large Reduce timestep or forcing bandwidth\n\n","category":"section"},{"location":"pages/stochastic_forcing/#API-Reference-Summary","page":"Stochastic Forcing","title":"API Reference Summary","text":"","category":"section"},{"location":"pages/stochastic_forcing/#Constructor","page":"Stochastic Forcing","title":"Constructor","text":"StochasticForcing(;\n    field_size,                          # (Nx, Ny) or (Nx, Ny, Nz)\n    domain_size = (2π, 2π, ...),        # (Lx, Ly, ...)\n    energy_injection_rate = 1.0,         # ε\n    k_forcing = 4.0,                     # k_f\n    dk_forcing = 1.0,                    # δ_f\n    dt = 0.01,\n    spectrum_type = :ring,               # :ring, :band, :lowk, :kolmogorov\n    rng = Random.GLOBAL_RNG,\n    dtype = Float64\n)","category":"section"},{"location":"pages/stochastic_forcing/#Key-Functions","page":"Stochastic Forcing","title":"Key Functions","text":"Function Purpose\ngenerate_forcing!(f, t, substep) Generate/cache forcing\napply_forcing!(rhs, f, t, substep) Add forcing to RHS\nstore_prevsol!(f, sol) Store ψⁿ for work calculation\nwork_stratonovich(f, sol) Compute Stratonovich work\nset_dt!(f, dt) Update timestep\nmean_energy_injection_rate(f) Get target ε\ninstantaneous_power(f, sol) Get current P(t)\n\n","category":"section"},{"location":"pages/stochastic_forcing/#See-Also","page":"Stochastic Forcing","title":"See Also","text":"Timesteppers - Time integration methods\nSolvers - Using forcing with IVP solvers\nAPI: Stochastic Forcing - Complete API reference","category":"section"},{"location":"pages/stochastic_forcing/#References","page":"Stochastic Forcing","title":"References","text":"GeophysicalFlows.jl Stochastic Forcing\nGeophysicalFlows.jl 2D NS Example\nConstantinou, N. C., & Hogg, A. M. (2021). \"Intrinsic oceanic decadal variability\"","category":"section"},{"location":"examples/gallery/#Example-Gallery","page":"Example Gallery","title":"Example Gallery","text":"This gallery showcases various problems that can be solved with Tarang.jl. Each example includes complete, runnable code and visualization.","category":"section"},{"location":"examples/gallery/#Quick-Navigation","page":"Example Gallery","title":"Quick Navigation","text":"","category":"section"},{"location":"examples/gallery/#By-Physics","page":"Example Gallery","title":"By Physics","text":"Fluid Dynamics\nHeat Transfer\nStability Analysis\nAtmospheric Flows","category":"section"},{"location":"examples/gallery/#By-Complexity","page":"Example Gallery","title":"By Complexity","text":"Beginner (⭐)\nIntermediate (⭐⭐)\nAdvanced (⭐⭐⭐)","category":"section"},{"location":"examples/gallery/#By-Features","page":"Example Gallery","title":"By Features","text":"2D Problems\n3D Problems\nTime-Dependent\nEigenvalue Problems\n\n","category":"section"},{"location":"examples/gallery/#Fluid-Dynamics","page":"Example Gallery","title":"Fluid Dynamics","text":"","category":"section"},{"location":"examples/gallery/#2D-Rayleigh-Bénard-Convection-(Intermediate)","page":"Example Gallery","title":"2D Rayleigh-Bénard Convection (Intermediate)","text":"Thermal convection in a horizontal layer heated from below.\n\nPhysics: Buoyancy-driven flow, convection cells, heat transfer\n\nFeatures:\n\nNavier-Stokes equations with buoyancy\nNo-slip boundary conditions\nAdaptive time stepping\nNusselt number analysis\n\nCode: See 2D Rayleigh-Bénard Tutorial for complete implementation\n\nTutorial: 2D Rayleigh-Bénard\n\n# Quick start\nmpiexec -n 4 julia examples/rayleigh_benard_2d.jl\n\nTypical Output:\n\nStarting Rayleigh-Bénard simulation\nRa = 1.0e6, Pr = 1.0\nResolution: 256 × 64\nMPI processes: 4\n============================================================\nt = 0.100, dt = 2.45e-04, Nu = 1.023\nt = 0.200, dt = 2.31e-04, Nu = 1.156\nt = 1.000, dt = 2.28e-04, Nu = 4.523\n\nParameters to Try:\n\nRa = 10⁴ to 10⁷ (different convection regimes)\nPr = 0.7 (air), 1.0 (water), 7.0 (oils)\nAspect ratio = 1, 2, 4, 8\n\n","category":"section"},{"location":"examples/gallery/#3D-Taylor-Green-Vortex-(Advanced)","page":"Example Gallery","title":"3D Taylor-Green Vortex (Advanced)","text":"Canonical test case for 3D turbulence and vortex dynamics.\n\nPhysics: Vortex stretching, energy cascade, turbulence\n\nFeatures:\n\n3D Navier-Stokes\nPeriodic boundaries all directions\nEnergy spectrum analysis\nEnstrophy tracking\n\nCode: See 3D Turbulence Tutorial for complete implementation\n\n# Run with 8 processes (2×2×2 mesh)\nmpiexec -n 8 julia examples/taylor_green_3d.jl\n\nVisualization: Vorticity isosurfaces, energy spectra\n\n","category":"section"},{"location":"examples/gallery/#3D-Channel-Flow-(Advanced)","page":"Example Gallery","title":"3D Channel Flow (Advanced)","text":"Turbulent flow between parallel plates.\n\nPhysics: Wall-bounded turbulence, Reynolds stress, mean profiles\n\nFeatures:\n\n3D Navier-Stokes with walls\nPeriodic in x,y; no-slip at z walls\nMean flow forcing\nTurbulence statistics\n\nCode: Example coming soon\n\nAnalysis: Mean velocity profile, Reynolds stresses, energy spectra\n\n","category":"section"},{"location":"examples/gallery/#2D-Kelvin-Helmholtz-Instability-(Intermediate)","page":"Example Gallery","title":"2D Kelvin-Helmholtz Instability (Intermediate)","text":"Shear flow instability and vortex formation.\n\nPhysics: Shear instability, vortex roll-up, mixing\n\nFeatures:\n\n2D Euler or Navier-Stokes\nShear layer with perturbation\nPeriodic boundaries\nVorticity evolution\n\nCode: Example coming soon\n\n","category":"section"},{"location":"examples/gallery/#Heat-Transfer","page":"Example Gallery","title":"Heat Transfer","text":"","category":"section"},{"location":"examples/gallery/#1D-Heat-Diffusion-(Beginner)","page":"Example Gallery","title":"1D Heat Diffusion (Beginner)","text":"Simple diffusion equation in one dimension.\n\nPhysics: Heat conduction, diffusion\n\nFeatures:\n\nSingle PDE\nDirichlet boundary conditions\nExact solution comparison\nGood first example\n\nCode: See example below\n\nusing Tarang, MPI\n\nMPI.Init()\n\ncoords = CartesianCoordinates(\"x\")\ndist = Distributor(coords, mesh=(4,))\n\nx = ChebyshevT(coords[\"x\"], size=64, bounds=(0.0, 1.0))\ndomain = Domain(dist, (x,))\n\nT = ScalarField(dist, \"T\", (x,))\n\nproblem = IVP([T])\nadd_equation!(problem, \"∂t(T) = kappa*lap(T)\")\nproblem.parameters[\"kappa\"] = 0.01\n\nadd_equation!(problem, \"T(x=0) = 1\")\nadd_equation!(problem, \"T(x=1) = 0\")\n\nsolver = InitialValueSolver(problem, RK222(), dt=0.001)\n\nwhile solver.sim_time < 1.0\n    step!(solver)\nend\n\nMPI.Finalize()\n\n","category":"section"},{"location":"examples/gallery/#2D-Steady-State-Heat-Conduction-(Beginner)","page":"Example Gallery","title":"2D Steady-State Heat Conduction (Beginner)","text":"Solve Laplace equation for steady heat distribution.\n\nPhysics: Steady-state diffusion, thermal equilibrium\n\nFeatures:\n\nBoundary value problem (LBVP)\nMixed boundary conditions\nSparse linear solve\n\nCode: Example coming soon\n\n","category":"section"},{"location":"examples/gallery/#3D-Thermal-Convection-with-Rotation-(Advanced)","page":"Example Gallery","title":"3D Thermal Convection with Rotation (Advanced)","text":"Rotating Rayleigh-Bénard convection.\n\nPhysics: Geophysical flows, rotation effects, Taylor-Proudman\n\nFeatures:\n\nCoriolis force\n3D buoyancy-driven flow\nPattern formation\n\nCode: Example coming soon\n\n","category":"section"},{"location":"examples/gallery/#Stability-Analysis","page":"Example Gallery","title":"Stability Analysis","text":"","category":"section"},{"location":"examples/gallery/#Rayleigh-Bénard-Linear-Stability-(Intermediate)","page":"Example Gallery","title":"Rayleigh-Bénard Linear Stability (Intermediate)","text":"Compute critical Rayleigh number and eigenmodes.\n\nPhysics: Hydrodynamic stability, critical conditions\n\nFeatures:\n\nEigenvalue problem (EVP)\nGrowth rates and frequencies\nCritical modes visualization\n\nCode: See Eigenvalue Problems Tutorial for complete implementation\n\nTutorial: Eigenvalue Problems\n\n","category":"section"},{"location":"examples/gallery/#Plane-Poiseuille-Stability-(Advanced)","page":"Example Gallery","title":"Plane Poiseuille Stability (Advanced)","text":"Stability of parallel shear flow.\n\nPhysics: Orr-Sommerfeld equation, Tollmien-Schlichting waves\n\nFeatures:\n\nOrr-Sommerfeld eigenvalue problem\nNeutral stability curves\nMost unstable modes\n\nCode: Example coming soon\n\n","category":"section"},{"location":"examples/gallery/#Wave-Propagation","page":"Example Gallery","title":"Wave Propagation","text":"","category":"section"},{"location":"examples/gallery/#1D-Linear-Wave-Equation-(Beginner)","page":"Example Gallery","title":"1D Linear Wave Equation (Beginner)","text":"Simple wave propagation.\n\nPhysics: Hyperbolic PDE, wave dynamics\n\nFeatures:\n\nSecond-order time derivative\nExact solutions\nWave reflections\n\nCode: Example coming soon\n\n","category":"section"},{"location":"examples/gallery/#2D-Acoustic-Waves-(Intermediate)","page":"Example Gallery","title":"2D Acoustic Waves (Intermediate)","text":"Sound wave propagation in 2D.\n\nPhysics: Acoustics, wave scattering\n\nFeatures:\n\nLinear acoustics\nPoint source\nRadiation patterns\n\nCode: Example coming soon\n\n","category":"section"},{"location":"examples/gallery/#Atmospheric-Flows","page":"Example Gallery","title":"Atmospheric Flows","text":"","category":"section"},{"location":"examples/gallery/#2D-Gravity-Waves-(Intermediate)","page":"Example Gallery","title":"2D Gravity Waves (Intermediate)","text":"Internal gravity waves in stratified fluid.\n\nPhysics: Stratified flows, buoyancy oscillations\n\nFeatures:\n\nBoussinesq equations\nStable stratification\nWave propagation\n\nCode: Example coming soon\n\n","category":"section"},{"location":"examples/gallery/#2D-Quasi-Geostrophic-Flow-(Advanced)","page":"Example Gallery","title":"2D Quasi-Geostrophic Flow (Advanced)","text":"Large-scale atmospheric/oceanic flows.\n\nPhysics: Geostrophic balance, Rossby waves\n\nFeatures:\n\nPotential vorticity equation\nBeta-plane approximation\nJet formation\n\nCode: Example coming soon\n\n","category":"section"},{"location":"examples/gallery/#Advanced-Examples","page":"Example Gallery","title":"Advanced Examples","text":"","category":"section"},{"location":"examples/gallery/#MHD-(Magnetohydrodynamics)-(Advanced)","page":"Example Gallery","title":"MHD (Magnetohydrodynamics) (Advanced)","text":"Fluid dynamics with magnetic fields.\n\nPhysics: Lorentz force, magnetic induction\n\nFeatures:\n\nCoupled fluid and magnetic fields\nAlfvén waves\nMagnetic energy\n\nCode: Example coming soon\n\n","category":"section"},{"location":"examples/gallery/#Double-Diffusive-Convection-(Advanced)","page":"Example Gallery","title":"Double-Diffusive Convection (Advanced)","text":"Convection driven by two diffusing species.\n\nPhysics: Salt-fingering, thermohaline circulation\n\nFeatures:\n\nTwo scalar fields (T and S)\nDifferent diffusivities\nLayering phenomena\n\nCode: Example coming soon\n\n","category":"section"},{"location":"examples/gallery/#Stratified-Shear-Flow-(Advanced)","page":"Example Gallery","title":"Stratified Shear Flow (Advanced)","text":"Combined shear and stratification.\n\nPhysics: Richardson number, mixing, turbulence\n\nFeatures:\n\nBackground shear and stratification\nKelvin-Helmholtz + gravity waves\nMixing efficiency\n\nCode: Example coming soon\n\n","category":"section"},{"location":"examples/gallery/#Example-Structure","page":"Example Gallery","title":"Example Structure","text":"Each example follows this structure:\n\n# 1. Load packages\nusing Tarang, MPI\n\n# 2. Initialize MPI\nMPI.Init()\n\n# 3. Parameters\nRa = 1e6\nPr = 1.0\n# ...\n\n# 4. Setup domain\ncoords = CartesianCoordinates(...)\ndist = Distributor(...)\nbases = (...)\ndomain = Domain(...)\n\n# 5. Create fields\nu = VectorField(...)\np = ScalarField(...)\n# ...\n\n# 6. Define problem\nproblem = IVP([...])\nadd_equation!(problem, \"...\")\nproblem.parameters[...] = ...\n\n# 7. Boundary conditions\nadd_equation!(problem, \"...\")\n\n# 8. Initial conditions\n# ... initialize fields ...\n\n# 9. Solver\nsolver = InitialValueSolver(...)\n\n# 10. Analysis setup\ncfl = CFL(...)\noutput_handler = add_netcdf_handler(...)\n\n# 11. Time loop\nwhile solver.sim_time < t_end\n    dt = compute_timestep(cfl)\n    step!(solver, dt)\n    # ... diagnostics ...\nend\n\n# 12. Cleanup\nMPI.Finalize()\n\n","category":"section"},{"location":"examples/gallery/#Running-Examples","page":"Example Gallery","title":"Running Examples","text":"","category":"section"},{"location":"examples/gallery/#From-Repository","page":"Example Gallery","title":"From Repository","text":"# Clone repository\ngit clone https://github.com/subhk/Tarang.jl.git\ncd Tarang.jl\n\n# Install dependencies\njulia --project -e 'using Pkg; Pkg.instantiate()'\n\n# Run an example\ncd examples\nmpiexec -n 4 julia rayleigh_benard_2d.jl","category":"section"},{"location":"examples/gallery/#Modifying-Examples","page":"Example Gallery","title":"Modifying Examples","text":"Copy an example and modify:\n\ncp examples/rayleigh_benard_2d.jl my_simulation.jl\n# Edit my_simulation.jl\nmpiexec -n 4 julia my_simulation.jl","category":"section"},{"location":"examples/gallery/#Creating-New-Examples","page":"Example Gallery","title":"Creating New Examples","text":"Start from a template:\n\ncp examples/template.jl my_new_example.jl\n# Follow the structure above\n\n","category":"section"},{"location":"examples/gallery/#Visualization","page":"Example Gallery","title":"Visualization","text":"","category":"section"},{"location":"examples/gallery/#During-Simulation","page":"Example Gallery","title":"During Simulation","text":"using Plots\n\nif solver.iteration % 100 == 0\n    T_grid = get_grid_data(T)\n    heatmap(T_grid')\n    savefig(\"output/T_$(solver.iteration).png\")\nend","category":"section"},{"location":"examples/gallery/#Post-Processing","page":"Example Gallery","title":"Post-Processing","text":"using Plots, HDF5\n\n# Load saved data\nT_data = h5read(\"output/fields.h5\", \"T\")\n\n# Animate\nanim = @animate for t in 1:size(T_data, 3)\n    heatmap(T_data[:, :, t]', clims=(0, 1))\nend\ngif(anim, \"animation.gif\", fps=15)\n\n","category":"section"},{"location":"examples/gallery/#Contributing-Examples","page":"Example Gallery","title":"Contributing Examples","text":"We welcome new examples! Guidelines:\n\nComplete and runnable: Include all necessary code\nWell-commented: Explain physics and numerics\nDocumented: Add to this gallery with description\nTested: Verify runs correctly with typical parameters\nRealistic: Use physically meaningful parameters\n\nSee Contributing Guide for details.\n\n","category":"section"},{"location":"examples/gallery/#Next-Steps","page":"Example Gallery","title":"Next Steps","text":"Learn the basics: Getting Started\nDetailed tutorials: Tutorials\nUnderstand the API: API Reference\nAsk questions: GitHub Discussions","category":"section"},{"location":"examples/gpu_fft_heuristics/#GPU-FFT-Heuristics","page":"GPU FFT Heuristics","title":"GPU FFT Heuristics","text":"Tarang lets you control when a field uses GPU FFTs via set_gpu_fft_min_elements! and per-field set_gpu_fft_mode!.\n\nusing Tarang\n\nfield = ScalarField(dist, \"θ\", bases)\nset_gpu_fft_mode!(field, :cpu)   # force CPU\nset_gpu_fft_mode!(field, :gpu)   # force GPU\nset_gpu_fft_mode!(field, :auto)  # default heuristic\n\nset_gpu_fft_min_elements!(64_000)  # global cutoff for :auto fields","category":"section"},{"location":"notebooks/taylor_green/#Notebook:-Taylor-Green-Vortex","page":"Notebook: Taylor-Green Vortex","title":"Notebook: Taylor-Green Vortex","text":"This notebook demonstrates the Taylor-Green vortex, a classic benchmark for DNS codes.","category":"section"},{"location":"notebooks/taylor_green/#Overview","page":"Notebook: Taylor-Green Vortex","title":"Overview","text":"The Taylor-Green vortex is an unsteady flow with an exact analytical solution that decays in time. It's commonly used to validate spectral codes and study the transition to turbulence.","category":"section"},{"location":"notebooks/taylor_green/#Setup","page":"Notebook: Taylor-Green Vortex","title":"Setup","text":"using Tarang\nusing MPI\nusing Plots\n\nMPI.Init()","category":"section"},{"location":"notebooks/taylor_green/#Parameters","page":"Notebook: Taylor-Green Vortex","title":"Parameters","text":"Re = 100.0       # Reynolds number\nnu = 1.0 / Re    # Kinematic viscosity\nL = 2π           # Domain size\nN = 64           # Resolution","category":"section"},{"location":"notebooks/taylor_green/#Domain-(Triply-Periodic)","page":"Notebook: Taylor-Green Vortex","title":"Domain (Triply Periodic)","text":"coords = CartesianCoordinates(\"x\", \"y\", \"z\")\ndist = Distributor(coords; mesh=(1,), dtype=Float64)\n\n# All Fourier bases for periodic boundaries\nx_basis = RealFourier(coords[\"x\"]; size=N, bounds=(0.0, L), dealias=1.5)\ny_basis = RealFourier(coords[\"y\"]; size=N, bounds=(0.0, L), dealias=1.5)\nz_basis = RealFourier(coords[\"z\"]; size=N, bounds=(0.0, L), dealias=1.5)\n\ndomain = Domain(dist, (x_basis, y_basis, z_basis))","category":"section"},{"location":"notebooks/taylor_green/#Fields","page":"Notebook: Taylor-Green Vortex","title":"Fields","text":"ux = ScalarField(dist, \"ux\", (x_basis, y_basis, z_basis), Float64)\nuy = ScalarField(dist, \"uy\", (x_basis, y_basis, z_basis), Float64)\nuz = ScalarField(dist, \"uz\", (x_basis, y_basis, z_basis), Float64)\np = ScalarField(dist, \"p\", (x_basis, y_basis, z_basis), Float64)","category":"section"},{"location":"notebooks/taylor_green/#Problem-Definition","page":"Notebook: Taylor-Green Vortex","title":"Problem Definition","text":"problem = IVP([ux, uy, uz, p])\nproblem.parameters[\"nu\"] = nu\n\n# Momentum equations\nTarang.add_equation!(problem,\n    \"∂t(ux) + ux*∂x(ux) + uy*∂y(ux) + uz*∂z(ux) + ∂x(p) = nu*Δ(ux)\")\nTarang.add_equation!(problem,\n    \"∂t(uy) + ux*∂x(uy) + uy*∂y(uy) + uz*∂z(uy) + ∂y(p) = nu*Δ(uy)\")\nTarang.add_equation!(problem,\n    \"∂t(uz) + ux*∂x(uz) + uy*∂y(uz) + uz*∂z(uz) + ∂z(p) = nu*Δ(uz)\")\n\n# Continuity\nTarang.add_equation!(problem, \"∂x(ux) + ∂y(uy) + ∂z(uz) = 0\")","category":"section"},{"location":"notebooks/taylor_green/#Analytical-Solution","page":"Notebook: Taylor-Green Vortex","title":"Analytical Solution","text":"Taylor-Green initial condition:\n\nbeginaligned\nu = cos(x) sin(y) cos(z) \nv = -sin(x) cos(y) cos(z) \nw = 0 \np = frac116cos(2x) + cos(2y)cos(2z) + 2\nendaligned\n\nTime evolution (viscous decay):\n\nu(xt) = u_0(x) e^-2nu t","category":"section"},{"location":"notebooks/taylor_green/#Initial-Conditions","page":"Notebook: Taylor-Green Vortex","title":"Initial Conditions","text":"function taylor_green_ic!(ux, uy, uz)\n    x = get_grid(ux.bases[1])\n    y = get_grid(ux.bases[2])\n    z = get_grid(ux.bases[3])\n\n    Tarang.ensure_layout!(ux, :g)\n    Tarang.ensure_layout!(uy, :g)\n    Tarang.ensure_layout!(uz, :g)\n\n    for i in eachindex(x), j in eachindex(y), k in eachindex(z)\n        ux.data_g[i,j,k] =  cos(x[i]) * sin(y[j]) * cos(z[k])\n        uy.data_g[i,j,k] = -sin(x[i]) * cos(y[j]) * cos(z[k])\n        uz.data_g[i,j,k] = 0.0\n    end\n\n    Tarang.ensure_layout!(ux, :c)\n    Tarang.ensure_layout!(uy, :c)\n    Tarang.ensure_layout!(uz, :c)\nend\n\ntaylor_green_ic!(ux, uy, uz)","category":"section"},{"location":"notebooks/taylor_green/#Diagnostic-Functions","page":"Notebook: Taylor-Green Vortex","title":"Diagnostic Functions","text":"function kinetic_energy(ux, uy, uz)\n    Tarang.ensure_layout!(ux, :g)\n    Tarang.ensure_layout!(uy, :g)\n    Tarang.ensure_layout!(uz, :g)\n\n    return 0.5 * mean(ux.data_g.^2 + uy.data_g.^2 + uz.data_g.^2)\nend\n\nfunction enstrophy(ux, uy, uz)\n    # Simplified: full implementation needs curl\n    return 0.0  # Placeholder\nend\n\n# Analytical kinetic energy decay\nKE_analytical(t, nu) = 0.125 * exp(-4*nu*t)","category":"section"},{"location":"notebooks/taylor_green/#Solver","page":"Notebook: Taylor-Green Vortex","title":"Solver","text":"solver = InitialValueSolver(problem, RK443(); dt=0.01)\n\ncfl = CFL(problem; safety=0.5)\nadd_velocity!(cfl, ux)\nadd_velocity!(cfl, uy)\nadd_velocity!(cfl, uz)","category":"section"},{"location":"notebooks/taylor_green/#Simulation","page":"Notebook: Taylor-Green Vortex","title":"Simulation","text":"t_end = 10.0\n\ntimes = Float64[]\nKE_numerical = Float64[]\nKE_exact = Float64[]\n\nwhile solver.sim_time < t_end\n    dt = compute_timestep(cfl)\n    step!(solver, dt)\n\n    if solver.iteration % 10 == 0\n        t = solver.sim_time\n        KE = kinetic_energy(ux, uy, uz)\n\n        push!(times, t)\n        push!(KE_numerical, KE)\n        push!(KE_exact, KE_analytical(t, nu))\n\n        println(\"t = $t, KE = $KE\")\n    end\nend","category":"section"},{"location":"notebooks/taylor_green/#Results","page":"Notebook: Taylor-Green Vortex","title":"Results","text":"","category":"section"},{"location":"notebooks/taylor_green/#Energy-Decay","page":"Notebook: Taylor-Green Vortex","title":"Energy Decay","text":"plot(times, KE_numerical, label=\"Numerical\", marker=:circle)\nplot!(times, KE_exact, label=\"Analytical\", linestyle=:dash)\nxlabel!(\"Time\")\nylabel!(\"Kinetic Energy\")\ntitle!(\"Taylor-Green Vortex Energy Decay (Re=$Re)\")","category":"section"},{"location":"notebooks/taylor_green/#Error","page":"Notebook: Taylor-Green Vortex","title":"Error","text":"relative_error = abs.(KE_numerical .- KE_exact) ./ KE_exact\nplot(times, relative_error,\n    xlabel=\"Time\",\n    ylabel=\"Relative Error\",\n    title=\"Energy Error\",\n    yscale=:log10\n)","category":"section"},{"location":"notebooks/taylor_green/#Vorticity-Visualization","page":"Notebook: Taylor-Green Vortex","title":"Vorticity Visualization","text":"# Slice at z = π\nTarang.ensure_layout!(ux, :g)\nslice_idx = N÷2\n\nux_slice = ux.data_g[:, :, slice_idx]\nheatmap(ux_slice',\n    xlabel=\"x\", ylabel=\"y\",\n    title=\"ux at z=π, t=$(solver.sim_time)\"\n)","category":"section"},{"location":"notebooks/taylor_green/#High-Reynolds-Number","page":"Notebook: Taylor-Green Vortex","title":"High Reynolds Number","text":"For transition to turbulence:\n\n# Re = 1600 is classic benchmark\nRe_high = 1600\nN_high = 256  # Need more resolution\n\n# At high Re:\n# - Initial structure breaks down\n# - Energy cascades to small scales\n# - Enstrophy peaks then decays","category":"section"},{"location":"notebooks/taylor_green/#Exercises","page":"Notebook: Taylor-Green Vortex","title":"Exercises","text":"Convergence study: N = 32, 64, 128, 256\nReynolds number scan: Re = 100, 400, 1600, 3000\nEnergy spectrum: Compute at different times\nEnstrophy evolution: Track vorticity magnitude","category":"section"},{"location":"notebooks/taylor_green/#Cleanup","page":"Notebook: Taylor-Green Vortex","title":"Cleanup","text":"MPI.Finalize()","category":"section"},{"location":"notebooks/taylor_green/#References","page":"Notebook: Taylor-Green Vortex","title":"References","text":"Taylor, G.I. & Green, A.E. (1937). Mechanism of the production of small eddies from large ones\nBrachet, M.E. et al. (1983). Small-scale structure of the Taylor-Green vortex","category":"section"},{"location":"examples/fluid_dynamics/#Fluid-Dynamics-Examples","page":"Fluid Dynamics Examples","title":"Fluid Dynamics Examples","text":"Collection of fluid dynamics simulations with Tarang.jl.","category":"section"},{"location":"examples/fluid_dynamics/#Incompressible-Navier-Stokes","page":"Fluid Dynamics Examples","title":"Incompressible Navier-Stokes","text":"","category":"section"},{"location":"examples/fluid_dynamics/#2D-Lid-Driven-Cavity","page":"Fluid Dynamics Examples","title":"2D Lid-Driven Cavity","text":"Classic benchmark for viscous flow.\n\nusing Tarang, MPI\nMPI.Init()\n\nRe = 1000\nLx, Lz = 1.0, 1.0\nNx, Nz = 128, 128\n\ncoords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords; mesh=(1,), dtype=Float64)\n\nx_basis = ChebyshevT(coords[\"x\"]; size=Nx, bounds=(0.0, Lx))\nz_basis = ChebyshevT(coords[\"z\"]; size=Nz, bounds=(0.0, Lz))\n\nux = ScalarField(dist, \"ux\", (x_basis, z_basis), Float64)\nuz = ScalarField(dist, \"uz\", (x_basis, z_basis), Float64)\np = ScalarField(dist, \"p\", (x_basis, z_basis), Float64)\n\nproblem = IVP([ux, uz, p])\nproblem.parameters[\"nu\"] = 1.0/Re\n\nTarang.add_equation!(problem, \"∂t(ux) + ux*∂x(ux) + uz*∂z(ux) + ∂x(p) = nu*Δ(ux)\")\nTarang.add_equation!(problem, \"∂t(uz) + ux*∂x(uz) + uz*∂z(uz) + ∂z(p) = nu*Δ(uz)\")\nTarang.add_equation!(problem, \"∂x(ux) + ∂z(uz) = 0\")\n\n# Bottom, left, right walls: no-slip\nTarang.add_equation!(problem, \"ux(z=0) = 0\")\nTarang.add_equation!(problem, \"ux(x=0) = 0\")\nTarang.add_equation!(problem, \"ux(x=$Lx) = 0\")\n# Top wall: moving lid\nTarang.add_equation!(problem, \"ux(z=$Lz) = 1\")\n# All walls: no penetration\nTarang.add_equation!(problem, \"uz(z=0) = 0\")\nTarang.add_equation!(problem, \"uz(z=$Lz) = 0\")\nTarang.add_equation!(problem, \"uz(x=0) = 0\")\nTarang.add_equation!(problem, \"uz(x=$Lx) = 0\")\n\nsolver = InitialValueSolver(problem, SBDF2(); dt=1e-3)\n# ... time integration ...\n\nMPI.Finalize()","category":"section"},{"location":"examples/fluid_dynamics/#Kelvin-Helmholtz-Instability","page":"Fluid Dynamics Examples","title":"Kelvin-Helmholtz Instability","text":"Shear layer instability in periodic domain.\n\n# Setup\ncoords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords; mesh=(2, 2), dtype=Float64)\n\nx_basis = RealFourier(coords[\"x\"]; size=256, bounds=(0.0, 1.0))\nz_basis = RealFourier(coords[\"z\"]; size=256, bounds=(0.0, 1.0))\n\n# Initial shear layer with perturbation\nfunction init_kh!(ux, uz, δ, A)\n    x = get_grid(ux.bases[1])\n    z = get_grid(ux.bases[2])\n\n    Tarang.ensure_layout!(ux, :g)\n    Tarang.ensure_layout!(uz, :g)\n\n    for i in eachindex(x), j in eachindex(z)\n        ux.data_g[i,j] = tanh((z[j] - 0.5) / δ)\n        uz.data_g[i,j] = A * sin(2π * x[i]) * exp(-((z[j]-0.5)/δ)^2)\n    end\nend\n\ninit_kh!(ux, uz, 0.05, 0.01)","category":"section"},{"location":"examples/fluid_dynamics/#Thermal-Convection","page":"Fluid Dynamics Examples","title":"Thermal Convection","text":"","category":"section"},{"location":"examples/fluid_dynamics/#Double-Diffusive-Convection","page":"Fluid Dynamics Examples","title":"Double-Diffusive Convection","text":"Convection with both temperature and salinity.\n\nproblem = IVP([ux, uz, p, T, S])\nproblem.parameters[\"Pr\"] = 7.0    # Prandtl\nproblem.parameters[\"tau\"] = 0.01  # Diffusivity ratio\nproblem.parameters[\"Ra_T\"] = 1e6  # Thermal Rayleigh\nproblem.parameters[\"Ra_S\"] = 1e5  # Solutal Rayleigh\n\nTarang.add_equation!(problem, \"∂t(ux) + ... = Pr*Δ(ux)\")\nTarang.add_equation!(problem, \"∂t(uz) + ... = Pr*Δ(uz) + Ra_T*Pr*T - Ra_S*Pr*S\")\nTarang.add_equation!(problem, \"∂x(ux) + ∂z(uz) = 0\")\nTarang.add_equation!(problem, \"∂t(T) + ... = Δ(T)\")\nTarang.add_equation!(problem, \"∂t(S) + ... = tau*Δ(S)\")","category":"section"},{"location":"examples/fluid_dynamics/#Rotating-Convection","page":"Fluid Dynamics Examples","title":"Rotating Convection","text":"With Coriolis force.\n\nproblem.parameters[\"Ek\"] = 1e-4   # Ekman number\nproblem.parameters[\"Ra\"] = 1e7\n\n# Include Coriolis term: 2Ω × u\nTarang.add_equation!(problem,\n    \"∂t(ux) + ... = Pr*Δ(ux) - (2/Ek)*uy\")\nTarang.add_equation!(problem,\n    \"∂t(uy) + ... = Pr*Δ(uy) + (2/Ek)*ux\")","category":"section"},{"location":"examples/fluid_dynamics/#Stratified-Flows","page":"Fluid Dynamics Examples","title":"Stratified Flows","text":"","category":"section"},{"location":"examples/fluid_dynamics/#Internal-Gravity-Waves","page":"Fluid Dynamics Examples","title":"Internal Gravity Waves","text":"problem = IVP([ux, uz, p, b])  # b = buoyancy\nproblem.parameters[\"N2\"] = 1.0  # Brunt-Väisälä frequency squared\n\nTarang.add_equation!(problem, \"∂t(ux) + ... + ∂x(p) = nu*Δ(ux)\")\nTarang.add_equation!(problem, \"∂t(uz) + ... + ∂z(p) = nu*Δ(uz) + b\")\nTarang.add_equation!(problem, \"∂x(ux) + ∂z(uz) = 0\")\nTarang.add_equation!(problem, \"∂t(b) + N2*uz + ... = kappa*Δ(b)\")","category":"section"},{"location":"examples/fluid_dynamics/#Turbulence","page":"Fluid Dynamics Examples","title":"Turbulence","text":"","category":"section"},{"location":"examples/fluid_dynamics/#Homogeneous-Isotropic-Turbulence","page":"Fluid Dynamics Examples","title":"Homogeneous Isotropic Turbulence","text":"Forced turbulence in triply-periodic box.\n\n# Add forcing to low wavenumbers\nfunction add_forcing!(problem)\n    # Forcing term F added to momentum equations\n    # Target specific wavenumber shells\nend\n\n# Monitor energy spectrum\nfunction energy_spectrum(u)\n    # Shell-averaged E(k)\nend\n\n# Monitor dissipation\nfunction dissipation_rate(u, nu)\n    # ε = 2ν⟨S_ij S_ij⟩\nend","category":"section"},{"location":"examples/fluid_dynamics/#Decaying-Turbulence","page":"Fluid Dynamics Examples","title":"Decaying Turbulence","text":"Study energy cascade without forcing.\n\n# Initialize with random velocity field\n# Filter to specific wavenumber range\n# Watch energy decay and cascade","category":"section"},{"location":"examples/fluid_dynamics/#Tips","page":"Fluid Dynamics Examples","title":"Tips","text":"","category":"section"},{"location":"examples/fluid_dynamics/#Resolution-Requirements","page":"Fluid Dynamics Examples","title":"Resolution Requirements","text":"Problem Typical Resolution\nLaminar 64-128\nTransitional 128-256\nTurbulent (moderate Re) 256-512\nTurbulent (high Re) 512-2048+","category":"section"},{"location":"examples/fluid_dynamics/#Timestepping","page":"Fluid Dynamics Examples","title":"Timestepping","text":"Use RK443 for advection-dominated flows\nUse SBDF2/3 for diffusion-dominated or stiff problems\nAlways use CFL-based adaptive stepping","category":"section"},{"location":"examples/fluid_dynamics/#Diagnostics","page":"Fluid Dynamics Examples","title":"Diagnostics","text":"Always monitor:\n\nKinetic energy\nMaximum velocity (CFL check)\nDivergence (should be ~machine precision)\nPhysical observables (Nu, drag, etc.)","category":"section"},{"location":"examples/fluid_dynamics/#See-Also","page":"Fluid Dynamics Examples","title":"See Also","text":"Rayleigh-Bénard Tutorial\nHeat Transfer Examples\nExample Gallery","category":"section"},{"location":"pages/fields/#Fields","page":"Fields","title":"Fields","text":"Fields represent physical quantities distributed across the computational domain.","category":"section"},{"location":"pages/fields/#Field-Types","page":"Fields","title":"Field Types","text":"","category":"section"},{"location":"pages/fields/#ScalarField","page":"Fields","title":"ScalarField","text":"Single-component fields like temperature or pressure.\n\nusing Tarang\n\n# Create scalar field\nT = ScalarField(dist, \"temperature\", (x_basis, z_basis), Float64)\np = ScalarField(dist, \"pressure\", (x_basis, z_basis), Float64)","category":"section"},{"location":"pages/fields/#VectorField","page":"Fields","title":"VectorField","text":"Multi-component fields like velocity.\n\n# Create velocity field\nu = VectorField(dist, coords, \"u\", (x_basis, z_basis), Float64)\n\n# Access components\nux = u.components[1]  # x-component\nuz = u.components[2]  # z-component","category":"section"},{"location":"pages/fields/#TensorField","page":"Fields","title":"TensorField","text":"Rank-2 tensor fields like stress tensors.\n\n# Stress tensor (symmetric)\ntau = TensorField(dist, coords, \"tau\", bases; symmetric=true)\n\n# Velocity gradient (not symmetric)\ngrad_u = TensorField(dist, coords, \"grad_u\", bases; symmetric=false)","category":"section"},{"location":"pages/fields/#Field-Properties","page":"Fields","title":"Field Properties","text":"field.name          # String: field name\nfield.dist          # Distributor\nfield.bases         # Tuple of spectral bases\nfield.dtype         # Data type (Float64, etc.)\nfield.current_layout # :g (grid) or :c (coefficient)\nfield.data_g        # Grid space data (when in :g layout)\nfield.data_c        # Coefficient data (when in :c layout)","category":"section"},{"location":"pages/fields/#Data-Access","page":"Fields","title":"Data Access","text":"","category":"section"},{"location":"pages/fields/#Grid-Space","page":"Fields","title":"Grid Space","text":"# Ensure field is in grid space\nTarang.ensure_layout!(field, :g)\n\n# Access data\ndata = field.data_g\n\n# Modify values\ndata[10, 20] = 1.0\ndata .= sin.(x_grid) .* cos.(z_grid)","category":"section"},{"location":"pages/fields/#Coefficient-Space","page":"Fields","title":"Coefficient Space","text":"# Ensure field is in coefficient space\nTarang.ensure_layout!(field, :c)\n\n# Access spectral coefficients\ncoeffs = field.data_c\n\n# Set specific modes\ncoeffs[1, 1] = 0.0  # Zero mean","category":"section"},{"location":"pages/fields/#Initialization","page":"Fields","title":"Initialization","text":"","category":"section"},{"location":"pages/fields/#Constant-Value","page":"Fields","title":"Constant Value","text":"Tarang.ensure_layout!(field, :g)\nfield.data_g .= 1.0","category":"section"},{"location":"pages/fields/#From-Function","page":"Fields","title":"From Function","text":"function initialize_field!(field, f)\n    Tarang.ensure_layout!(field, :g)\n\n    # Get grid coordinates\n    x = get_grid(field.bases[1])\n    z = get_grid(field.bases[2])\n\n    for i in eachindex(x), j in eachindex(z)\n        field.data_g[i, j] = f(x[i], z[j])\n    end\nend\n\n# Usage\ninitialize_field!(T, (x, z) -> sin(x) * cos(π*z))","category":"section"},{"location":"pages/fields/#Random-Perturbations","page":"Fields","title":"Random Perturbations","text":"using Random\n\nfunction add_perturbation!(field, amplitude; seed=42)\n    Tarang.ensure_layout!(field, :g)\n\n    Random.seed!(seed + field.dist.rank)\n    field.data_g .+= amplitude .* (rand(size(field.data_g)...) .- 0.5)\nend\n\nadd_perturbation!(T, 0.01)","category":"section"},{"location":"pages/fields/#Field-Operations","page":"Fields","title":"Field Operations","text":"","category":"section"},{"location":"pages/fields/#Copy","page":"Fields","title":"Copy","text":"# Create copy\nT2 = copy(T)\n\n# Deep copy\nT3 = deepcopy(T)","category":"section"},{"location":"pages/fields/#Arithmetic","page":"Fields","title":"Arithmetic","text":"# In-place operations (preferred)\nfield.data_g .+= other.data_g\nfield.data_g .*= 2.0\n\n# Scaling\nfield.data_g ./= maximum(abs.(field.data_g))","category":"section"},{"location":"pages/fields/#Reductions","page":"Fields","title":"Reductions","text":"# Local operations\nlocal_max = maximum(field.data_g)\nlocal_sum = sum(field.data_g)\n\n# Global MPI reductions\nreducer = GlobalArrayReducer(dist.comm)\nglobal_max = reduce_scalar(reducer, local_max, MPI.MAX)\nglobal_sum = reduce_scalar(reducer, local_sum, MPI.SUM)","category":"section"},{"location":"pages/fields/#Layout-Management","page":"Fields","title":"Layout Management","text":"","category":"section"},{"location":"pages/fields/#Transforms","page":"Fields","title":"Transforms","text":"# Transform to grid space\nTarang.ensure_layout!(field, :g)\n\n# Transform to coefficient space\nTarang.ensure_layout!(field, :c)\n\n# Check current layout\nif field.current_layout == :g\n    println(\"Field is in grid space\")\nend","category":"section"},{"location":"pages/fields/#Efficient-Transform-Usage","page":"Fields","title":"Efficient Transform Usage","text":"# Bad: Multiple unnecessary transforms\nfor i in 1:100\n    Tarang.ensure_layout!(field, :g)\n    # ... work ...\n    Tarang.ensure_layout!(field, :c)\nend\n\n# Good: Batch operations in same space\nTarang.ensure_layout!(field, :g)\nfor i in 1:100\n    # ... all grid-space work ...\nend\nTarang.ensure_layout!(field, :c)","category":"section"},{"location":"pages/fields/#VectorField-Operations","page":"Fields","title":"VectorField Operations","text":"","category":"section"},{"location":"pages/fields/#Component-Access","page":"Fields","title":"Component Access","text":"u = VectorField(dist, coords, \"u\", bases, Float64)\n\n# Individual components\nux = u.components[1]\nuy = u.components[2]\nuz = u.components[3]\n\n# Iterate\nfor (i, component) in enumerate(u.components)\n    println(\"Component $i: $(component.name)\")\nend","category":"section"},{"location":"pages/fields/#Vector-Magnitude","page":"Fields","title":"Vector Magnitude","text":"function magnitude(u)\n    Tarang.ensure_layout!(u.components[1], :g)\n\n    mag = zeros(size(u.components[1].data_g))\n    for c in u.components\n        Tarang.ensure_layout!(c, :g)\n        mag .+= c.data_g.^2\n    end\n\n    return sqrt.(mag)\nend","category":"section"},{"location":"pages/fields/#Divergence-Check","page":"Fields","title":"Divergence Check","text":"function check_divergence(u)\n    # In spectral space, compute div(u)\n    # This should be near zero for incompressible flows\n    # ... implementation ...\nend","category":"section"},{"location":"pages/fields/#Memory-Management","page":"Fields","title":"Memory Management","text":"","category":"section"},{"location":"pages/fields/#Pre-allocation","page":"Fields","title":"Pre-allocation","text":"# Create work arrays once\nwork = similar(field.data_g)\n\n# Reuse in computation\nfor step in 1:nsteps\n    work .= compute_rhs(field)\n    field.data_g .+= dt .* work\nend","category":"section"},{"location":"pages/fields/#In-place-Operations","page":"Fields","title":"In-place Operations","text":"# Avoid allocations\n# Bad:\nfield.data_g = field.data_g + other.data_g\n\n# Good:\nfield.data_g .+= other.data_g","category":"section"},{"location":"pages/fields/#Parallel-Considerations","page":"Fields","title":"Parallel Considerations","text":"","category":"section"},{"location":"pages/fields/#Local-Data","page":"Fields","title":"Local Data","text":"Each process holds only its portion of the field:\n\n# Local array size\nlocal_size = size(field.data_g)\n\n# This is smaller than global size\nglobal_size = field.bases[1].size, field.bases[2].size","category":"section"},{"location":"pages/fields/#MPI-Communication","page":"Fields","title":"MPI Communication","text":"Communication happens automatically during:\n\nLayout transforms\nGlobal reductions\nOutput operations","category":"section"},{"location":"pages/fields/#See-Also","page":"Fields","title":"See Also","text":"Domains: Where fields live\nOperators: Operations on fields\nAPI: Fields: Complete reference","category":"section"},{"location":"api/domains/#Domains-API","page":"Domains API","title":"Domains API","text":"A domain represents the spatial discretization of your problem, combining coordinate systems, spectral bases, and MPI distribution.","category":"section"},{"location":"api/domains/#Domain","page":"Domains API","title":"Domain","text":"The domain class combines multiple spectral bases and manages the spatial discretization.\n\nConstructor:\n\nDomain(\n    distributor::Distributor,\n    bases::Tuple{Vararg{Basis}}\n)\n\nArguments:\n\ndistributor: MPI distributor managing process distribution\nbases: Tuple of spectral bases, one per coordinate dimension\n\nExamples:","category":"section"},{"location":"api/domains/#1D-Domain","page":"Domains API","title":"1D Domain","text":"using Tarang, MPI\n\nMPI.Init()\n\n# Setup coordinates and distributor\ncoords = CartesianCoordinates(\"x\")\ndist = Distributor(coords, mesh=(4,))\n\n# Create basis\nx_basis = RealFourier(coords[\"x\"], size=128, bounds=(0.0, 2π))\n\n# Create domain\ndomain = Domain(dist, (x_basis,))","category":"section"},{"location":"api/domains/#2D-Domain","page":"Domains API","title":"2D Domain","text":"coords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords, mesh=(2, 2))\n\n# Periodic horizontal, bounded vertical\nx_basis = RealFourier(coords[\"x\"], size=256, bounds=(0.0, 4.0))\nz_basis = ChebyshevT(coords[\"z\"], size=64, bounds=(0.0, 1.0))\n\ndomain = Domain(dist, (x_basis, z_basis))","category":"section"},{"location":"api/domains/#3D-Domain","page":"Domains API","title":"3D Domain","text":"coords = CartesianCoordinates(\"x\", \"y\", \"z\")\ndist = Distributor(coords, mesh=(4, 4, 2))\n\n# All periodic (e.g., turbulence)\nx_basis = RealFourier(coords[\"x\"], size=256, bounds=(0.0, 2π))\ny_basis = RealFourier(coords[\"y\"], size=256, bounds=(0.0, 2π))\nz_basis = RealFourier(coords[\"z\"], size=256, bounds=(0.0, 2π))\n\ndomain = Domain(dist, (x_basis, y_basis, z_basis))\n\n","category":"section"},{"location":"api/domains/#Properties","page":"Domains API","title":"Properties","text":"","category":"section"},{"location":"api/domains/#Basic-Properties","page":"Domains API","title":"Basic Properties","text":"domain.distributor      # Distributor: MPI distribution\ndomain.bases            # Tuple: Spectral bases\ndomain.dim              # Int: Number of dimensions\ndomain.coords           # CoordinateSystem: Coordinate system","category":"section"},{"location":"api/domains/#Size-Information","page":"Domains API","title":"Size Information","text":"# Global domain size (spectral modes)\ndomain.global_size      # Tuple: (Nx, Ny, Nz)\n\n# Global grid size (grid points)\ndomain.global_grid_size # Tuple: Grid dimensions\n\n# Local size on this MPI rank\ndomain.local_size       # Tuple: Local array size\n\n# Domain bounds\ndomain.bounds           # Tuple of tuples: ((xmin,xmax), (ymin,ymax), ...)\n\n# Domain lengths\ndomain.lengths          # Tuple: (Lx, Ly, Lz)\n\n","category":"section"},{"location":"api/domains/#Methods","page":"Domains API","title":"Methods","text":"","category":"section"},{"location":"api/domains/#Grid-Access","page":"Domains API","title":"Grid Access","text":"# Get grid points for each dimension\nx_grid = get_grid(domain, 1)  # First dimension\ny_grid = get_grid(domain, 2)  # Second dimension\nz_grid = get_grid(domain, 3)  # Third dimension\n\n# Or access via basis\nx_grid = get_grid(domain.bases[1])","category":"section"},{"location":"api/domains/#Meshgrid-Creation","page":"Domains API","title":"Meshgrid Creation","text":"# Create 2D meshgrid\nX, Z = meshgrid(domain)\n\n# For 3D\nX, Y, Z = meshgrid(domain)\n\n# Example: Initialize field on grid\nfunction init_temperature!(T, domain)\n    X, Z = meshgrid(domain)\n    T_grid = get_grid_data(T)\n\n    T_grid .= @. sin(2π * X / domain.lengths[1]) * cos(π * Z / domain.lengths[2])\n\n    to_spectral!(T)\nend","category":"section"},{"location":"api/domains/#Wavenumber-Arrays","page":"Domains API","title":"Wavenumber Arrays","text":"# Get wavenumber arrays\nkx = get_wavenumbers(domain, 1)\nky = get_wavenumbers(domain, 2)\nkz = get_wavenumbers(domain, 3)\n\n# Wavenumber magnitude\nfunction get_k_magnitude(domain)\n    kx = get_wavenumbers(domain, 1)\n    ky = get_wavenumbers(domain, 2)\n    kz = get_wavenumbers(domain, 3)\n\n    # 3D meshgrid of wavenumbers\n    KX = reshape(kx, :, 1, 1)\n    KY = reshape(ky, 1, :, 1)\n    KZ = reshape(kz, 1, 1, :)\n\n    K = @. sqrt(KX^2 + KY^2 + KZ^2)\n    return K\nend\n\n","category":"section"},{"location":"api/domains/#Domain-Types-and-Examples","page":"Domains API","title":"Domain Types and Examples","text":"","category":"section"},{"location":"api/domains/#Periodic-Domains","page":"Domains API","title":"Periodic Domains","text":"All directions periodic (e.g., homogeneous turbulence):\n\ncoords = CartesianCoordinates(\"x\", \"y\", \"z\")\ndist = Distributor(coords, mesh=(4, 4, 4))\n\nbases = (\n    RealFourier(coords[\"x\"], size=128, bounds=(0.0, 2π)),\n    RealFourier(coords[\"y\"], size=128, bounds=(0.0, 2π)),\n    RealFourier(coords[\"z\"], size=128, bounds=(0.0, 2π))\n)\n\ndomain = Domain(dist, bases)\n\nUse cases: Turbulence, Taylor-Green vortex, forced isotropic flow\n\n","category":"section"},{"location":"api/domains/#Channel-Domains","page":"Domains API","title":"Channel Domains","text":"Periodic in streamwise/spanwise, bounded in wall-normal:\n\ncoords = CartesianCoordinates(\"x\", \"y\", \"z\")\ndist = Distributor(coords, mesh=(8, 4, 2))\n\nbases = (\n    RealFourier(coords[\"x\"], size=256, bounds=(0.0, 2π)),  # Streamwise\n    RealFourier(coords[\"y\"], size=128, bounds=(0.0, π)),   # Spanwise\n    ChebyshevT(coords[\"z\"], size=64, bounds=(0.0, 1.0))    # Wall-normal\n)\n\ndomain = Domain(dist, bases)\n\nUse cases: Channel flow, pipe flow, boundary layers\n\n","category":"section"},{"location":"api/domains/#Convection-Domains","page":"Domains API","title":"Convection Domains","text":"Periodic horizontal, bounded vertical:\n\ncoords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords, mesh=(4, 2))\n\nbases = (\n    RealFourier(coords[\"x\"], size=256, bounds=(0.0, 4.0)),  # Horizontal\n    ChebyshevT(coords[\"z\"], size=64, bounds=(0.0, 1.0))     # Vertical\n)\n\ndomain = Domain(dist, bases)\n\nUse cases: Rayleigh-Bénard convection, atmospheric convection\n\n","category":"section"},{"location":"api/domains/#Spherical-Domains","page":"Domains API","title":"Spherical Domains","text":"For problems in spherical geometry:\n\ncoords = SphericalCoordinates()\ndist = Distributor(coords, mesh=(2, 2, 2))\n\nbases = (\n    ChebyshevT(coords[\"r\"], size=64, bounds=(0.5, 1.0)),      # Radius\n    RealFourier(coords[\"theta\"], size=128, bounds=(0.0, π)),  # Polar\n    RealFourier(coords[\"phi\"], size=256, bounds=(0.0, 2π))    # Azimuthal\n)\n\ndomain = Domain(dist, bases)\n\nUse cases: Spherical shells, planetary cores, stellar interiors\n\n","category":"section"},{"location":"api/domains/#Multi-Domain-Problems","page":"Domains API","title":"Multi-Domain Problems","text":"Some problems require multiple domains (e.g., domain decomposition, multi-scale):\n\n# Coarse domain for large scales\ncoords_coarse = CartesianCoordinates(\"x\", \"z\")\ndist_coarse = Distributor(coords_coarse, mesh=(2, 2))\nbases_coarse = (\n    RealFourier(coords_coarse[\"x\"], size=64, bounds=(0.0, 4.0)),\n    ChebyshevT(coords_coarse[\"z\"], size=32, bounds=(0.0, 1.0))\n)\ndomain_coarse = Domain(dist_coarse, bases_coarse)\n\n# Fine domain for small scales\ndist_fine = Distributor(coords_coarse, mesh=(4, 4))\nbases_fine = (\n    RealFourier(coords_coarse[\"x\"], size=256, bounds=(0.0, 4.0)),\n    ChebyshevT(coords_coarse[\"z\"], size=128, bounds=(0.0, 1.0))\n)\ndomain_fine = Domain(dist_fine, bases_fine)\n\n","category":"section"},{"location":"api/domains/#Domain-Utilities","page":"Domains API","title":"Domain Utilities","text":"","category":"section"},{"location":"api/domains/#Volume-Element","page":"Domains API","title":"Volume Element","text":"# Get volume element (dV)\ndV = get_volume_element(domain)\n\n# Useful for integrals\nfunction integrate(field, domain)\n    to_grid!(field)\n    data = get_grid_data(field)\n    dV = get_volume_element(domain)\n    return sum(data .* dV)\nend","category":"section"},{"location":"api/domains/#Domain-Information","page":"Domains API","title":"Domain Information","text":"# Print domain information\nfunction print_domain_info(domain)\n    println(\"Domain Information:\")\n    println(\"  Dimensions: $(domain.dim)\")\n    println(\"  Global size: $(domain.global_size)\")\n    println(\"  Grid size: $(domain.global_grid_size)\")\n    println(\"  Bounds: $(domain.bounds)\")\n    println(\"  Lengths: $(domain.lengths)\")\n\n    for (i, basis) in enumerate(domain.bases)\n        println(\"  Basis $i: $(typeof(basis))\")\n        println(\"    Size: $(basis.size)\")\n        println(\"    Bounds: $(basis.bounds)\")\n    end\nend","category":"section"},{"location":"api/domains/#Domain-Validation","page":"Domains API","title":"Domain Validation","text":"# Check domain validity\nfunction validate_domain(domain)\n    # Check dimensions match\n    @assert length(domain.bases) == domain.dim\n    @assert length(domain.distributor.mesh) == domain.dim\n\n    # Check process mesh matches\n    @assert prod(domain.distributor.mesh) == MPI.Comm_size(domain.distributor.comm)\n\n    # Check bases match coordinates\n    for (i, basis) in enumerate(domain.bases)\n        @assert basis.coord.index == i\n    end\n\n    println(\"Domain validation passed!\")\nend\n\n","category":"section"},{"location":"api/domains/#Domain-Transformations","page":"Domains API","title":"Domain Transformations","text":"","category":"section"},{"location":"api/domains/#Coordinate-Transformations","page":"Domains API","title":"Coordinate Transformations","text":"For non-Cartesian geometries, coordinate transformations are handled automatically:\n\n# Spherical coordinates example\ncoords = SphericalCoordinates()\n# Metric tensor and Jacobian computed automatically\n# Operators (grad, div, curl) use correct forms","category":"section"},{"location":"api/domains/#Grid-Refinement","page":"Domains API","title":"Grid Refinement","text":"# Create refined domain (double resolution)\nfunction refine_domain(domain_coarse)\n    bases_fine = map(domain_coarse.bases) do basis\n        if typeof(basis) <: RealFourier\n            RealFourier(basis.coord,\n                       size=2*basis.size,\n                       bounds=basis.bounds,\n                       dealias=basis.dealias)\n        elseif typeof(basis) <: ChebyshevT\n            ChebyshevT(basis.coord,\n                      size=2*basis.size,\n                      bounds=basis.bounds)\n        end\n    end\n\n    return Domain(domain_coarse.distributor, bases_fine)\nend\n\n","category":"section"},{"location":"api/domains/#Advanced-Topics","page":"Domains API","title":"Advanced Topics","text":"","category":"section"},{"location":"api/domains/#Custom-Domains","page":"Domains API","title":"Custom Domains","text":"For specialized geometries:\n\n# Define custom domain with mixed basis types\ncoords = CartesianCoordinates(\"r\", \"theta\")\ndist = Distributor(coords, mesh=(2, 2))\n\nbases = (\n    ChebyshevT(coords[\"r\"], size=64, bounds=(0.0, 1.0)),  # Radial\n    RealFourier(coords[\"theta\"], size=128, bounds=(0.0, 2π))  # Angular\n)\n\ndomain = Domain(dist, bases)","category":"section"},{"location":"api/domains/#Domain-Decomposition","page":"Domains API","title":"Domain Decomposition","text":"For large problems, decompose into subdomains:\n\n# Create subdomain for specific region\nfunction create_subdomain(domain, bounds_x, bounds_z)\n    # Extract relevant portions\n    # ... implementation depends on specific needs\nend","category":"section"},{"location":"api/domains/#Adaptive-Mesh-Refinement","page":"Domains API","title":"Adaptive Mesh Refinement","text":"# Refine in specific regions (advanced)\n# Would require custom basis implementation\n# Not currently built-in\n\n","category":"section"},{"location":"api/domains/#Performance-Considerations","page":"Domains API","title":"Performance Considerations","text":"","category":"section"},{"location":"api/domains/#Memory-Usage","page":"Domains API","title":"Memory Usage","text":"# Estimate memory usage\nfunction estimate_memory(domain)\n    bytes_per_point = 16  # Complex128\n    points = prod(domain.global_grid_size)\n    total_gb = bytes_per_point * points / 1e9\n\n    per_rank_gb = total_gb / MPI.Comm_size(domain.distributor.comm)\n\n    println(\"Total memory: $(total_gb) GB\")\n    println(\"Per rank: $(per_rank_gb) GB\")\nend","category":"section"},{"location":"api/domains/#Optimal-Domain-Decomposition","page":"Domains API","title":"Optimal Domain Decomposition","text":"# Choose mesh based on domain aspect ratio\nfunction optimal_mesh(Nx, Ny, Nz, total_procs)\n    # Aim for cubic subdomains\n    ratio = (Nx, Ny, Nz) ./ sum([Nx, Ny, Nz])\n\n    # Distribute processes proportionally\n    # ... heuristic for choosing mesh\n\n    return (Px, Py, Pz)\nend\n\n","category":"section"},{"location":"api/domains/#See-Also","page":"Domains API","title":"See Also","text":"Coordinates: Coordinate system setup\nBases: Spectral basis selection\nFields: Creating fields on domains\nOperators: Differential operators\nParallelism Guide: MPI configuration","category":"section"},{"location":"pages/contributing/#Contributing","page":"Contributing","title":"Contributing","text":"Fork, clone, and submit PRs to main. Run tests with julia --project=. -e 'using Pkg; Pkg.test()'.\n\nStyle: 4-space indent, 92-char lines, snake_case functions, CamelCase types.\n\nHelp: Issues | Discussions","category":"section"},{"location":"tutorials/rotating_shallow_water/#Rotating-Shallow-Water-with-Lagrangian-Averaging","page":"Rotating Shallow Water with Lagrangian Averaging","title":"Rotating Shallow Water with Lagrangian Averaging","text":"This tutorial demonstrates how to use temporal filters to separate fast inertia-gravity waves from slow geostrophic flow in a rotating shallow water model.\n\n","category":"section"},{"location":"tutorials/rotating_shallow_water/#Physical-Problem","page":"Rotating Shallow Water with Lagrangian Averaging","title":"Physical Problem","text":"The rotating shallow water equations on an f-plane:\n\n\nfracpartial upartial t - fv = -gfracpartial etapartial x\n\n\n\nfracpartial vpartial t + fu = -gfracpartial etapartial y\n\n\n\nfracpartial etapartial t + Hleft(fracpartial upartial x + fracpartial vpartial yright) = 0\n\n\nwhere\n- u v = velocity components\n- eta = surface elevation\n- f = Coriolis parameter\n- g = gravity\n- H = mean depth\n\nThis system supports two types of motion\n1 **Slow geostrophic flow** - balanced flow satisfying fv = gpartialetapartial x\n2 **Fast inertia-gravity waves** - oscillations with frequency omega^2 = f^2 + c^2(k_x^2 + k_y^2)\n\nThe challenge **How do we separate these efficiently**\n\n---\n\n Solution Temporal Filtering\n\nInstead of explicit trajectory tracking we use **exponential temporal filters** that run alongside the simulation The Butterworth filter provides sharp frequency separation with only two auxiliary arrays per filtered field\n\n Wave-Mean Decomposition\n\nAfter filtering\n\nu = ū + u     (mean + wave fluctuation)\n\n\nThe mean baru captures the slow geostrophic motion while u contains the fast wave oscillations\n\n---\n\n Complete Example Code\n\njulia\nusing Tarang\nusing Statistics mean\n\n =============================================================================\n ROTATING SHALLOW WATER MODEL WITH LAGRANGIAN MEAN COMPUTATION\n =============================================================================\n\n -----------------------------------------------------------------------------\n 1 Physical Parameters\n -----------------------------------------------------------------------------\n\n Domain\nLx Ly = 2π 2π         Domain size\nNx Ny = 128 128       Resolution\n\n Physical constants\nf = 10                 Coriolis parameter\ng = 100                Gravity\nH = 10                 Mean depth\nν = 0001               Viscosity (for numerical stability)\n\n Derived quantities\nc = sqrt(g * H)         Gravity wave phase speed\nω_min = f               Minimum wave frequency (inertial)\nT_inertial = 2π  f     Inertial period\n\nprintln(Physical parameters)\nprintln(  Gravity wave speed c =  c)\nprintln(  Inertial period T =  round(T_inertial digits=3))\n\n -----------------------------------------------------------------------------\n 2 Grid and Operators\n -----------------------------------------------------------------------------\n\ndx dy = LxNx LyNy\nx = (i-1)*dx for i in 1Nx\ny = (j-1)*dy for j in 1Ny\n\n Spectral wavenumbers\nkx = i = Nx2+1  i-1  i-Nx-1 for i in 1Nx * (2πLx)\nky = j = Ny2+1  j-1  j-Ny-1 for j in 1Ny * (2πLy)\n\n Preallocate FFT arrays\nusing FFTW\nFFTWset_num_threads(4)\nplan_fft = plan_fft(zeros(ComplexF64 Nx Ny))\nplan_ifft = plan_ifft(zeros(ComplexF64 Nx Ny))\n\n Derivative operators in spectral space\nfunction spectral_gradient(dfdx dfdy f_hat kx ky)\n    inbounds for j in 1size(f_hat 2) i in 1size(f_hat 1)\n        dfdxij = im * kxi * f_hatij\n        dfdyij = im * kyj * f_hatij\n    end\nend\n\n -----------------------------------------------------------------------------\n 3 Initialize Fields\n -----------------------------------------------------------------------------\n\n Velocity and elevation\nu = zeros(Nx Ny)\nv = zeros(Nx Ny)\nη = zeros(Nx Ny)\n\n Work arrays\nu_hat = zeros(ComplexF64 Nx Ny)\nv_hat = zeros(ComplexF64 Nx Ny)\nη_hat = zeros(ComplexF64 Nx Ny)\n\n Temporary arrays for derivatives\ndudx = zeros(ComplexF64 Nx Ny)\ndudy = zeros(ComplexF64 Nx Ny)\ndvdx = zeros(ComplexF64 Nx Ny)\ndvdy = zeros(ComplexF64 Nx Ny)\ndηdx = zeros(ComplexF64 Nx Ny)\ndηdy = zeros(ComplexF64 Nx Ny)\n\n Initial condition Geostrophic jet + wave perturbation\nfor i in 1Nx j in 1Ny\n     Background geostrophic jet\n    uij = 05 * sin(yj)\n    vij = 00\n    ηij = -(fg) * 05 * cos(yj)   Geostrophic balance\n\n     Add wave perturbation (k=2 l=2 mode)\n    k_wave l_wave = 20 20\n    ω_wave = sqrt(f^2 + c^2 * (k_wave^2 + l_wave^2))\n    amplitude = 01\n    ηij += amplitude * cos(k_wave * xi + l_wave * yj)\nend\n\nprintln(nInitial condition)\nprintln(  Geostrophic jet U = 05 sin(y))\nprintln(  Wave perturbation amplitude = 01)\n\n -----------------------------------------------------------------------------\n 4 Setup Temporal Filters\n -----------------------------------------------------------------------------\n\n Filter timescale average over 20 wave periods\nT_wave = 2π  sqrt(f^2 + c^2 * 4)   Wave period for k=l=2\nα = 10  (20 * T_wave)             Filter parameter\n\nprintln(nFilter setup)\nprintln(  Wave period T_wave =  round(T_wave digits=3))\nprintln(  Filter timescale 1α =  round(1α digits=1))\n\n Create filters for each prognostic variable\nu_filter = ButterworthFilter((Nx Ny) α=α)\nv_filter = ButterworthFilter((Nx Ny) α=α)\nη_filter = ButterworthFilter((Nx Ny) α=α)\n\n Precompute ETD coefficients for unconditional stability\ndt = 001   Time step\netd_coeffs_u = precompute_etd_coefficients(u_filter dt)\netd_coeffs_v = precompute_etd_coefficients(v_filter dt)\netd_coeffs_η = precompute_etd_coefficients(η_filter dt)\n\nprintln(  Using ETD integration (unconditionally stable))\nprintln(  αdt =  round(α * dt digits=4))\n\n -----------------------------------------------------------------------------\n 5 Time Integration (RK4 for dynamics ETD for filters)\n -----------------------------------------------------------------------------\n\nfunction rhs(du dv dη u v η u_hat v_hat η_hat\n              dudx dudy dvdx dvdy dηdx dηdy\n              plan_fft plan_ifft kx ky f g H ν)\n\n     Transform to spectral space\n    u_hat = u\n    v_hat = v\n    η_hat = η\n    plan_fft * u_hat\n    plan_fft * v_hat\n    plan_fft * η_hat\n\n     Compute gradients\n    spectral_gradient(dudx dudy u_hat kx ky)\n    spectral_gradient(dvdx dvdy v_hat kx ky)\n    spectral_gradient(dηdx dηdy η_hat kx ky)\n\n     Transform derivatives back\n    plan_ifft * dudx\n    plan_ifft * dudy\n    plan_ifft * dvdx\n    plan_ifft * dvdy\n    plan_ifft * dηdx\n    plan_ifft * dηdy\n\n     RHS of shallow water equations\n    inbounds for j in 1size(u 2) i in 1size(u 1)\n         Nonlinear advection\n        adv_u = uij * real(dudxij) + vij * real(dudyij)\n        adv_v = uij * real(dvdxij) + vij * real(dvdyij)\n\n         Momentum equations\n        duij = f * vij - g * real(dηdxij) - adv_u\n        dvij = -f * uij - g * real(dηdyij) - adv_v\n\n         Continuity equation\n        dηij = -H * (real(dudxij) + real(dvdyij))\n    end\n\n     Add viscous damping in spectral space for stability\n    if ν  0\n        u_hat = u\n        v_hat = v\n        plan_fft * u_hat\n        plan_fft * v_hat\n        inbounds for j in 1size(u_hat 2) i in 1size(u_hat 1)\n            k2 = kxi^2 + kyj^2\n            visc = -ν * k2\n            u_hatij *= visc\n            v_hatij *= visc\n        end\n        plan_ifft * u_hat\n        plan_ifft * v_hat\n        du += real(u_hat)\n        dv += real(v_hat)\n    end\nend\n\n RK4 time stepper for dynamics\nfunction step_rk4(u v η dt args)\n     Allocate RK stages\n    k1_u k1_v k1_η = similar(u) similar(v) similar(η)\n    k2_u k2_v k2_η = similar(u) similar(v) similar(η)\n    k3_u k3_v k3_η = similar(u) similar(v) similar(η)\n    k4_u k4_v k4_η = similar(u) similar(v) similar(η)\n    u_tmp v_tmp η_tmp = similar(u) similar(v) similar(η)\n\n     k1\n    rhs(k1_u k1_v k1_η u v η args)\n\n     k2\n     u_tmp = u + 05 * dt * k1_u\n     v_tmp = v + 05 * dt * k1_v\n     η_tmp = η + 05 * dt * k1_η\n    rhs(k2_u k2_v k2_η u_tmp v_tmp η_tmp args)\n\n     k3\n     u_tmp = u + 05 * dt * k2_u\n     v_tmp = v + 05 * dt * k2_v\n     η_tmp = η + 05 * dt * k2_η\n    rhs(k3_u k3_v k3_η u_tmp v_tmp η_tmp args)\n\n     k4\n     u_tmp = u + dt * k3_u\n     v_tmp = v + dt * k3_v\n     η_tmp = η + dt * k3_η\n    rhs(k4_u k4_v k4_η u_tmp v_tmp η_tmp args)\n\n     Update\n     u += dt6 * (k1_u + 2*k2_u + 2*k3_u + k4_u)\n     v += dt6 * (k1_v + 2*k2_v + 2*k3_v + k4_v)\n     η += dt6 * (k1_η + 2*k2_η + 2*k3_η + k4_η)\nend\n\n -----------------------------------------------------------------------------\n 6 Main Time Loop\n -----------------------------------------------------------------------------\n\nT_final = 1000         Total simulation time\nnsteps = Int(T_final  dt)\noutput_interval = Int(10  dt)   Output every 1 time unit\n\n Diagnostics storage\ntimes = Float64\nKE_total = Float64\nKE_mean = Float64\nKE_wave = Float64\nPE_total = Float64\n\nprintln(n * =^60)\nprintln(Starting simulation)\nprintln(=^60)\n\nfor step in 1nsteps\n    t = step * dt\n\n     Step dynamics (RK4)\n    step_rk4(u v η dt\n              u_hat v_hat η_hat\n              dudx dudy dvdx dvdy dηdx dηdy\n              plan_fft plan_ifft kx ky f g H ν)\n\n     Update filters (ETD - unconditionally stable)\n    update_etd(u_filter u etd_coeffs_u)\n    update_etd(v_filter v etd_coeffs_v)\n    update_etd(η_filter η etd_coeffs_η)\n\n     Output diagnostics\n    if step  output_interval == 0\n         Get filtered means\n        ū = get_mean(u_filter)\n        v̄ = get_mean(v_filter)\n        η̄ = get_mean(η_filter)\n\n         Wave components\n        u_wave = u - ū\n        v_wave = v - v̄\n        η_wave = η - η̄\n\n         Energy diagnostics\n        ke_total = 05 * mean(u^2 + v^2)\n        ke_mean = 05 * mean(ū^2 + v̄^2)\n        ke_wave = 05 * mean(u_wave^2 + v_wave^2)\n        pe_total = 05 * gH * mean(η^2)\n\n        push(times t)\n        push(KE_total ke_total)\n        push(KE_mean ke_mean)\n        push(KE_wave ke_wave)\n        push(PE_total pe_total)\n\n        printf(t = 62f  KE_total = 4e  KE_mean = 4e  KE_wave = 4en\n                t ke_total ke_mean ke_wave)\n    end\nend\n\n -----------------------------------------------------------------------------\n 7 Final Analysis\n -----------------------------------------------------------------------------\n\nprintln(n * =^60)\nprintln(Simulation complete)\nprintln(=^60)\n\n Final wave-mean decomposition\nū = get_mean(u_filter)\nv̄ = get_mean(v_filter)\nη̄ = get_mean(η_filter)\n\nu_wave = u - ū\nv_wave = v - v̄\nη_wave = η - η̄\n\nprintln(nFinal state statistics)\nprintln(  Mean flow)\nprintln(    maxū =  round(maximum(abs(ū)) digits=4))\nprintln(    maxv̄ =  round(maximum(abs(v̄)) digits=4))\nprintln(    maxη̄ =  round(maximum(abs(η̄)) digits=4))\n\nprintln(  Wave fluctuations)\nprintln(    maxu =  round(maximum(abs(u_wave)) digits=4))\nprintln(    maxv =  round(maximum(abs(v_wave)) digits=4))\nprintln(    maxη =  round(maximum(abs(η_wave)) digits=4))\n\nprintln(nEnergy partition)\nke_final_total = 05 * mean(u^2 + v^2)\nke_final_mean = 05 * mean(ū^2 + v̄^2)\nke_final_wave = 05 * mean(u_wave^2 + v_wave^2)\nprintln(  Total KE      round(ke_final_total digits=6))\nprintln(  Mean flow KE  round(ke_final_mean digits=6)\n         ( round(100*ke_final_meanke_final_total digits=1) ))\nprintln(  Wave KE       round(ke_final_wave digits=6)\n         ( round(100*ke_final_waveke_final_total digits=1) ))\n\n\n---\n\n Understanding the Output\n\n Energy Partition\n\nThe simulation separates kinetic energy into\n- **Mean flow KE** Energy in slow filtered geostrophic motion\n- **Wave KE** Energy in fast inertia-gravity oscillations\n\nTypical output after spinup\n\nEnergy partition\n  Total KE     0062500\n  Mean flow KE 0050000 (800)\n  Wave KE      0012500 (200)\n\n\n Wave-Mean Decomposition\n\nThe filtered mean baru should recover the initial geostrophic jet\njulia\n Expected ū  05 sin(y) (the background jet)\n Expected v̄  0 (no mean meridional flow)\n\n\n---\n\n Time Integration Methods\n\n Method 1 Explicit Euler (not recommended)\n\njulia\nupdate(filter field dt)   Forward Euler\n\n**Stability limit** Delta t leq sqrt2alpha\n\n Method 2 RK2 (moderate stability)\n\njulia\nupdate(filter field dt Val(RK2))\n\n**Stability limit** Delta t leq 2sqrt2alpha\n\n Method 3 ETD (recommended - unconditionally stable)\n\njulia\ncoeffs = precompute_etd_coefficients(filter dt)\nupdate_etd(filter field coeffs)\n\n**No stability limit** Can use any timestep\n\n Method 4 IMEXSBDF (for implicit PDE solvers)\n\njulia\ncoeffs = precompute_imex_coefficients(filter dt scheme=SBDF2)\nupdate_imex(filter (h_n h_nm1) coeffs)\n\n**No stability limit** Integrates naturally with SBDF timestepping\n\n---\n\n Choosing Filter Parameters\n\n The key parameter α\n\nalpha = frac1T_textavg\n\nRule of thumb: T_textavg approx 10-100 times T_textwave\n\nWaves to filter Wave period Recommended α\nInertia-gravity waves 2pisqrtf^2 + c^2 k^2 alpha = 005-01 times wave frequency\nNear-inertial waves 2pif alpha approx f50\nInternal gravity waves 2piN alpha approx N100","category":"section"},{"location":"tutorials/rotating_shallow_water/#Filter-comparison","page":"Rotating Shallow Water with Lagrangian Averaging","title":"Filter comparison","text":"Filter High-freq rolloff Memory Use case\nExponentialMean -20 dB/decade 1 array Simple averaging\nButterworthFilter -40 dB/decade 2 arrays Sharp wave-mean separation\n\n","category":"section"},{"location":"tutorials/rotating_shallow_water/#Extensions","page":"Rotating Shallow Water with Lagrangian Averaging","title":"Extensions","text":"","category":"section"},{"location":"tutorials/rotating_shallow_water/#Adding-Lagrangian-Averaging","page":"Rotating Shallow Water with Lagrangian Averaging","title":"Adding Lagrangian Averaging","text":"For true Lagrangian mean (following particle motion):\n\n# Create Lagrangian filter\nlag_filter = LagrangianFilter((Nx, Ny);\n    α=α,\n    filter_type=:butterworth\n)\n\n# In time loop:\nupdate_displacement!(lag_filter, (u, v), dt)\n\n# Get Lagrangian mean velocity\nū_L = get_mean_velocity(lag_filter)\n\n# Compute Lagrangian mean of a tracer\nθ_L = zeros(Nx, Ny)\nlagrangian_mean!(lag_filter, θ_L, tracer, dt)","category":"section"},{"location":"tutorials/rotating_shallow_water/#Computing-Stokes-Drift","page":"Rotating Shallow Water with Lagrangian Averaging","title":"Computing Stokes Drift","text":"The Stokes drift is the difference between Lagrangian and Eulerian means:\n\nu_stokes = ū_L - ū_E  # Lagrangian mean - Eulerian mean\n\nThis captures wave-induced transport important for:\n\nPollutant dispersion\nLarval transport in oceans\nSea ice drift\n\n","category":"section"},{"location":"tutorials/rotating_shallow_water/#References","page":"Rotating Shallow Water with Lagrangian Averaging","title":"References","text":"Minz, C., Baker, L. E., Kafiabad, H. A., & Vanneste, J. (2025). Efficient Lagrangian averaging with exponential filters. Phys. Rev. Fluids, 10, 074902. DOI\nVallis, G. K. (2017). Atmospheric and Oceanic Fluid Dynamics (2nd ed.). Cambridge University Press. Chapter 3: Shallow water systems.\nBühler, O. (2014). Waves and Mean Flows (2nd ed.). Cambridge University Press.\n\n","category":"section"},{"location":"tutorials/rotating_shallow_water/#Next-Steps","page":"Rotating Shallow Water with Lagrangian Averaging","title":"Next Steps","text":"Temporal Filters Reference - Complete API documentation\nLES Models - Subgrid-scale modeling for turbulence\nSurface Dynamics - SQG and other surface-confined flows\n\n\n\nTutorial version 1.0 | December 2024 | Tarang.jl","category":"section"},{"location":"notebooks/rayleigh_benard/#Notebook:-Rayleigh-Bénard-Convection","page":"Notebook: Rayleigh-Bénard Convection","title":"Notebook: Rayleigh-Bénard Convection","text":"This notebook demonstrates 2D Rayleigh-Bénard convection simulation.","category":"section"},{"location":"notebooks/rayleigh_benard/#Setup","page":"Notebook: Rayleigh-Bénard Convection","title":"Setup","text":"using Tarang\nusing MPI\nusing Plots\n\nMPI.Init()","category":"section"},{"location":"notebooks/rayleigh_benard/#Problem-Definition","page":"Notebook: Rayleigh-Bénard Convection","title":"Problem Definition","text":"Rayleigh-Bénard convection simulates fluid heated from below in a gravity field.","category":"section"},{"location":"notebooks/rayleigh_benard/#Parameters","page":"Notebook: Rayleigh-Bénard Convection","title":"Parameters","text":"Ra = 1e6    # Rayleigh number\nPr = 1.0    # Prandtl number\nLx = 4.0    # Domain width\nLz = 1.0    # Domain height","category":"section"},{"location":"notebooks/rayleigh_benard/#Domain","page":"Notebook: Rayleigh-Bénard Convection","title":"Domain","text":"coords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords; mesh=(1,), dtype=Float64)\n\nNx, Nz = 256, 64\nx_basis = RealFourier(coords[\"x\"]; size=Nx, bounds=(0.0, Lx), dealias=1.5)\nz_basis = ChebyshevT(coords[\"z\"]; size=Nz, bounds=(0.0, Lz))\n\ndomain = Domain(dist, (x_basis, z_basis))","category":"section"},{"location":"notebooks/rayleigh_benard/#Fields","page":"Notebook: Rayleigh-Bénard Convection","title":"Fields","text":"ux = ScalarField(dist, \"ux\", (x_basis, z_basis), Float64)\nuz = ScalarField(dist, \"uz\", (x_basis, z_basis), Float64)\np = ScalarField(dist, \"p\", (x_basis, z_basis), Float64)\nT = ScalarField(dist, \"T\", (x_basis, z_basis), Float64)","category":"section"},{"location":"notebooks/rayleigh_benard/#Equations","page":"Notebook: Rayleigh-Bénard Convection","title":"Equations","text":"problem = IVP([ux, uz, p, T])\nproblem.parameters[\"Ra\"] = Ra\nproblem.parameters[\"Pr\"] = Pr\n\nTarang.add_equation!(problem,\n    \"∂t(ux) + ux*∂x(ux) + uz*∂z(ux) + ∂x(p) = Pr*Δ(ux)\")\nTarang.add_equation!(problem,\n    \"∂t(uz) + ux*∂x(uz) + uz*∂z(uz) + ∂z(p) = Pr*Δ(uz) + Ra*Pr*T\")\nTarang.add_equation!(problem, \"∂x(ux) + ∂z(uz) = 0\")\nTarang.add_equation!(problem,\n    \"∂t(T) + ux*∂x(T) + uz*∂z(T) = Δ(T)\")","category":"section"},{"location":"notebooks/rayleigh_benard/#Boundary-Conditions","page":"Notebook: Rayleigh-Bénard Convection","title":"Boundary Conditions","text":"# No-slip walls\nTarang.add_equation!(problem, \"ux(z=0) = 0\")\nTarang.add_equation!(problem, \"ux(z=1) = 0\")\nTarang.add_equation!(problem, \"uz(z=0) = 0\")\nTarang.add_equation!(problem, \"uz(z=1) = 0\")\n\n# Fixed temperatures\nTarang.add_equation!(problem, \"T(z=0) = 1\")  # Hot\nTarang.add_equation!(problem, \"T(z=1) = 0\")  # Cold","category":"section"},{"location":"notebooks/rayleigh_benard/#Initial-Conditions","page":"Notebook: Rayleigh-Bénard Convection","title":"Initial Conditions","text":"# Random perturbations to trigger instability\nTarang.ensure_layout!(T, :g)\nT.data_g .= 0.5 .+ 0.01 .* randn(size(T.data_g))\nTarang.ensure_layout!(T, :c)","category":"section"},{"location":"notebooks/rayleigh_benard/#Solver","page":"Notebook: Rayleigh-Bénard Convection","title":"Solver","text":"solver = InitialValueSolver(problem, RK222(); dt=1e-4)\n\n# CFL condition\ncfl = CFL(problem; safety=0.5)\nadd_velocity!(cfl, ux)\nadd_velocity!(cfl, uz)","category":"section"},{"location":"notebooks/rayleigh_benard/#Simulation","page":"Notebook: Rayleigh-Bénard Convection","title":"Simulation","text":"t_end = 1.0\ndt_output = 0.1\n\ntimes = Float64[]\nenergies = Float64[]\n\nwhile solver.sim_time < t_end\n    dt = compute_timestep(cfl)\n    step!(solver, dt)\n\n    push!(times, solver.sim_time)\n    push!(energies, compute_kinetic_energy([ux, uz]))\n\n    if solver.iteration % 100 == 0\n        println(\"t = $(solver.sim_time)\")\n    end\nend","category":"section"},{"location":"notebooks/rayleigh_benard/#Visualization","page":"Notebook: Rayleigh-Bénard Convection","title":"Visualization","text":"# Temperature field\nTarang.ensure_layout!(T, :g)\nheatmap(T.data_g',\n    xlabel=\"x\", ylabel=\"z\",\n    title=\"Temperature at t=$(solver.sim_time)\",\n    colorbar=true\n)","category":"section"},{"location":"notebooks/rayleigh_benard/#Analysis","page":"Notebook: Rayleigh-Bénard Convection","title":"Analysis","text":"# Kinetic energy evolution\nplot(times, energies,\n    xlabel=\"Time\",\n    ylabel=\"Kinetic Energy\",\n    title=\"Energy Evolution\"\n)","category":"section"},{"location":"notebooks/rayleigh_benard/#Cleanup","page":"Notebook: Rayleigh-Bénard Convection","title":"Cleanup","text":"MPI.Finalize()","category":"section"},{"location":"notebooks/rayleigh_benard/#Exercises","page":"Notebook: Rayleigh-Bénard Convection","title":"Exercises","text":"Vary Rayleigh number: Try Ra = 10^4, 10^5, 10^7\nChange aspect ratio: Lx = 2, 8, 16\nCompute Nusselt number: Track heat transfer efficiency\nResolution study: How do results change with Nx, Nz?","category":"section"},{"location":"notebooks/rayleigh_benard/#References","page":"Notebook: Rayleigh-Bénard Convection","title":"References","text":"Chandrasekhar, S. (1961). Hydrodynamic and Hydromagnetic Stability\nSpectral methods tutorials","category":"section"},{"location":"examples/","page":"-","title":"-","text":"GPU FFT Heuristics","category":"section"},{"location":"pages/configuration/#Configuration","page":"Configuration","title":"Configuration","text":"Tarang.jl provides multiple ways to configure its behavior, from environment variables to configuration files. This guide covers all configuration options.","category":"section"},{"location":"pages/configuration/#Configuration-Files","page":"Configuration","title":"Configuration Files","text":"","category":"section"},{"location":"pages/configuration/#Location","page":"Configuration","title":"Location","text":"Tarang.jl searches for configuration files in this order:\n\nCurrent working directory: ./tarang.toml\nUser configuration: ~/.tarang/config.toml\nPackage default: Built-in defaults\n\nThe first file found takes precedence.","category":"section"},{"location":"pages/configuration/#File-Format","page":"Configuration","title":"File Format","text":"Configuration uses TOML format:\n\n# tarang.toml\n\n[parallelism]\nTRANSPOSE_LIBRARY = \"PENCIL\"\nGROUP_TRANSPOSES = true\nSYNC_TRANSPOSES = true\n\n[transforms]\nGROUP_TRANSFORMS = true\nDEALIAS_BEFORE_CONVERTING = true\n\n[transforms-fftw]\nPLANNING_RIGOR = \"FFTW_MEASURE\"\nUSE_FFTW_WISDOM = true\nWISDOM_FILE = \"fftw_wisdom.dat\"\n\n[logging]\nLEVEL = \"INFO\"\nFILE = \"tarang.log\"\nMPI_AWARE = true\n\n[performance]\nPROFILE_DIR = \"profiles\"\nENABLE_PROFILING = false\nMEMORY_POOL_SIZE = \"1GB\"\n\n[output]\nDEFAULT_FORMAT = \"netcdf\"\nCOMPRESSION_LEVEL = 4\nCHUNK_SIZE = \"auto\"","category":"section"},{"location":"pages/configuration/#Configuration-Sections","page":"Configuration","title":"Configuration Sections","text":"","category":"section"},{"location":"pages/configuration/#Parallelism","page":"Configuration","title":"Parallelism","text":"Controls MPI and parallel execution:\n\n[parallelism]\n# Transpose library: \"PENCIL\" or \"CUSTOM\"\nTRANSPOSE_LIBRARY = \"PENCIL\"\n\n# Group multiple transposes together\nGROUP_TRANSPOSES = true\n\n# Synchronize after transposes (for debugging)\nSYNC_TRANSPOSES = false\n\n# Process mesh optimization\nAUTO_OPTIMIZE_MESH = true\nPREFERRED_PENCIL_AXIS = \"auto\"  # \"auto\", \"x\", \"y\", \"z\"\n\nOptions:\n\nTRANSPOSE_LIBRARY: Backend for array transposes\n\"PENCIL\": Use PencilArrays (recommended)\n\"CUSTOM\": Custom implementation\nGROUP_TRANSPOSES: Batch transposes for efficiency\nSYNC_TRANSPOSES: Add MPI barriers (reduces performance, useful for debugging)","category":"section"},{"location":"pages/configuration/#Transforms","page":"Configuration","title":"Transforms","text":"FFT and spectral transform settings:\n\n[transforms]\n# Group multiple transforms\nGROUP_TRANSFORMS = true\n\n# Dealias before converting between spaces\nDEALIAS_BEFORE_CONVERTING = true\n\n# Transform cache size (number of temporary arrays)\nCACHE_SIZE = 10\n\n# Forward transform in-place when possible\nINPLACE_FORWARD = true\n\n# Backward transform in-place when possible\nINPLACE_BACKWARD = true","category":"section"},{"location":"pages/configuration/#FFTW-Settings","page":"Configuration","title":"FFTW Settings","text":"FFTW-specific configuration:\n\n[transforms-fftw]\n# Planning rigor: determines FFTW plan optimization level\nPLANNING_RIGOR = \"FFTW_MEASURE\"\n\n# Save and load FFTW wisdom\nUSE_FFTW_WISDOM = true\nWISDOM_FILE = \"fftw_wisdom.dat\"\n\n# Number of threads for FFTW (usually leave at 1 with MPI)\nNUM_THREADS = 1\n\n# FFTW flags\nFLAGS = [\"FFTW_MEASURE\", \"FFTW_DESTROY_INPUT\"]\n\nPLANNING_RIGOR options:\n\n\"FFTW_ESTIMATE\": Fast planning, slower execution (good for testing)\n\"FFTW_MEASURE\": Medium planning time, good performance (recommended)\n\"FFTW_PATIENT\": Slow planning, best performance (for production runs)\n\"FFTW_EXHAUSTIVE\": Very slow planning, marginally better than PATIENT\n\ntip: FFTW Wisdom\nSave FFTW wisdom on first run, then reuse it to skip planning:using FFTW\n# After first run with FFTW_MEASURE\nFFTW.export_wisdom(\"fftw_wisdom.dat\")\n\n# Subsequent runs\nFFTW.import_wisdom(\"fftw_wisdom.dat\")","category":"section"},{"location":"pages/configuration/#Logging","page":"Configuration","title":"Logging","text":"Configure logging output:\n\n[logging]\n# Log level: \"TRACE\", \"DEBUG\", \"INFO\", \"NOTICE\", \"WARN\", \"ERROR\"\nLEVEL = \"INFO\"\n\n# Log file (empty string for stdout only)\nFILE = \"tarang.log\"\n\n# Include MPI rank in log messages\nMPI_AWARE = true\n\n# Log to stdout as well as file\nALSO_STDOUT = false\n\n# Timestamp format\nTIMESTAMP_FORMAT = \"yyyy-mm-dd HH:MM:SS\"\n\nProgrammatic logging setup:\n\nusing Tarang.Logging\n\nsetup_tarang_logging(\n    level=\"INFO\",\n    filename=\"simulation.log\",\n    mpi_aware=true,\n    console=true,\n    format_timestamp=true\n)","category":"section"},{"location":"pages/configuration/#Performance","page":"Configuration","title":"Performance","text":"Performance tuning and profiling:\n\n[performance]\n# Enable performance profiling\nENABLE_PROFILING = false\n\n# Directory for profile output\nPROFILE_DIR = \"profiles\"\n\n# Memory pool size for reusable arrays\nMEMORY_POOL_SIZE = \"1GB\"\n\n# Pre-allocate work arrays\nPREALLOCATE_WORK = true\n\n# Number of work arrays per field\nWORK_ARRAY_COUNT = 5","category":"section"},{"location":"pages/configuration/#Output","page":"Configuration","title":"Output","text":"Default output settings:\n\n[output]\n# Default output format: \"netcdf\", \"hdf5\", \"jld2\"\nDEFAULT_FORMAT = \"netcdf\"\n\n# Compression level (0-9, 0=none, 9=maximum)\nCOMPRESSION_LEVEL = 4\n\n# Chunk size: \"auto\" or explicit dimensions\nCHUNK_SIZE = \"auto\"\n\n# Output precision: \"single\", \"double\"\nPRECISION = \"double\"\n\n# Include metadata\nINCLUDE_METADATA = true","category":"section"},{"location":"pages/configuration/#Environment-Variables","page":"Configuration","title":"Environment Variables","text":"Environment variables override configuration file settings:","category":"section"},{"location":"pages/configuration/#Core-Settings","page":"Configuration","title":"Core Settings","text":"# Log level\nexport TARANG_LOG_LEVEL=DEBUG\n\n# Log file\nexport TARANG_LOG_FILE=my_simulation.log\n\n# Profile directory\nexport TARANG_PROFILE_DIR=my_profiles\n\n# Configuration file location\nexport TARANG_CONFIG=/path/to/tarang.toml","category":"section"},{"location":"pages/configuration/#FFTW-Settings-2","page":"Configuration","title":"FFTW Settings","text":"# FFTW planning rigor\nexport FFTW_PLANNING_RIGOR=FFTW_MEASURE\n\n# FFTW wisdom file\nexport FFTW_WISDOM_FILE=fftw_wisdom.dat\n\n# FFTW threads (use 1 with MPI)\nexport OMP_NUM_THREADS=1","category":"section"},{"location":"pages/configuration/#MPI-Settings","page":"Configuration","title":"MPI Settings","text":"# OpenMPI settings\nexport OMPI_MCA_mpi_show_mca_params=1\nexport OMPI_MCA_btl=^openib  # Disable InfiniBand\n\n# Process binding\nexport OMPI_MCA_hwloc_base_binding_policy=core","category":"section"},{"location":"pages/configuration/#Julia-Settings","page":"Configuration","title":"Julia Settings","text":"# Julia threads\nexport JULIA_NUM_THREADS=4\n\n# Optimization level\nexport JULIA_OPT_LEVEL=3\n\n# Disable precompilation\nexport JULIA_PKG_PRECOMPILE_AUTO=0","category":"section"},{"location":"pages/configuration/#Runtime-Configuration","page":"Configuration","title":"Runtime Configuration","text":"Some settings can be changed at runtime:\n\nusing Tarang.Config\n\n# Get current configuration\nconfig = get_config()\n\n# Modify settings\nconfig.logging.level = \"DEBUG\"\nconfig.transforms.group_transforms = false\n\n# Apply changes\napply_config!(config)","category":"section"},{"location":"pages/configuration/#Example-Configurations","page":"Configuration","title":"Example Configurations","text":"","category":"section"},{"location":"pages/configuration/#Development-(Fast-Startup)","page":"Configuration","title":"Development (Fast Startup)","text":"[transforms-fftw]\nPLANNING_RIGOR = \"FFTW_ESTIMATE\"  # Fast planning\n\n[logging]\nLEVEL = \"DEBUG\"\nFILE = \"debug.log\"\n\n[performance]\nENABLE_PROFILING = true","category":"section"},{"location":"pages/configuration/#Production-(Maximum-Performance)","page":"Configuration","title":"Production (Maximum Performance)","text":"[transforms-fftw]\nPLANNING_RIGOR = \"FFTW_PATIENT\"\nUSE_FFTW_WISDOM = true\n\n[transforms]\nGROUP_TRANSFORMS = true\nDEALIAS_BEFORE_CONVERTING = true\n\n[logging]\nLEVEL = \"INFO\"\n\n[performance]\nMEMORY_POOL_SIZE = \"2GB\"\nPREALLOCATE_WORK = true","category":"section"},{"location":"pages/configuration/#Debugging-(Verbose-Output)","page":"Configuration","title":"Debugging (Verbose Output)","text":"[parallelism]\nSYNC_TRANSPOSES = true  # Add barriers for debugging\n\n[logging]\nLEVEL = \"DEBUG\"\nMPI_AWARE = true\nALSO_STDOUT = true\n\n[performance]\nENABLE_PROFILING = true","category":"section"},{"location":"pages/configuration/#HPC-Cluster","page":"Configuration","title":"HPC Cluster","text":"[parallelism]\nTRANSPOSE_LIBRARY = \"PENCIL\"\nAUTO_OPTIMIZE_MESH = true\n\n[transforms-fftw]\nPLANNING_RIGOR = \"FFTW_MEASURE\"\nUSE_FFTW_WISDOM = true\nWISDOM_FILE = \"/scratch/user/fftw_wisdom.dat\"\n\n[logging]\nLEVEL = \"INFO\"\nFILE = \"/scratch/user/simulation.log\"\n\n[output]\nDEFAULT_FORMAT = \"netcdf\"\nCOMPRESSION_LEVEL = 6","category":"section"},{"location":"pages/configuration/#Configuration-Priority","page":"Configuration","title":"Configuration Priority","text":"Settings are applied in this order (later overrides earlier):\n\nBuilt-in defaults\nConfiguration file (tarang.toml)\nEnvironment variables\nRuntime API calls\n\nExample:\n\n# File: tarang.toml has LEVEL = \"INFO\"\nexport TARANG_LOG_LEVEL=DEBUG  # Overrides file setting","category":"section"},{"location":"pages/configuration/#Best-Practices","page":"Configuration","title":"Best Practices","text":"","category":"section"},{"location":"pages/configuration/#For-Development","page":"Configuration","title":"For Development","text":"export OMP_NUM_THREADS=1\nexport FFTW_PLANNING_RIGOR=FFTW_ESTIMATE\nexport TARANG_LOG_LEVEL=DEBUG","category":"section"},{"location":"pages/configuration/#For-Production","page":"Configuration","title":"For Production","text":"[transforms-fftw]\nPLANNING_RIGOR = \"FFTW_MEASURE\"\nUSE_FFTW_WISDOM = true\n\n[performance]\nMEMORY_POOL_SIZE = \"2GB\"\nPREALLOCATE_WORK = true","category":"section"},{"location":"pages/configuration/#For-Benchmarking","page":"Configuration","title":"For Benchmarking","text":"[performance]\nENABLE_PROFILING = true\n\n[logging]\nLEVEL = \"INFO\"\nFILE = \"benchmark.log\"","category":"section"},{"location":"pages/configuration/#Validation","page":"Configuration","title":"Validation","text":"Check your configuration:\n\nusing Tarang.Config\n\n# Load and validate configuration\nconfig = load_config(\"tarang.toml\")\nvalidate_config(config)\n\n# Print current configuration\nprint_config(config)","category":"section"},{"location":"pages/configuration/#Next-Steps","page":"Configuration","title":"Next Steps","text":"Parallelism Guide: Detailed MPI configuration\nOptimization: Performance tuning\nAnalysis and Output: Output configuration","category":"section"},{"location":"pages/gpu_computing/#GPU-Computing","page":"GPU Computing","title":"GPU Computing","text":"Tarang.jl provides comprehensive GPU acceleration through CUDA.jl, enabling significant speedups for spectral simulations on NVIDIA GPUs.","category":"section"},{"location":"pages/gpu_computing/#Overview","page":"GPU Computing","title":"Overview","text":"<div class=\"admonition is-info\">\n<p class=\"admonition-title\">Requirements</p>\n<p>GPU support requires an NVIDIA GPU with CUDA capability 5.0+ and the CUDA.jl package.</p>\n</div>","category":"section"},{"location":"pages/gpu_computing/#Key-Features","page":"GPU Computing","title":"Key Features","text":"Feature Description\nAutomatic Dispatch Arrays automatically use GPU kernels when on GPU memory\nCUFFT Integration Optimized FFT plans via NVIDIA's cuFFT library\nCustom Kernels KernelAbstractions.jl for portable CPU/GPU code\nMemory Pools Efficient GPU memory management with pooling\nMulti-GPU MPI + CUDA for distributed GPU computing\nMixed Precision Float32 support for memory-bound problems","category":"section"},{"location":"pages/gpu_computing/#Quick-Start","page":"GPU Computing","title":"Quick Start","text":"","category":"section"},{"location":"pages/gpu_computing/#Basic-GPU-Setup","page":"GPU Computing","title":"Basic GPU Setup","text":"using Tarang\nusing CUDA\n\n# Check GPU availability\n@assert CUDA.functional() \"CUDA not available\"\n\n# Create distributor with GPU architecture\ncoords = CartesianCoordinates(\"x\", \"y\")\ndist = Distributor(coords; mesh=(1,), dtype=Float64, architecture=GPU())\n\n# Create bases and fields (automatically on GPU)\nxbasis = Fourier(coords, \"x\", 256)\nybasis = Fourier(coords, \"y\", 256)\nfield = ScalarField(dist, \"u\", (xbasis, ybasis))\n\n# Field data is a CuArray\n@assert field[\"g\"] isa CuArray","category":"section"},{"location":"pages/gpu_computing/#CPU-vs-GPU-Architecture","page":"GPU Computing","title":"CPU vs GPU Architecture","text":"# CPU execution (default)\ndist_cpu = Distributor(coords; architecture=CPU())\n\n# GPU execution\ndist_gpu = Distributor(coords; architecture=GPU())\n\n# Check architecture\narch = dist_gpu.architecture  # GPU()","category":"section"},{"location":"pages/gpu_computing/#GPU-Transforms","page":"GPU Computing","title":"GPU Transforms","text":"","category":"section"},{"location":"pages/gpu_computing/#Automatic-FFT-Acceleration","page":"GPU Computing","title":"Automatic FFT Acceleration","text":"When fields are on GPU, transforms automatically use CUFFT:\n\nusing Tarang, CUDA\n\ndist = Distributor(coords; architecture=GPU())\nfield = ScalarField(dist, \"u\", (xbasis, ybasis))\n\n# Initialize with GPU data\nfield[\"g\"] .= CUDA.rand(Float64, size(field[\"g\"])...)\n\n# Forward transform (uses CUFFT automatically)\nforward_transform!(field)\n\n# Backward transform\nbackward_transform!(field)","category":"section"},{"location":"pages/gpu_computing/#FFT-Mode-Control","page":"GPU Computing","title":"FFT Mode Control","text":"Control when GPU FFTs are used:\n\n# Per-field control\nset_gpu_fft_mode!(field, :gpu)   # Always use GPU FFT\nset_gpu_fft_mode!(field, :cpu)   # Always use CPU FFT\nset_gpu_fft_mode!(field, :auto)  # Heuristic-based (default)\n\n# Global threshold for :auto mode\n# Use GPU FFT only if array has >= N elements\nset_gpu_fft_min_elements!(64_000)","category":"section"},{"location":"pages/gpu_computing/#Mixed-Fourier-Chebyshev-Transforms","page":"GPU Computing","title":"Mixed Fourier-Chebyshev Transforms","text":"GPU DCT for Chebyshev bases:\n\n# Mixed basis domain\nxbasis = Fourier(coords, \"x\", 256)      # FFT\nzbasis = ChebyshevT(coords, \"z\", 64)    # DCT\n\ndist = Distributor(coords; architecture=GPU())\nfield = ScalarField(dist, \"T\", (xbasis, zbasis))\n\n# Transforms automatically select FFT or DCT per dimension\nforward_transform!(field)   # FFT in x, DCT in z\nbackward_transform!(field)  # IFFT in x, IDCT in z","category":"section"},{"location":"pages/gpu_computing/#GPU-Memory-Management","page":"GPU Computing","title":"GPU Memory Management","text":"","category":"section"},{"location":"pages/gpu_computing/#Memory-Pools","page":"GPU Computing","title":"Memory Pools","text":"Tarang uses memory pooling to reduce allocation overhead:\n\nusing TarangCUDAExt: GPUMemoryPool, pool_allocate, pool_release!\n\n# Get memory pool statistics\nstats = memory_pool_stats()\nprintln(\"Allocated: $(stats.allocated_bytes) bytes\")\nprintln(\"Cached: $(stats.cached_bytes) bytes\")\n\n# Clear the memory pool (frees cached memory)\nclear_memory_pool!()","category":"section"},{"location":"pages/gpu_computing/#Pinned-Memory-for-MPI","page":"GPU Computing","title":"Pinned Memory for MPI","text":"For efficient GPU-MPI transfers:\n\nusing TarangCUDAExt: get_pinned_buffer, async_copy_to_gpu!, async_copy_to_cpu!\n\n# Get a pinned CPU buffer for async transfers\nbuffer = get_pinned_buffer(Float64, 1024)\n\n# Async copy operations\nasync_copy_to_gpu!(gpu_array, buffer)\nasync_copy_to_cpu!(buffer, gpu_array)","category":"section"},{"location":"pages/gpu_computing/#Memory-Monitoring","page":"GPU Computing","title":"Memory Monitoring","text":"using TarangCUDAExt: gpu_memory_info, check_gpu_memory\n\n# Get current memory usage\ninfo = gpu_memory_info()\nprintln(\"Free: $(info.free_bytes / 1e9) GB\")\nprintln(\"Total: $(info.total_bytes / 1e9) GB\")\n\n# Check if allocation will fit\ncan_allocate = check_gpu_memory(required_bytes)","category":"section"},{"location":"pages/gpu_computing/#Custom-GPU-Kernels","page":"GPU Computing","title":"Custom GPU Kernels","text":"","category":"section"},{"location":"pages/gpu_computing/#KernelAbstractions-Integration","page":"GPU Computing","title":"KernelAbstractions Integration","text":"Write portable kernels that run on both CPU and GPU:\n\nusing Tarang, KernelAbstractions\n\n# Define a kernel\n@kernel function add_kernel!(c, @Const(a), @Const(b))\n    i = @index(Global)\n    @inbounds c[i] = a[i] + b[i]\nend\n\n# Wrap as KernelOperation\nadd_op = KernelOperation(add_kernel!) do c, a, b\n    length(c)  # ndrange\nend\n\n# Use on any architecture\narch = GPU()\na = ones(arch, Float64, 1024)\nb = ones(arch, Float64, 1024)\nc = zeros(arch, Float64, 1024)\n\nadd_op(arch, c, a, b)  # Runs on GPU","category":"section"},{"location":"pages/gpu_computing/#Built-in-GPU-Kernels","page":"GPU Computing","title":"Built-in GPU Kernels","text":"Tarang provides optimized kernels for common operations:\n\nusing TarangCUDAExt\n\n# Element-wise operations\ngpu_add!(c, a, b)           # c = a + b\ngpu_sub!(c, a, b)           # c = a - b\ngpu_mul!(c, a, b)           # c = a * b\ngpu_scale!(y, α, x)         # y = α * x\ngpu_axpy!(y, α, x)          # y = y + α * x\ngpu_linear_combination!(y, α, a, β, b)  # y = α*a + β*b\n\n# Fused operations for timestepping\ngpu_rk_stage!(u_new, u, k, dt, coeff)\ngpu_axpby!(y, α, x, β)      # y = α*x + β*y\n\n# Physics kernels\ngpu_kinetic_energy_2d!(ke, ux, uy)\ngpu_kinetic_energy_3d!(ke, ux, uy, uz)\ngpu_viscous_damping!(field, ν, k2)","category":"section"},{"location":"pages/gpu_computing/#Distributed-GPU-Computing","page":"GPU Computing","title":"Distributed GPU Computing","text":"","category":"section"},{"location":"pages/gpu_computing/#MPI-CUDA","page":"GPU Computing","title":"MPI + CUDA","text":"For multi-GPU simulations:\n\nusing Tarang, MPI, CUDA\n\nMPI.Init()\n\ncomm = MPI.COMM_WORLD\nrank = MPI.Comm_rank(comm)\n\n# Assign GPU to MPI rank\nif CUDA.ndevices() >= MPI.Comm_size(comm)\n    CUDA.device!(rank)\nend\n\n# Create distributed GPU setup\ncoords = CartesianCoordinates(\"x\", \"y\", \"z\")\ndist = Distributor(coords; mesh=(2, 2), architecture=GPU())\n\n# Each rank has its own GPU memory\nfield = ScalarField(dist, \"u\", bases)","category":"section"},{"location":"pages/gpu_computing/#CUDA-Aware-MPI","page":"GPU Computing","title":"CUDA-Aware MPI","text":"For direct GPU-to-GPU communication:\n\nusing TarangCUDAExt: check_cuda_aware_mpi\n\nif check_cuda_aware_mpi()\n    println(\"CUDA-aware MPI available - using direct GPU transfers\")\nelse\n    println(\"Staging through CPU for MPI transfers\")\nend","category":"section"},{"location":"pages/gpu_computing/#TransposableField-for-GPUMPI","page":"GPU Computing","title":"TransposableField for GPU+MPI","text":"Efficient distributed FFTs with GPU:\n\n# Create transposable field for distributed transforms\nfield = ScalarField(dist, \"u\", bases)\ntf = TransposableField(field)\n\n# Distributed forward transform (handles GPU transposes)\ndistributed_forward_transform!(tf)\n\n# Distributed backward transform\ndistributed_backward_transform!(tf)","category":"section"},{"location":"pages/gpu_computing/#Performance-Optimization","page":"GPU Computing","title":"Performance Optimization","text":"","category":"section"},{"location":"pages/gpu_computing/#Best-Practices","page":"GPU Computing","title":"Best Practices","text":"Use Float32 when possible - 2x memory bandwidth, often sufficient accuracy\ndist = Distributor(coords; dtype=Float32, architecture=GPU())\nBatch operations - Minimize kernel launches\n# Bad: many small operations\nfor i in 1:n\n    gpu_scale!(field, α)\nend\n\n# Good: fused operations\ngpu_rk_stage!(u_new, u, k, dt, coeff)\nPreallocate buffers - Avoid allocation in hot loops\n# Preallocate work arrays\nwork = zeros(GPU(), Float64, size(field[\"g\"]))\n\nfor step in 1:nsteps\n    # Reuse work array\n    compute!(work, field)\nend\nUse streams for overlap - Overlap computation and communication\nusing TarangCUDAExt: get_compute_stream, get_transfer_stream, sync_streams!\n\ncompute_stream = get_compute_stream()\ntransfer_stream = get_transfer_stream()\n# ... overlap operations\nsync_streams!()","category":"section"},{"location":"pages/gpu_computing/#Profiling","page":"GPU Computing","title":"Profiling","text":"using CUDA\n\n# Profile a section\nCUDA.@profile begin\n    forward_transform!(field)\n    backward_transform!(field)\nend\n\n# Time with synchronization\nCUDA.@elapsed begin\n    forward_transform!(field)\n    CUDA.synchronize()\nend","category":"section"},{"location":"pages/gpu_computing/#Memory-Bandwidth-Optimization","page":"GPU Computing","title":"Memory Bandwidth Optimization","text":"# Check if transform is memory-bound\nn = prod(size(field[\"g\"]))\nbytes_transferred = n * sizeof(eltype(field[\"g\"])) * 4  # rough estimate\n\n# Theoretical bandwidth (e.g., A100 = 2 TB/s)\ntheoretical_time = bytes_transferred / 2e12\n\n# Compare to actual time\nactual_time = CUDA.@elapsed forward_transform!(field)\nefficiency = theoretical_time / actual_time\nprintln(\"Memory bandwidth efficiency: $(efficiency * 100)%\")","category":"section"},{"location":"pages/gpu_computing/#Tensor-Core-Support","page":"GPU Computing","title":"Tensor Core Support","text":"For supported operations on Ampere+ GPUs:\n\nusing TarangCUDAExt: enable_tensor_cores!, disable_tensor_cores!\n\n# Enable tensor cores (requires compatible data types)\nenable_tensor_cores!()\n\n# Disable if numerical precision is critical\ndisable_tensor_cores!()","category":"section"},{"location":"pages/gpu_computing/#Troubleshooting","page":"GPU Computing","title":"Troubleshooting","text":"","category":"section"},{"location":"pages/gpu_computing/#Common-Issues","page":"GPU Computing","title":"Common Issues","text":"Out of Memory\n\n# Check available memory before large allocations\ninfo = gpu_memory_info()\nif info.free_bytes < required_bytes\n    clear_memory_pool!()  # Free cached allocations\n    GC.gc()               # Trigger garbage collection\n    CUDA.reclaim()        # Reclaim CUDA memory\nend\n\nSlow Performance\n\n# Ensure synchronization isn't killing performance\nCUDA.allowscalar(false)  # Disable slow scalar indexing\n\n# Check for CPU fallbacks\n@assert field[\"g\"] isa CuArray \"Data not on GPU!\"\n\nMPI + CUDA Issues\n\n# Ensure correct GPU assignment\nprintln(\"Rank $rank using GPU $(CUDA.device())\")\n\n# Force synchronization before MPI calls\nCUDA.synchronize()\nMPI.Barrier(comm)","category":"section"},{"location":"pages/gpu_computing/#API-Reference","page":"GPU Computing","title":"API Reference","text":"See the GPU API documentation for complete function references.","category":"section"},{"location":"pages/gpu_computing/#Key-Functions","page":"GPU Computing","title":"Key Functions","text":"Function Description\nGPU() GPU architecture singleton\non_architecture(GPU(), array) Move array to GPU\nforward_transform!(field) GPU-accelerated forward FFT\nbackward_transform!(field) GPU-accelerated inverse FFT\nset_gpu_fft_mode!(field, mode) Control FFT backend\nTransposableField(field) Distributed GPU transforms","category":"section"},{"location":"tutorials/surface_dynamics/#Surface-and-Boundary-Dynamics","page":"Surface and Boundary Dynamics","title":"Surface and Boundary Dynamics","text":"This tutorial covers solving advection-diffusion equations on domain boundaries, including Surface Quasi-Geostrophic (SQG) dynamics and general boundary-coupled systems.","category":"section"},{"location":"tutorials/surface_dynamics/#Overview","page":"Surface and Boundary Dynamics","title":"Overview","text":"Many physical systems involve dynamics confined to surfaces or boundaries:\n\nSurface Quasi-Geostrophic (SQG): Ocean/atmosphere surface temperature dynamics\nQuasi-Geostrophic (QG): Coupled surface buoyancy with interior PV\nPassive tracers: Concentration advected by prescribed flow\nReactive surfaces: Chemical species on catalytic surfaces\n\nTarang provides a flexible BoundaryAdvectionDiffusion framework for all these cases.","category":"section"},{"location":"tutorials/surface_dynamics/#The-Advection-Diffusion-Equation","page":"Surface and Boundary Dynamics","title":"The Advection-Diffusion Equation","text":"The general equation solved on each boundary is:\n\n∂c/∂t + u·∇c = D(c) + S\n\nwhere:\n\nc is the scalar field (buoyancy, concentration, temperature)\nu is the advection velocity\nD(c) is the diffusion operator\nS is an optional source term","category":"section"},{"location":"tutorials/surface_dynamics/#Velocity-Sources","page":"Surface and Boundary Dynamics","title":"Velocity Sources","text":"The key difference between problems is how the velocity u is obtained:","category":"section"},{"location":"tutorials/surface_dynamics/#1.-Self-Derived-Velocity-(SQG-like)","page":"Surface and Boundary Dynamics","title":"1. Self-Derived Velocity (SQG-like)","text":"Velocity computed from the boundary field itself through an inversion:\n\nψ = (-Δ)^α c      (fractional Laplacian inversion)\nu = ∇⊥ψ           (perpendicular gradient for incompressibility)\n\nFor SQG, α = -1/2, giving ψ = (-Δ)^(-1/2) θ.\n\nusing Tarang\n\n# SQG setup: velocity from buoyancy inversion\nbad = boundary_advection_diffusion_setup(\n    Lx=2π, Ly=2π,\n    Nx=256, Ny=256,\n    boundaries=[BoundarySpec(\"theta\", :z, 0.0)],\n    velocity_source=SelfDerivedVelocity(\n        inversion_exponent=-0.5,  # SQG: ψ = (-Δ)^(-1/2) θ\n        use_perp_grad=true        # u = ∇⊥ψ (incompressible)\n    ),\n    diffusion=DiffusionSpec(\n        type=:fractional,\n        coefficient=1e-4,\n        exponent=0.5              # Physical SQG dissipation\n    )\n)","category":"section"},{"location":"tutorials/surface_dynamics/#2.-Interior-Derived-Velocity-(QG-like)","page":"Surface and Boundary Dynamics","title":"2. Interior-Derived Velocity (QG-like)","text":"Velocity extracted from a 3D interior field at the boundary:\n\n# QG setup: velocity from interior streamfunction\nbad = boundary_advection_diffusion_setup(\n    Lx=2π, Ly=2π,\n    Nx=128, Ny=128,\n    boundaries=[\n        BoundarySpec(\"bottom\", :z, 0.0),\n        BoundarySpec(\"top\", :z, 1.0)\n    ],\n    velocity_source=InteriorDerivedVelocity(:perp_grad),  # u = ∇⊥ψ|_{surface}\n    diffusion=DiffusionSpec(type=:fractional, coefficient=1e-4, exponent=0.5),\n    interior_coupling=(\n        Nz=32,\n        H=1.0,\n        equation=\"Δ(ψ) + S*∂z(∂z(ψ)) = q\",  # QG elliptic operator\n        params=Dict(\"S\" => 0.01, \"q\" => 0.0)\n    )\n)","category":"section"},{"location":"tutorials/surface_dynamics/#3.-Prescribed-Velocity-(Passive-Tracer)","page":"Surface and Boundary Dynamics","title":"3. Prescribed Velocity (Passive Tracer)","text":"Velocity set externally by the user each timestep:\n\n# Passive tracer in prescribed flow\nbad = boundary_advection_diffusion_setup(\n    Lx=2π, Ly=2π,\n    Nx=128, Ny=128,\n    boundaries=[BoundarySpec(\"concentration\", :z, 0.0)],\n    velocity_source=PrescribedVelocity(),\n    diffusion=DiffusionSpec(type=:laplacian, coefficient=0.01)\n)\n\n# In time loop, set velocity before stepping\nfunction set_velocity!(bad, t)\n    # Example: rotating flow\n    x, y = get_coordinates(bad)\n    bad.velocities[\"concentration\"].components[1].data_g .= -sin.(y)\n    bad.velocities[\"concentration\"].components[2].data_g .= sin.(x)\nend","category":"section"},{"location":"tutorials/surface_dynamics/#Diffusion-Types","page":"Surface and Boundary Dynamics","title":"Diffusion Types","text":"","category":"section"},{"location":"tutorials/surface_dynamics/#Standard-Laplacian","page":"Surface and Boundary Dynamics","title":"Standard Laplacian","text":"DiffusionSpec(type=:laplacian, coefficient=0.01)\n# Gives: κΔc","category":"section"},{"location":"tutorials/surface_dynamics/#Fractional-Laplacian","page":"Surface and Boundary Dynamics","title":"Fractional Laplacian","text":"DiffusionSpec(type=:fractional, coefficient=1e-4, exponent=0.5)\n# Gives: -κ(-Δ)^α c\n\nCommon exponents:\n\nα = 0.5: Physical SQG dissipation\nα = 1.0: Standard Laplacian (equivalent to :laplacian)\nα = 2.0: Biharmonic (hyperviscosity)","category":"section"},{"location":"tutorials/surface_dynamics/#Hyperdiffusion","page":"Surface and Boundary Dynamics","title":"Hyperdiffusion","text":"DiffusionSpec(type=:hyperdiffusion, coefficient=1e-8, exponent=2.0)\n# Gives: -κ(-Δ)^n c (typically n=2 for biharmonic)","category":"section"},{"location":"tutorials/surface_dynamics/#No-Diffusion","page":"Surface and Boundary Dynamics","title":"No Diffusion","text":"DiffusionSpec(type=:none)\n# Inviscid dynamics","category":"section"},{"location":"tutorials/surface_dynamics/#Complete-SQG-Example","page":"Surface and Boundary Dynamics","title":"Complete SQG Example","text":"using Tarang\n\n# Domain and resolution\nLx, Ly = 2π, 2π\nNx, Ny = 256, 256\n\n# Create SQG system\nsqg = boundary_advection_diffusion_setup(\n    Lx=Lx, Ly=Ly,\n    Nx=Nx, Ny=Ny,\n    boundaries=[BoundarySpec(\"theta\", :z, 0.0)],\n    velocity_source=SelfDerivedVelocity(inversion_exponent=-0.5),\n    diffusion=DiffusionSpec(type=:fractional, coefficient=1e-4, exponent=0.5)\n)\n\n# Initial condition: random perturbation\nθ = sqg.fields[\"theta\"]\nensure_layout!(θ, :g)\n\n# Create elliptical vortex\nx = range(0, Lx, length=Nx)\ny = range(0, Ly, length=Ny)\nX = [xi for xi in x, _ in y]\nY = [yj for _ in x, yj in y]\n\nθ.data_g .= exp.(-((X .- π).^2 ./ 0.5 .+ (Y .- π).^2 ./ 0.3))\n\n# Time stepping\ndt = 0.001\nnsteps = 10000\noutput_interval = 100\n\nfor step in 1:nsteps\n    bad_step!(sqg, dt; timestepper=:RK4)\n\n    if step % output_interval == 0\n        energy = bad_energy(sqg)\n        max_vel = bad_max_velocity(sqg)\n        println(\"Step $step: E = $energy, max|u| = $max_vel\")\n    end\nend","category":"section"},{"location":"tutorials/surface_dynamics/#Multiple-Boundaries-(QG-like)","page":"Surface and Boundary Dynamics","title":"Multiple Boundaries (QG-like)","text":"For problems with dynamics at multiple surfaces:\n\n# Two-surface QG system\nqg = boundary_advection_diffusion_setup(\n    Lx=2π, Ly=2π,\n    Nx=128, Ny=128,\n    boundaries=[\n        BoundarySpec(\"theta_bot\", :z, 0.0; field_name=\"θ_bottom\"),\n        BoundarySpec(\"theta_top\", :z, 1.0; field_name=\"θ_top\")\n    ],\n    velocity_source=InteriorDerivedVelocity(:perp_grad),\n    diffusion=DiffusionSpec(type=:fractional, coefficient=1e-4, exponent=0.5),\n    interior_coupling=(\n        Nz=32,\n        H=1.0,\n        equation=\"Δ(ψ) + S*∂z(∂z(ψ)) = 0\",\n        params=Dict(\"S\" => (1.0/10.0)^2)  # (f₀/N)²\n    )\n)\n\n# Set different initial conditions at each surface\nqg.fields[\"theta_bot\"].data_g .= initial_bottom\nqg.fields[\"theta_top\"].data_g .= initial_top\n\n# Both surfaces evolve together\nfor step in 1:nsteps\n    bad_step!(qg, dt)\nend","category":"section"},{"location":"tutorials/surface_dynamics/#Adding-Source-Terms","page":"Surface and Boundary Dynamics","title":"Adding Source Terms","text":"Custom source terms can be added:\n\n# Gaussian forcing centered at (π, π)\nfunction my_forcing(bad, boundary_name)\n    θ = bad.fields[boundary_name]\n    Nx, Ny = size(θ.data_g)\n\n    x = range(0, bad.params[\"Lx\"], length=Nx)\n    y = range(0, bad.params[\"Ly\"], length=Ny)\n\n    forcing = zeros(Nx, Ny)\n    for j in 1:Ny, i in 1:Nx\n        r2 = (x[i] - π)^2 + (y[j] - π)^2\n        forcing[i, j] = 0.1 * exp(-r2 / 0.5)\n    end\n\n    return forcing\nend\n\nbad_add_source!(sqg, \"theta\", my_forcing)","category":"section"},{"location":"tutorials/surface_dynamics/#Available-Timesteppers","page":"Surface and Boundary Dynamics","title":"Available Timesteppers","text":"Method Order Description\n:Euler 1 Forward Euler\n:RK2 2 Midpoint method\n:RK4 4 Classical Runge-Kutta\n:SSPRK3 3 Strong Stability Preserving RK3\n\nbad_step!(sqg, dt; timestepper=:SSPRK3)","category":"section"},{"location":"tutorials/surface_dynamics/#Diagnostics","page":"Surface and Boundary Dynamics","title":"Diagnostics","text":"","category":"section"},{"location":"tutorials/surface_dynamics/#Energy","page":"Surface and Boundary Dynamics","title":"Energy","text":"E = bad_energy(sqg)  # Total L² energy across all boundaries","category":"section"},{"location":"tutorials/surface_dynamics/#Enstrophy","page":"Surface and Boundary Dynamics","title":"Enstrophy","text":"Z = bad_enstrophy(sqg, \"theta\")  # Squared gradient of specific field","category":"section"},{"location":"tutorials/surface_dynamics/#Maximum-Velocity","page":"Surface and Boundary Dynamics","title":"Maximum Velocity","text":"umax = bad_max_velocity(sqg)","category":"section"},{"location":"tutorials/surface_dynamics/#CFL-Timestep","page":"Surface and Boundary Dynamics","title":"CFL Timestep","text":"dt_cfl = bad_cfl_dt(sqg; safety=0.5)","category":"section"},{"location":"tutorials/surface_dynamics/#Adaptive-Timestepping","page":"Surface and Boundary Dynamics","title":"Adaptive Timestepping","text":"for step in 1:nsteps\n    # Compute CFL-limited timestep\n    dt = bad_cfl_dt(sqg; safety=0.4)\n    dt = min(dt, dt_max)  # Cap maximum timestep\n\n    bad_step!(sqg, dt)\n\n    sqg.time  # Current simulation time\nend","category":"section"},{"location":"tutorials/surface_dynamics/#MPI-Parallelism","page":"Surface and Boundary Dynamics","title":"MPI Parallelism","text":"The framework supports MPI domain decomposition:\n\nsqg = boundary_advection_diffusion_setup(\n    Lx=2π, Ly=2π,\n    Nx=512, Ny=512,\n    boundaries=[BoundarySpec(\"theta\", :z, 0.0)],\n    velocity_source=SelfDerivedVelocity(inversion_exponent=-0.5),\n    diffusion=DiffusionSpec(type=:fractional, coefficient=1e-4, exponent=0.5),\n    mesh=(4, 4)  # 4×4 = 16 MPI processes\n)\n\nRun with:\n\nmpiexec -n 16 julia my_sqg_simulation.jl","category":"section"},{"location":"tutorials/surface_dynamics/#Comparison-with-Dedicated-QGSystem","page":"Surface and Boundary Dynamics","title":"Comparison with Dedicated QGSystem","text":"For full QG with interior PV dynamics, you can also use the specialized QGSystem:\n\n# Using dedicated QGSystem (more features for QG-specific problems)\nqg = qg_system_setup(\n    Lx=2π, Ly=2π, H=1.0,\n    Nx=128, Ny=128, Nz=32,\n    f0=1.0, N=10.0,\n    κ=1e-4, α=0.5\n)\n\nqg_step!(qg, dt; timestepper=:RK4)\nE = qg_energy(qg)\n\nThe BoundaryAdvectionDiffusion framework is more general and flexible, while QGSystem provides QG-specific functionality.","category":"section"},{"location":"tutorials/surface_dynamics/#Summary","page":"Surface and Boundary Dynamics","title":"Summary","text":"Use Case Velocity Source Example\nSQG SelfDerivedVelocity Surface buoyancy dynamics\nQG InteriorDerivedVelocity Coupled surface-interior\nPassive tracer PrescribedVelocity Tracer in known flow","category":"section"},{"location":"tutorials/surface_dynamics/#See-Also","page":"Surface and Boundary Dynamics","title":"See Also","text":"Operators: Fractional Laplacian details\nProblems: IVP and LBVP setup\nSolvers: Timestepping and BVP solvers","category":"section"},{"location":"#Tarang.jl","page":"Home","title":"Tarang.jl","text":"A flexible spectral PDE solver for Julia with GPU acceleration and MPI parallelization\n\n<div style=\"text-align: center; margin: 2em 0;\">\n  <img src=\"assets/logo_light.svg\" alt=\"Tarang.jl\" width=\"500\" style=\"max-width: 100%;\" />\n</div>","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"Tarang.jl is a high-performance Julia framework for solving partial differential equations (PDEs) using spectral methods. Inspired by Dedalus, it provides a flexible symbolic interface for specifying equations while leveraging Julia's speed and composability.\n\n<div class=\"feature-grid\">\n  <div class=\"feature-card\">\n    <h3>🔬 Spectral Methods</h3>\n    <p>Fourier, Chebyshev, and Legendre bases with automatic differentiation and spectral accuracy.</p>\n  </div>\n  <div class=\"feature-card\">\n    <h3>⚡ GPU Acceleration</h3>\n    <p>Native CUDA support with optimized FFT plans, GPU kernels, and automatic CPU/GPU dispatch.</p>\n  </div>\n  <div class=\"feature-card\">\n    <h3>🚀 MPI Parallelization</h3>\n    <p>Efficient pencil decomposition using PencilArrays.jl and PencilFFTs.jl for scalable HPC.</p>\n  </div>\n  <div class=\"feature-card\">\n    <h3>📝 Symbolic Equations</h3>\n    <p>Natural mathematical syntax for PDEs with automatic parsing and operator construction.</p>\n  </div>\n</div>","category":"section"},{"location":"#Quick-Installation","page":"Home","title":"Quick Installation","text":"using Pkg\nPkg.add(\"Tarang\")\n\nFor GPU support:\n\nPkg.add(\"CUDA\")\n\nFor MPI parallelization:\n\nPkg.add(\"MPI\")\n\nSee the Installation Guide for detailed instructions.","category":"section"},{"location":"#Quick-Start-Example","page":"Home","title":"Quick Start Example","text":"using Tarang, MPI\n\nMPI.Init()\n\n# Create 2D domain for Rayleigh-Bénard convection\ncoords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords, mesh=(2, 2))\n\n# Define spectral bases\nx_basis = RealFourier(coords[\"x\"], size=256, bounds=(0.0, 4.0))\nz_basis = ChebyshevT(coords[\"z\"], size=64, bounds=(0.0, 1.0))\n\n# Create domain and fields\ndomain = Domain(dist, (x_basis, z_basis))\nu = VectorField(dist, coords, \"u\", (x_basis, z_basis))\np = ScalarField(dist, \"p\", (x_basis, z_basis))\nT = ScalarField(dist, \"T\", (x_basis, z_basis))\n\n# Set up initial value problem with Dedalus-style syntax\nproblem = IVP([u.components[1], u.components[2], p, T])\nadd_equation!(problem, \"dt(ux) - Pr*lap(ux) + dx(p) = -u@grad(ux) + Ra*Pr*T*ez\")\nadd_equation!(problem, \"dt(uz) - Pr*lap(uz) + dz(p) = -u@grad(uz)\")\nadd_equation!(problem, \"div(u) = 0\")\nadd_equation!(problem, \"dt(T) - lap(T) = -u@grad(T)\")\n\n# Parameters\nproblem.parameters[\"Pr\"] = 1.0\nproblem.parameters[\"Ra\"] = 1e5\n\n# Boundary conditions\nadd_equation!(problem, \"u(z=0) = 0\")\nadd_equation!(problem, \"u(z=1) = 0\")\nadd_equation!(problem, \"T(z=0) = 1\")\nadd_equation!(problem, \"T(z=1) = 0\")\n\n# Create solver and integrate\nsolver = InitialValueSolver(problem, RK222(), dt=1e-3)\nwhile solver.sim_time < 1.0\n    step!(solver, 1e-3)\nend\n\nMPI.Finalize()","category":"section"},{"location":"#Documentation-Sections","page":"Home","title":"Documentation Sections","text":"<div class=\"feature-grid\">\n  <div class=\"feature-card\">\n    <h3><a href=\"getting_started/installation/\">Installing Tarang</a></h3>\n    <p>Installation instructions, first steps, and configuration options.</p>\n  </div>\n  <div class=\"feature-card\">\n    <h3><a href=\"tutorials/overview/\">Tutorials & Examples</a></h3>\n    <p>Step-by-step tutorials, example scripts, and Jupyter notebooks.</p>\n  </div>\n  <div class=\"feature-card\">\n    <h3><a href=\"pages/coordinates/\">User Guide</a></h3>\n    <p>Detailed documentation on coordinates, bases, fields, operators, and solvers.</p>\n  </div>\n  <div class=\"feature-card\">\n    <h3><a href=\"api/coordinates/\">API Reference</a></h3>\n    <p>Complete API documentation with docstrings for all public functions.</p>\n  </div>\n</div>","category":"section"},{"location":"#Capabilities","page":"Home","title":"Capabilities","text":"","category":"section"},{"location":"#Problem-Types","page":"Home","title":"Problem Types","text":"Type Description Example\nIVP Initial Value Problems Time-dependent Navier-Stokes\nBVP Boundary Value Problems Steady state solutions\nEVP Eigenvalue Problems Linear stability analysis\nLBVP Linear BVPs Poisson equation\nNLBVP Nonlinear BVPs Steady nonlinear systems","category":"section"},{"location":"#Spectral-Bases","page":"Home","title":"Spectral Bases","text":"Basis Domain Usage\nRealFourier Periodic Horizontal directions\nComplexFourier Periodic Complex-valued fields\nChebyshevT Non-periodic Bounded domains, BCs\nLegendre Non-periodic Alternative to Chebyshev","category":"section"},{"location":"#Physical-Applications","page":"Home","title":"Physical Applications","text":"Fluid Dynamics: Navier-Stokes, Rayleigh-Bénard convection, channel flow\nHeat Transfer: Diffusion, advection-diffusion\nMagnetohydrodynamics: MHD equations with magnetic fields\nGeophysical Flows: Rotating shallow water, stratified turbulence\nTurbulence Modeling: LES with Smagorinsky and AMD models","category":"section"},{"location":"#Featured-Tutorials","page":"Home","title":"Featured Tutorials","text":"2D Rayleigh-Bénard Convection — Classic thermal convection\n3D Homogeneous Turbulence — Isotropic turbulence simulation\nEigenvalue Problems — Linear stability analysis\nRotating Shallow Water — Geophysical fluid dynamics","category":"section"},{"location":"#GPU-Acceleration","page":"Home","title":"GPU Acceleration","text":"Tarang.jl provides first-class GPU support through CUDA.jl:\n\n<div class=\"feature-grid\">\n  <div class=\"feature-card\">\n    <h3>CUFFT Integration</h3>\n    <p>Automatic FFT/DCT acceleration using NVIDIA's optimized cuFFT library.</p>\n  </div>\n  <div class=\"feature-card\">\n    <h3>Custom Kernels</h3>\n    <p>Portable CPU/GPU kernels via KernelAbstractions.jl for element-wise operations.</p>\n  </div>\n  <div class=\"feature-card\">\n    <h3>Multi-GPU MPI</h3>\n    <p>Distributed GPU computing with CUDA-aware MPI support for large-scale simulations.</p>\n  </div>\n  <div class=\"feature-card\">\n    <h3>Memory Management</h3>\n    <p>GPU memory pools, pinned buffers, and automatic data movement.</p>\n  </div>\n</div>","category":"section"},{"location":"#Quick-GPU-Example","page":"Home","title":"Quick GPU Example","text":"using Tarang, CUDA\n\n# Create GPU-accelerated simulation\ncoords = CartesianCoordinates(\"x\", \"y\")\ndist = Distributor(coords; architecture=GPU(), dtype=Float32)\n\nxbasis = Fourier(coords, \"x\", 512)\nybasis = Fourier(coords, \"y\", 512)\n\nfield = ScalarField(dist, \"u\", (xbasis, ybasis))\nfield[\"g\"] .= CUDA.rand(Float32, 512, 512)\n\n# Transforms automatically use CUFFT\nforward_transform!(field)   # GPU FFT\nbackward_transform!(field)  # GPU IFFT\n\nSee the GPU Computing Guide for detailed documentation.","category":"section"},{"location":"#Performance","page":"Home","title":"Performance","text":"Tarang.jl is designed for high performance:\n\nNative Julia Speed: Compiled to native machine code, no interpreter overhead\nGPU Acceleration: CUDA-optimized kernels with automatic memory management\nScalable MPI: Efficient pencil decomposition scales to thousands of cores\nMemory Efficient: Zero-copy operations and optimized memory layouts","category":"section"},{"location":"#Citing-Tarang.jl","page":"Home","title":"Citing Tarang.jl","text":"If you use Tarang.jl in your research, please cite:\n\n@software{tarang_jl,\n  title = {Tarang.jl: A Spectral PDE Solver for Julia},\n  author = {Subhajit Kar},\n  year = {2024},\n  url = {https://github.com/subhk/Tarang.jl}\n}","category":"section"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"Tarang.jl builds upon excellent Julia packages:\n\nPencilArrays.jl — Distributed array infrastructure\nPencilFFTs.jl — Parallel FFT transforms\nMPI.jl — MPI bindings for Julia\nCUDA.jl — GPU computing support","category":"section"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"Issues: Report bugs on GitHub Issues\nDiscussions: Ask questions on GitHub Discussions\nContributing: See the Contributing Guide","category":"section"},{"location":"#License","page":"Home","title":"License","text":"Tarang.jl is licensed under the MIT License.","category":"section"},{"location":"api/timesteppers/#Timesteppers-API","page":"Timesteppers API","title":"Timesteppers API","text":"Time integration schemes for evolving PDEs in time.","category":"section"},{"location":"api/timesteppers/#TimeStepper-Types","page":"Timesteppers API","title":"TimeStepper Types","text":"","category":"section"},{"location":"api/timesteppers/#Abstract-Type","page":"Timesteppers API","title":"Abstract Type","text":"abstract type TimeStepper end\n\nAll timesteppers inherit from this abstract type.","category":"section"},{"location":"api/timesteppers/#IMEX-Runge-Kutta","page":"Timesteppers API","title":"IMEX Runge-Kutta","text":"","category":"section"},{"location":"api/timesteppers/#RK111","page":"Timesteppers API","title":"RK111","text":"1st-order IMEX Runge-Kutta.\n\nRK111()\n\nProperties:\n\nOrder: 1\nStages: 1\nImplicit part: Backward Euler for linear terms\nExplicit part: Forward Euler for nonlinear terms\nMemory: Minimal","category":"section"},{"location":"api/timesteppers/#RK222","page":"Timesteppers API","title":"RK222","text":"2nd-order, 2-stage IMEX Runge-Kutta.\n\nRK222()\n\nProperties:\n\nOrder: 2\nStages: 2\nImplicit part: 2-stage DIRK for linear terms\nExplicit part: 2-stage explicit RK for nonlinear terms\nMemory: 2 state copies\n\nRecommended for: General purpose problems.","category":"section"},{"location":"api/timesteppers/#RK443","page":"Timesteppers API","title":"RK443","text":"3rd-order, 4-stage IMEX Runge-Kutta.\n\nRK443()\n\nProperties:\n\nOrder: 3\nStages: 4\nImplicit part: 4-stage DIRK for linear terms\nExplicit part: 4-stage explicit RK for nonlinear terms\nMemory: 4 state copies\n\nRecommended for: High accuracy requirements.","category":"section"},{"location":"api/timesteppers/#IMEX-Multistep-Methods","page":"Timesteppers API","title":"IMEX Multistep Methods","text":"","category":"section"},{"location":"api/timesteppers/#CNAB-(Crank-Nicolson-Adams-Bashforth)","page":"Timesteppers API","title":"CNAB (Crank-Nicolson Adams-Bashforth)","text":"CNAB1()  # 1st order\nCNAB2()  # 2nd order\n\nTreatment:\n\nLinear terms: Crank-Nicolson (implicit)\nNonlinear terms: Adams-Bashforth (explicit)\n\nProperties:\n\nCNAB1: Order 1, 1 history level\nCNAB2: Order 2, 2 history levels","category":"section"},{"location":"api/timesteppers/#SBDF-(Semi-implicit-BDF)","page":"Timesteppers API","title":"SBDF (Semi-implicit BDF)","text":"SBDF1()  # 1st order\nSBDF2()  # 2nd order\nSBDF3()  # 3rd order\nSBDF4()  # 4th order\n\nTreatment:\n\nLinear terms: BDF (implicit)\nNonlinear terms: Extrapolation (explicit)\n\nProperties: | Method | Order | History Levels | Stability | |––––|–––-|––––––––|–––––-| | SBDF1 | 1 | 1 | A-stable | | SBDF2 | 2 | 2 | A-stable | | SBDF3 | 3 | 3 | A(α)-stable | | SBDF4 | 4 | 4 | A(α)-stable |","category":"section"},{"location":"api/timesteppers/#Usage-with-Solver","page":"Timesteppers API","title":"Usage with Solver","text":"# Create solver with timestepper\nsolver = InitialValueSolver(problem, RK222(); dt=0.001)\n\n# Or IMEX\nsolver = InitialValueSolver(problem, SBDF2(); dt=0.01)\n\n# Time stepping\nwhile solver.sim_time < t_end\n    step!(solver)\nend","category":"section"},{"location":"api/timesteppers/#Timestepper-State","page":"Timesteppers API","title":"Timestepper State","text":"","category":"section"},{"location":"api/timesteppers/#TimestepperState","page":"Timesteppers API","title":"TimestepperState","text":"Internal state for multi-step methods.\n\nstruct TimestepperState\n    timestepper::TimeStepper\n    dt::Float64\n    history::Vector  # Previous time levels\nend\n\nManaged automatically by the solver.","category":"section"},{"location":"api/timesteppers/#Stability-Regions","page":"Timesteppers API","title":"Stability Regions","text":"","category":"section"},{"location":"api/timesteppers/#Explicit-Methods","page":"Timesteppers API","title":"Explicit Methods","text":"CFL condition limits timestep:\n\nDelta t  C fracDelta xu_max\n\nRK111: C ≈ 1.0\nRK222: C ≈ 1.0\nRK443: C ≈ 1.4","category":"section"},{"location":"api/timesteppers/#IMEX-Methods","page":"Timesteppers API","title":"IMEX Methods","text":"Diffusive stability removed:\n\nDelta t  C fracDelta xu_max\n\nOnly advective CFL, not diffusive.","category":"section"},{"location":"api/timesteppers/#Method-Selection-Guide","page":"Timesteppers API","title":"Method Selection Guide","text":"Problem Type Method Reason\nGeneral purpose RK222 Balance of cost/accuracy\nHigh accuracy RK443 More stages, higher order\nDiffusion-dominated SBDF2 Implicit diffusion\nVery stiff SBDF3/SBDF4 Strong stability","category":"section"},{"location":"api/timesteppers/#Performance","page":"Timesteppers API","title":"Performance","text":"","category":"section"},{"location":"api/timesteppers/#Computational-Cost","page":"Timesteppers API","title":"Computational Cost","text":"Method RHS Evaluations Linear Solves\nRK111 1 0\nRK222 2 0\nRK443 4 0\nCNAB2 1 1\nSBDF2 1 1","category":"section"},{"location":"api/timesteppers/#Memory-Requirements","page":"Timesteppers API","title":"Memory Requirements","text":"Method State Copies\nRK111 1\nRK222 2\nRK443 4\nSBDF2 2 (history)\nSBDF4 4 (history)","category":"section"},{"location":"api/timesteppers/#See-Also","page":"Timesteppers API","title":"See Also","text":"Solvers: Using timesteppers\nUser Guide: Timesteppers: Conceptual guide","category":"section"},{"location":"api/gpu/#GPU-API-Reference","page":"GPU API Reference","title":"GPU API Reference","text":"This page documents the GPU-specific functions and types in Tarang.jl.","category":"section"},{"location":"api/gpu/#Architecture-Types","page":"GPU API Reference","title":"Architecture Types","text":"","category":"section"},{"location":"api/gpu/#Array-Operations","page":"GPU API Reference","title":"Array Operations","text":"","category":"section"},{"location":"api/gpu/#Data-Movement","page":"GPU API Reference","title":"Data Movement","text":"# Move array to GPU\ngpu_array = on_architecture(GPU(), cpu_array)\n\n# Move array to CPU\ncpu_array = on_architecture(CPU(), gpu_array)\n\n# Check if array is on GPU\nis_gpu_array(array)","category":"section"},{"location":"api/gpu/#Allocation","page":"GPU API Reference","title":"Allocation","text":"# Allocate on specific architecture\nzeros(GPU(), Float64, 128, 128)\nones(GPU(), Float32, 256)\nsimilar(gpu_array)","category":"section"},{"location":"api/gpu/#Transform-Functions","page":"GPU API Reference","title":"Transform Functions","text":"","category":"section"},{"location":"api/gpu/#FFT-Control","page":"GPU API Reference","title":"FFT Control","text":"Function Description\nset_gpu_fft_mode!(field, mode) Set FFT backend (:auto, :cpu, :gpu)\nset_gpu_fft_min_elements!(n) Threshold for auto mode\nshould_use_gpu_fft(field) Check if GPU FFT will be used","category":"section"},{"location":"api/gpu/#Transform-Execution","page":"GPU API Reference","title":"Transform Execution","text":"Function Description\nforward_transform!(field) Forward spectral transform\nbackward_transform!(field) Backward spectral transform\ngpu_forward_transform!(field) Force GPU transform\ngpu_backward_transform!(field) Force GPU transform","category":"section"},{"location":"api/gpu/#GPU-Kernels","page":"GPU API Reference","title":"GPU Kernels","text":"","category":"section"},{"location":"api/gpu/#Element-wise-Operations","page":"GPU API Reference","title":"Element-wise Operations","text":"# Basic operations\ngpu_add!(c, a, b)           # c = a + b\ngpu_sub!(c, a, b)           # c = a - b\ngpu_mul!(c, a, b)           # c = a .* b\ngpu_scale!(y, α, x)         # y = α * x\ngpu_axpy!(y, α, x)          # y = y + α * x\n\n# Linear combinations\ngpu_linear_combination!(y, α, a, β, b)  # y = α*a + β*b\ngpu_axpby!(y, α, x, β)                  # y = α*x + β*y","category":"section"},{"location":"api/gpu/#Timestepping-Kernels","page":"GPU API Reference","title":"Timestepping Kernels","text":"# Runge-Kutta stage update\ngpu_rk_stage!(u_new, u, k, dt, coeff)\n\n# Fused multiply-add\ngpu_fma!(y, a, b, c)  # y = a*b + c","category":"section"},{"location":"api/gpu/#Physics-Kernels","page":"GPU API Reference","title":"Physics Kernels","text":"# Kinetic energy\ngpu_kinetic_energy_2d!(ke, ux, uy)\ngpu_kinetic_energy_3d!(ke, ux, uy, uz)\n\n# Gradient magnitude squared\ngpu_grad_mag_sq_2d!(result, fx, fy)\n\n# Viscous damping in spectral space\ngpu_viscous_damping!(field, ν, k2)\n\n# Dealiasing\ngpu_dealias_multiply!(result, a, b, mask)\ngpu_triple_product!(result, a, b, c)","category":"section"},{"location":"api/gpu/#Complex-Operations","page":"GPU API Reference","title":"Complex Operations","text":"# Complex conjugate multiply\ngpu_conj_multiply!(c, a, b)  # c = conj(a) * b\n\n# Squared magnitude\ngpu_squared_magnitude!(result, z)  # result = |z|²","category":"section"},{"location":"api/gpu/#Memory-Management","page":"GPU API Reference","title":"Memory Management","text":"","category":"section"},{"location":"api/gpu/#Memory-Pool","page":"GPU API Reference","title":"Memory Pool","text":"# Pool statistics\nstats = memory_pool_stats()\n\n# Clear cached memory\nclear_memory_pool!()\n\n# Allocate from pool\nbuffer = pool_allocate(Float64, 1024)\npool_release!(buffer)","category":"section"},{"location":"api/gpu/#Pinned-Memory","page":"GPU API Reference","title":"Pinned Memory","text":"# Get pinned buffer for async transfers\nbuffer = get_pinned_buffer(Float64, size)\n\n# Async copy operations\nasync_copy_to_gpu!(gpu_dest, pinned_src)\nasync_copy_to_cpu!(pinned_dest, gpu_src)","category":"section"},{"location":"api/gpu/#Memory-Info","page":"GPU API Reference","title":"Memory Info","text":"# GPU memory status\ninfo = gpu_memory_info()\n# Returns: (free_bytes, total_bytes, used_bytes)\n\n# Check if allocation is possible\ncan_alloc = check_gpu_memory(required_bytes)","category":"section"},{"location":"api/gpu/#Stream-Management","page":"GPU API Reference","title":"Stream Management","text":"# Get dedicated streams\ncompute_stream = get_compute_stream()\ntransfer_stream = get_transfer_stream()\n\n# Synchronize all streams\nsync_streams!()","category":"section"},{"location":"api/gpu/#FFT-Plans","page":"GPU API Reference","title":"FFT Plans","text":"","category":"section"},{"location":"api/gpu/#Standard-FFT-Plans","page":"GPU API Reference","title":"Standard FFT Plans","text":"# Create GPU FFT plan\nplan = plan_gpu_fft(arch, size, eltype)\n\n# Execute transforms\ngpu_forward_fft!(output, input, plan)\ngpu_backward_fft!(output, input, plan)\n\n# Async FFT\ngpu_fft_async!(output, input, plan, stream)","category":"section"},{"location":"api/gpu/#Batched-FFT","page":"GPU API Reference","title":"Batched FFT","text":"# Create batched plan\nplan = plan_batched_gpu_fft(arch, batch_size, fft_size, eltype)\n\n# Execute batched transforms\nbatched_fft!(output, input, plan)\nbatched_ifft!(output, input, plan)","category":"section"},{"location":"api/gpu/#DCT-Plans-(Chebyshev)","page":"GPU API Reference","title":"DCT Plans (Chebyshev)","text":"# Create DCT plan for specific dimension\nplan = plan_gpu_dct_dim(arch, full_size, eltype, dim)\n\n# Execute DCT\ngpu_dct_dim!(output, input, plan, Val(:forward))\ngpu_dct_dim!(output, input, plan, Val(:backward))","category":"section"},{"location":"api/gpu/#Mixed-Transform-Plans","page":"GPU API Reference","title":"Mixed Transform Plans","text":"# Create mixed Fourier-Chebyshev plan\nplan = plan_gpu_mixed_transform(arch, bases, size)\n\n# Execute mixed transforms\ngpu_mixed_forward_transform!(output, input, plan)\ngpu_mixed_backward_transform!(output, input, plan)","category":"section"},{"location":"api/gpu/#KernelOperation","page":"GPU API Reference","title":"KernelOperation","text":"Portable kernel wrapper for CPU/GPU:\n\nusing KernelAbstractions\n\n# Define kernel\n@kernel function my_kernel!(y, @Const(x), α)\n    i = @index(Global)\n    @inbounds y[i] = α * x[i]\nend\n\n# Create operation\nmy_op = KernelOperation(my_kernel!) do y, x, α\n    length(y)  # ndrange\nend\n\n# Execute on any architecture\nmy_op(arch, y, x, α)","category":"section"},{"location":"api/gpu/#Built-in-Operations","page":"GPU API Reference","title":"Built-in Operations","text":"Operation Description\nGPU_ADD_OP Element-wise addition\nGPU_SUB_OP Element-wise subtraction\nGPU_MUL_OP Element-wise multiplication\nGPU_SCALE_OP Scalar multiplication\nGPU_AXPY_OP AXPY operation","category":"section"},{"location":"api/gpu/#Distributed-GPU","page":"GPU API Reference","title":"Distributed GPU","text":"","category":"section"},{"location":"api/gpu/#TransposableField","page":"GPU API Reference","title":"TransposableField","text":"# Create transposable field for distributed transforms\ntf = TransposableField(field)\n\n# Distributed transforms with GPU support\ndistributed_forward_transform!(tf)\ndistributed_backward_transform!(tf)\n\n# Access current layout\nlayout = active_layout(tf)  # XLocal, YLocal, or ZLocal\ndata = current_data(tf)","category":"section"},{"location":"api/gpu/#CUDA-Aware-MPI","page":"GPU API Reference","title":"CUDA-Aware MPI","text":"# Check for CUDA-aware MPI\nis_cuda_aware = check_cuda_aware_mpi()\n\n# GPU pack/unpack for transposes\ngpu_pack_for_transpose!(buffer, data, counts, displs, dim, nranks)\ngpu_unpack_from_transpose!(data, buffer, counts, displs, dim, nranks)","category":"section"},{"location":"api/gpu/#Configuration","page":"GPU API Reference","title":"Configuration","text":"","category":"section"},{"location":"api/gpu/#GPU-Config","page":"GPU API Reference","title":"GPU Config","text":"# Initialize GPU configuration\ninit_gpu_config!()\n\n# Get/set configuration\nconfig = GPU_CONFIG\n\n# Tensor core support (Ampere+)\nenable_tensor_cores!()\ndisable_tensor_cores!()","category":"section"},{"location":"api/gpu/#Device-Management","page":"GPU API Reference","title":"Device Management","text":"# Ensure correct device context\nensure_device!(arch)\n\n# For multi-GPU\nCUDA.device!(rank % CUDA.ndevices())","category":"section"},{"location":"api/gpu/#Cache-Management","page":"GPU API Reference","title":"Cache Management","text":"# Clear transform caches\nclear_gpu_transform_cache!()\nclear_batched_fft_cache!()\nclear_gpu_mixed_transform_cache!()\n\n# Get cached plan\nplan = get_gpu_fft_plan(size, eltype)\nplan = get_batched_fft_plan(batch_size, fft_size, eltype)","category":"section"},{"location":"api/gpu/#Tarang.GPU","page":"GPU API Reference","title":"Tarang.GPU","text":"GPU <: AbstractSerialArchitecture\n\nGPU architecture using CUDA.jl for NVIDIA GPUs. Requires CUDA.jl to be loaded for full functionality.\n\nExample\n\nusing CUDA  # Must load CUDA first\narch = GPU()\ndist = Distributor(coordsys; architecture=arch)\n\nNotes\n\nGPU support is optional and loaded via package extension\nIf CUDA.jl is not available, GPU() will throw an error\nFor multi-GPU, use with MPI (one GPU per MPI rank)\n\n\n\n\n\n","category":"type"},{"location":"api/gpu/#Tarang.CPU","page":"GPU API Reference","title":"Tarang.CPU","text":"CPU <: AbstractSerialArchitecture\n\nCPU architecture using Julia's native arrays and threading. This is the default architecture.\n\nExample\n\narch = CPU()\ndist = Distributor(coordsys; architecture=arch)\n\n\n\n\n\n","category":"type"},{"location":"api/gpu/#Tarang.AbstractArchitecture","page":"GPU API Reference","title":"Tarang.AbstractArchitecture","text":"AbstractArchitecture\n\nAbstract supertype for all compute architectures.\n\n\n\n\n\n","category":"type"},{"location":"pages/coordinates/#Coordinates","page":"Coordinates","title":"Coordinates","text":"Coordinates define the spatial dimensions and geometry of your simulation domain.","category":"section"},{"location":"pages/coordinates/#Cartesian-Coordinates","page":"Coordinates","title":"Cartesian Coordinates","text":"For rectangular domains with uniform grid spacing in grid space.\n\nusing Tarang\n\n# 1D\ncoords = CartesianCoordinates(\"x\")\n\n# 2D\ncoords = CartesianCoordinates(\"x\", \"z\")\n\n# 3D\ncoords = CartesianCoordinates(\"x\", \"y\", \"z\")","category":"section"},{"location":"pages/coordinates/#Accessing-Coordinates","page":"Coordinates","title":"Accessing Coordinates","text":"# Get specific coordinate\nx = coords[\"x\"]\nz = coords[\"z\"]\n\n# Iterate over all coordinates\nfor coord in coords\n    println(coord.name)\nend\n\n# Number of dimensions\nndim = length(coords)","category":"section"},{"location":"pages/coordinates/#Coordinate-Properties","page":"Coordinates","title":"Coordinate Properties","text":"coord = coords[\"x\"]\n\ncoord.name      # String: \"x\"\ncoord.index     # Int: position in coordinate tuple\ncoord.system    # Symbol: :cartesian","category":"section"},{"location":"pages/coordinates/#Distributor","page":"Coordinates","title":"Distributor","text":"The Distributor manages MPI process distribution across the domain.\n\n# Create distributor\ndist = Distributor(coords; mesh=(2, 2), dtype=Float64)","category":"section"},{"location":"pages/coordinates/#Parameters","page":"Coordinates","title":"Parameters","text":"coords: Coordinate system\nmesh: Tuple specifying MPI process grid\ndtype: Data type (Float64, Float32)","category":"section"},{"location":"pages/coordinates/#MPI-Process-Mesh","page":"Coordinates","title":"MPI Process Mesh","text":"The mesh determines how processes are arranged:\n\n# 4 processes in 2×2 grid\ndist = Distributor(coords; mesh=(2, 2))\n\n# 8 processes: 4 in x, 2 in z\ndist = Distributor(coords; mesh=(4, 2))\n\n# Serial (single process)\ndist = Distributor(coords; mesh=(1,))\n\nGuidelines:\n\nProduct of mesh dimensions = total MPI processes\nMatch mesh to domain aspect ratio\nBalance communication vs. computation","category":"section"},{"location":"pages/coordinates/#Distributor-Properties","page":"Coordinates","title":"Distributor Properties","text":"dist.coords     # Coordinate system\ndist.comm       # MPI communicator\ndist.rank       # This process's rank\ndist.size       # Total number of processes\ndist.mesh       # Process mesh tuple","category":"section"},{"location":"pages/coordinates/#Domain-Decomposition","page":"Coordinates","title":"Domain Decomposition","text":"","category":"section"},{"location":"pages/coordinates/#Local-vs-Global-Indices","page":"Coordinates","title":"Local vs Global Indices","text":"# Get local indices for this process (internal function)\nlocal_idx = Tarang.local_indices(dist, axis, global_size)\n\n# Example: axis 1 with 128 global points on 4 processes\n# Process 0: 1:32\n# Process 1: 33:64\n# Process 2: 65:96\n# Process 3: 97:128","category":"section"},{"location":"pages/coordinates/#Pencil-Decomposition","page":"Coordinates","title":"Pencil Decomposition","text":"Tarang uses pencil (slab) decomposition for efficient parallel FFTs:\n\n3D domain distributed across 4 processes (2×2 mesh):\n\n    Process 0     Process 1\n    ┌─────────┐  ┌─────────┐\n    │ ▓▓▓▓▓▓▓ │  │ ░░░░░░░ │\n    │ ▓▓▓▓▓▓▓ │  │ ░░░░░░░ │\n    │ ▓▓▓▓▓▓▓ │  │ ░░░░░░░ │\n    └─────────┘  └─────────┘\n    Process 2     Process 3\n    ┌─────────┐  ┌─────────┐\n    │ ▒▒▒▒▒▒▒ │  │ ████████ │\n    │ ▒▒▒▒▒▒▒ │  │ ████████ │\n    │ ▒▒▒▒▒▒▒ │  │ ████████ │\n    └─────────┘  └─────────┘","category":"section"},{"location":"pages/coordinates/#Coordinate-Aware-Operations","page":"Coordinates","title":"Coordinate-Aware Operations","text":"","category":"section"},{"location":"pages/coordinates/#Derivatives","page":"Coordinates","title":"Derivatives","text":"Coordinate names determine derivative operators:\n\n# ∂x, ∂y, ∂z automatically available for Cartesian\nadd_equation!(problem, \"∂t(u) = ∂x(T)\")\n\n# The operator name matches the coordinate name\n# coords[\"x\"] → ∂x(field)\n# coords[\"z\"] → ∂z(field)","category":"section"},{"location":"pages/coordinates/#Grid-Access","page":"Coordinates","title":"Grid Access","text":"# Get grid points for a basis\nx_grid = get_grid(x_basis)  # Returns array of x values\n\n# Get local grid for distributed field\nlocal_grid = get_local_grid(field, axis)","category":"section"},{"location":"pages/coordinates/#Best-Practices","page":"Coordinates","title":"Best Practices","text":"","category":"section"},{"location":"pages/coordinates/#Choosing-Mesh-Dimensions","page":"Coordinates","title":"Choosing Mesh Dimensions","text":"Domain Shape Recommended Mesh\nSquare 2D (n, n)\nWide 2D (2n, n)\nTall 2D (n, 2n)\nCubic 3D (n, n, n)\nChannel 3D (2n, n, n)","category":"section"},{"location":"pages/coordinates/#Memory-Considerations","page":"Coordinates","title":"Memory Considerations","text":"Each process holds global_size / num_processes data\nCommunication overhead scales with surface area between processes\nBalance process count with per-process work","category":"section"},{"location":"pages/coordinates/#See-Also","page":"Coordinates","title":"See Also","text":"Bases: Spectral bases for each coordinate\nDomains: Combining coordinates and bases\nParallelism: MPI details","category":"section"},{"location":"api/coordinates/#Coordinates-API","page":"Coordinates API","title":"Coordinates API","text":"Coordinates define the dimensional structure of your problem domain. Tarang.jl supports Cartesian, spherical, and polar coordinate systems.","category":"section"},{"location":"api/coordinates/#Docstrings","page":"Coordinates API","title":"Docstrings","text":"","category":"section"},{"location":"api/coordinates/#Coordinate-Systems","page":"Coordinates API","title":"Coordinate Systems","text":"","category":"section"},{"location":"api/coordinates/#CartesianCoordinates","page":"Coordinates API","title":"CartesianCoordinates","text":"Cartesian coordinate system for rectangular domains.\n\nConstructor:\n\nCartesianCoordinates(names::String...)\n\nArguments:\n\nnames: Coordinate dimension names (e.g., \"x\", \"y\", \"z\")\n\nExamples:\n\n# 1D Cartesian\ncoords = CartesianCoordinates(\"x\")\n\n# 2D Cartesian\ncoords = CartesianCoordinates(\"x\", \"z\")\n\n# 3D Cartesian\ncoords = CartesianCoordinates(\"x\", \"y\", \"z\")\n\nProperties:\n\ncoords.names        # Tuple of coordinate names\ncoords.dim          # Number of dimensions\ncoords.coords       # Dictionary: name => Coordinate object\n\nMethods:","category":"section"},{"location":"api/coordinates/#Accessing-Coordinates","page":"Coordinates API","title":"Accessing Coordinates","text":"# Get coordinate by name\nx_coord = coords[\"x\"]\n\n# Get coordinate by index\nx_coord = coords[1]\n\n# Iterate over coordinates\nfor coord in coords\n    println(coord.name)\nend","category":"section"},{"location":"api/coordinates/#Unit-Vectors","page":"Coordinates API","title":"Unit Vectors","text":"# Get unit vector for coordinate direction\nex = unit_vector(coords, \"x\")\ney = unit_vector(coords, \"y\")\nez = unit_vector(coords, \"z\")\n\n# Use in equations\n# Example: buoyancy force in z-direction\nadd_equation!(problem, \"∂t(u) = ... + Ra*Pr*T*ez\")\n\n","category":"section"},{"location":"api/coordinates/#SphericalCoordinates","page":"Coordinates API","title":"SphericalCoordinates","text":"Spherical coordinate system (r, θ, φ) for problems with spherical geometry.\n\nnote: Note\nSphericalCoordinates is not yet implemented in Tarang.jl. This is planned for a future release.\n\nConstructor:\n\nSphericalCoordinates()\nSphericalCoordinates(names::Tuple{String,String,String})\n\nDefault names: (\"r\", \"theta\", \"phi\")\n\nExamples:\n\n# Default spherical coordinates\ncoords = SphericalCoordinates()\n\n# Custom names\ncoords = SphericalCoordinates((\"radius\", \"theta\", \"phi\"))\n\nCoordinate ranges:\n\nr: [0, ∞)\nθ: [0, π]\nφ: [0, 2π]\n\nMetric tensor: Available for computing gradient, divergence, curl in spherical coordinates\n\n","category":"section"},{"location":"api/coordinates/#PolarCoordinates","page":"Coordinates API","title":"PolarCoordinates","text":"Polar coordinate system (r, φ) for 2D axisymmetric problems.\n\nnote: Note\nPolarCoordinates is not yet implemented in Tarang.jl. This is planned for a future release.\n\nConstructor:\n\nPolarCoordinates()\nPolarCoordinates(names::Tuple{String,String})\n\nDefault names: (\"r\", \"phi\")\n\nExamples:\n\n# Default polar coordinates\ncoords = PolarCoordinates()\n\n# Custom names\ncoords = PolarCoordinates((\"radius\", \"angle\"))\n\nCoordinate ranges:\n\nr: [0, ∞)\nφ: [0, 2π]\n\n","category":"section"},{"location":"api/coordinates/#Coordinate-Object","page":"Coordinates API","title":"Coordinate Object","text":"Individual coordinate dimension.\n\nProperties:\n\ncoord.name          # String: Coordinate name\ncoord.index         # Int: Position in coordinate system\ncoord.system        # CoordinateSystem: Parent system\n\nExample:\n\ncoords = CartesianCoordinates(\"x\", \"y\", \"z\")\nx = coords[\"x\"]\n\nprintln(x.name)     # \"x\"\nprintln(x.index)    # 1\n\n","category":"section"},{"location":"api/coordinates/#Distributor","page":"Coordinates API","title":"Distributor","text":"The distributor manages MPI process distribution across coordinate dimensions.\n\nConstructor:\n\nDistributor(\n    coords::CoordinateSystem;\n    mesh::Tuple{Int,...},\n    device::String=\"cpu\"\n)\n\nArguments:\n\ncoords: Coordinate system\nmesh: MPI process mesh (one value per dimension)\n\nExamples:\n\n# 2D distribution with 2×2 process mesh\ncoords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords, mesh=(2, 2))\n\n# 3D distribution with 4×4×2 process mesh\ncoords = CartesianCoordinates(\"x\", \"y\", \"z\")\ndist = Distributor(coords, mesh=(4, 4, 2))\n\nProperties:\n\ndist.coords         # CoordinateSystem\ndist.mesh           # Tuple: Process mesh dimensions\ndist.comm           # MPI.Comm: MPI communicator\ndist.rank           # Int: MPI rank\ndist.size           # Int: Total number of processes\n\nMethods:","category":"section"},{"location":"api/coordinates/#Process-Information","page":"Coordinates API","title":"Process Information","text":"# Get process rank\nrank = get_rank(dist)\n\n# Get total number of processes\nnprocs = get_size(dist)\n\n# Check if this is the root process\nis_root = (get_rank(dist) == 0)","category":"section"},{"location":"api/coordinates/#Domain-Decomposition","page":"Coordinates API","title":"Domain Decomposition","text":"# Get local domain bounds for this process\nlocal_bounds = get_local_bounds(dist, basis)\n\n# Get global domain size\nglobal_size = get_global_size(dist, basis)\n\n","category":"section"},{"location":"api/coordinates/#Mesh-Configuration","page":"Coordinates API","title":"Mesh Configuration","text":"","category":"section"},{"location":"api/coordinates/#Choosing-Process-Mesh","page":"Coordinates API","title":"Choosing Process Mesh","text":"The process mesh determines how data is distributed across MPI processes.\n\nGeneral rules:\n\nProduct of mesh dimensions must equal number of MPI processes\nMatch mesh aspect ratio to domain aspect ratio\nUse powers of 2 when possible for optimal FFT performance\nBalance computation and communication\n\nExamples:\n\n# Square 2D mesh (recommended for square domains)\nmesh=(4, 4)  # 16 processes\n\n# Rectangular 2D mesh (for wide domains)\nmesh=(8, 2)  # 16 processes, more in x-direction\n\n# 3D mesh (for cubic domains)\nmesh=(4, 4, 4)  # 64 processes\n\n# 3D mesh (for stratified flows, thin in vertical)\nmesh=(8, 8, 2)  # 128 processes, fewer in z-direction","category":"section"},{"location":"api/coordinates/#Process-Mesh-Strategies","page":"Coordinates API","title":"Process Mesh Strategies","text":"","category":"section"},{"location":"api/coordinates/#2D-Problems","page":"Coordinates API","title":"2D Problems","text":"# Balanced decomposition (default)\ncoords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords, mesh=(4, 4))\n\n# More processes in horizontal direction (wide domain)\ndist = Distributor(coords, mesh=(8, 2))\n\n# More processes in vertical direction (tall domain)\ndist = Distributor(coords, mesh=(2, 8))","category":"section"},{"location":"api/coordinates/#3D-Problems","page":"Coordinates API","title":"3D Problems","text":"# Cubic mesh (isotropic domains)\ncoords = CartesianCoordinates(\"x\", \"y\", \"z\")\ndist = Distributor(coords, mesh=(4, 4, 4))\n\n# Anisotropic mesh (stratified flows)\n# More processes in horizontal directions\ndist = Distributor(coords, mesh=(8, 8, 2))\n\n# Channel flow mesh\n# More processes in streamwise and spanwise\ndist = Distributor(coords, mesh=(8, 4, 2))\n\n","category":"section"},{"location":"api/coordinates/#Pencil-Decomposition","page":"Coordinates API","title":"Pencil Decomposition","text":"Tarang.jl uses pencil decomposition for 3D problems, where data is distributed in two dimensions while remaining contiguous in one dimension.","category":"section"},{"location":"api/coordinates/#Pencil-Orientations","page":"Coordinates API","title":"Pencil Orientations","text":"For 3D domains, data can be organized in different pencil configurations:\n\nX-pencils: Contiguous in x, distributed in y and z\nY-pencils: Contiguous in y, distributed in x and z\nZ-pencils: Contiguous in z, distributed in x and y\n\nExample:\n\n# 3D domain with 4×4×2 process mesh\ncoords = CartesianCoordinates(\"x\", \"y\", \"z\")\ndist = Distributor(coords, mesh=(4, 4, 2))\n\n# PencilArrays automatically handles pencil rotations\n# during FFT operations","category":"section"},{"location":"api/coordinates/#Transpose-Operations","page":"Coordinates API","title":"Transpose Operations","text":"Pencil decomposition requires transpose operations to switch between orientations:\n\n# Configured in tarang.toml\n[parallelism]\nTRANSPOSE_LIBRARY = \"PENCIL\"  # Use PencilArrays\nGROUP_TRANSPOSES = true       # Batch transposes for efficiency\n\n","category":"section"},{"location":"api/coordinates/#Usage-Examples","page":"Coordinates API","title":"Usage Examples","text":"","category":"section"},{"location":"api/coordinates/#Basic-Setup","page":"Coordinates API","title":"Basic Setup","text":"using Tarang, MPI\n\nMPI.Init()\n\n# Define coordinate system\ncoords = CartesianCoordinates(\"x\", \"y\", \"z\")\n\n# Create distributor with process mesh\ndist = Distributor(coords, mesh=(2, 2, 2))\n\n# Verify setup\nif get_rank(dist) == 0\n    println(\"Running on $(get_size(dist)) processes\")\n    println(\"Process mesh: $(dist.mesh)\")\nend","category":"section"},{"location":"api/coordinates/#Multi-Resolution-Studies","page":"Coordinates API","title":"Multi-Resolution Studies","text":"# Create multiple distributors for different resolutions\ncoords = CartesianCoordinates(\"x\", \"z\")\n\n# Coarse resolution\ndist_coarse = Distributor(coords, mesh=(2, 2))\n\n# Fine resolution\ndist_fine = Distributor(coords, mesh=(4, 4))\n\n# Run simulation at each resolution\n# ... (use different dist for each case)","category":"section"},{"location":"api/coordinates/#Custom-Coordinate-Names","page":"Coordinates API","title":"Custom Coordinate Names","text":"# Use physics-appropriate names\ncoords = CartesianCoordinates(\"streamwise\", \"spanwise\", \"wall_normal\")\ndist = Distributor(coords, mesh=(8, 4, 2))\n\n# Access by custom names\nx = coords[\"streamwise\"]\ny = coords[\"spanwise\"]\nz = coords[\"wall_normal\"]\n\n","category":"section"},{"location":"api/coordinates/#Advanced-Topics","page":"Coordinates API","title":"Advanced Topics","text":"","category":"section"},{"location":"api/coordinates/#Custom-MPI-Communicators","page":"Coordinates API","title":"Custom MPI Communicators","text":"# Use custom MPI communicator\ncustom_comm = MPI.Comm_split(MPI.COMM_WORLD, color, key)\ndist = Distributor(coords, mesh=(2, 2), comm=custom_comm)","category":"section"},{"location":"api/coordinates/#Load-Balancing","page":"Coordinates API","title":"Load Balancing","text":"# Check load distribution\nif get_rank(dist) == 0\n    for rank in 0:(get_size(dist)-1)\n        local_size = get_local_size(dist, basis, rank)\n        println(\"Rank $rank: $local_size\")\n    end\nend\n\n","category":"section"},{"location":"api/coordinates/#Performance-Tips","page":"Coordinates API","title":"Performance Tips","text":"Use power-of-2 mesh dimensions for optimal FFT performance\nMatch mesh to domain aspect ratio for balanced load\nTest different meshes to find optimal configuration\nMonitor communication overhead with profiling tools\nConsider memory constraints when choosing mesh\n\n","category":"section"},{"location":"api/coordinates/#See-Also","page":"Coordinates API","title":"See Also","text":"Bases: Spectral basis functions for each coordinate\nDomains: Combining coordinates and bases into domains\nParallelism Guide: Detailed MPI configuration\nConfiguration: Process mesh tuning","category":"section"},{"location":"api/coordinates/#Tarang.CartesianCoordinates","page":"Coordinates API","title":"Tarang.CartesianCoordinates","text":"CartesianCoordinates\n\nCartesian coordinate system with named coordinates. Following implementation in coords:159-189.\n\nConstructor\n\nCartesianCoordinates(names...; right_handed=true)\n\nArguments\n\nnames: Names for each coordinate (e.g., \"x\", \"y\", \"z\")\nright_handed: Whether the coordinate system is right-handed (only used for 3D)\n\nExamples\n\n# 1D\ncoords = CartesianCoordinates(\"x\")\n\n# 2D\ncoords = CartesianCoordinates(\"x\", \"z\")\n\n# 3D\ncoords = CartesianCoordinates(\"x\", \"y\", \"z\")\ncoords[\"x\"]  # Get x coordinate\ncoords[1]    # Get first coordinate\n\n\n\n\n\n","category":"type"},{"location":"api/coordinates/#Tarang.coords-Tuple{CartesianCoordinates}","page":"Coordinates API","title":"Tarang.coords","text":"coords(coordsys::CoordinateSystem)\n\nReturn tuple of Coordinate objects for this coordinate system. Following pattern.\n\n\n\n\n\n","category":"method"},{"location":"examples/eigenvalue_analysis/#Eigenvalue-Analysis-Examples","page":"Eigenvalue Analysis Examples","title":"Eigenvalue Analysis Examples","text":"Collection of linear stability and eigenvalue problem examples with Tarang.jl.","category":"section"},{"location":"examples/eigenvalue_analysis/#Linear-Stability-Overview","page":"Eigenvalue Analysis Examples","title":"Linear Stability Overview","text":"Eigenvalue problems determine the stability of base states by solving:\n\nA mathbfx = sigma B mathbfx\n\nwhere σ is the eigenvalue (growth rate + frequency).","category":"section"},{"location":"examples/eigenvalue_analysis/#Rayleigh-Bénard-Stability","page":"Eigenvalue Analysis Examples","title":"Rayleigh-Bénard Stability","text":"Critical Rayleigh number for convection onset.\n\nusing Tarang, MPI\nMPI.Init()\n\n# Parameters\nPr = 1.0\nk = 3.117  # Critical wavenumber\n\n# Domain\ncoords = CartesianCoordinates(\"z\")\ndist = Distributor(coords; mesh=(1,), dtype=Float64)\nz_basis = ChebyshevT(coords[\"z\"]; size=64, bounds=(0.0, 1.0))\n\n# Fields (complex amplitudes)\nu_hat = ScalarField(dist, \"u_hat\", (z_basis,), ComplexF64)\nw_hat = ScalarField(dist, \"w_hat\", (z_basis,), ComplexF64)\np_hat = ScalarField(dist, \"p_hat\", (z_basis,), ComplexF64)\nT_hat = ScalarField(dist, \"T_hat\", (z_basis,), ComplexF64)\n\n# EVP\nevp = Tarang.EVP([u_hat, w_hat, p_hat, T_hat]; eigenvalue=:sigma)\nevp.parameters[\"Pr\"] = Pr\nevp.parameters[\"k2\"] = k^2\n\n# Scan Ra to find critical value\nfunction find_critical_Ra(evp, Ra_range)\n    for Ra in Ra_range\n        evp.parameters[\"Ra\"] = Ra\n        solver = Tarang.EigenvalueSolver(evp; nev=5, which=\"LR\")\n        eigenvalues, _ = Tarang.solve!(solver)\n        max_growth = maximum(real.(eigenvalues))\n\n        println(\"Ra = $Ra, σ_max = $max_growth\")\n\n        if max_growth > 0\n            return Ra  # Found critical Ra\n        end\n    end\nend\n\nRa_crit = find_critical_Ra(evp, 1000:100:2000)\nprintln(\"Critical Ra ≈ $Ra_crit\")\n\nMPI.Finalize()","category":"section"},{"location":"examples/eigenvalue_analysis/#Orr-Sommerfeld-(Plane-Poiseuille)","page":"Eigenvalue Analysis Examples","title":"Orr-Sommerfeld (Plane Poiseuille)","text":"Stability of channel flow.\n\n# Base flow\nU(z) = 1 - (2z - 1)^2  # Parabolic profile\nU_pp(z) = -8.0          # U''\n\n# Parameters\nRe = 5000\nk = 1.0\nk2 = k^2\n\n# EVP for complex wave speed c\nevp = Tarang.EVP([psi_hat]; eigenvalue=:c)\n\nTarang.add_equation!(evp, \"\"\"\n    c*(∂z(∂z(psi_hat)) - k2*psi_hat) =\n    U*(∂z(∂z(psi_hat)) - k2*psi_hat) - U_pp*psi_hat +\n    (1im/(Re*k))*(∂z(∂z(∂z(∂z(psi_hat)))) - 2*k2*∂z(∂z(psi_hat)) + k4*psi_hat)\n\"\"\")\n\n# No-slip: ψ = ∂ψ/∂z = 0 at walls\nTarang.add_equation!(evp, \"psi_hat(z=0) = 0\")\nTarang.add_equation!(evp, \"psi_hat(z=1) = 0\")\nTarang.add_equation!(evp, \"∂z(psi_hat)(z=0) = 0\")\nTarang.add_equation!(evp, \"∂z(psi_hat)(z=1) = 0\")","category":"section"},{"location":"examples/eigenvalue_analysis/#Neutral-Curves","page":"Eigenvalue Analysis Examples","title":"Neutral Curves","text":"Compute stability boundary in parameter space.\n\nfunction compute_neutral_curve(evp, k_range, Ra_range)\n    k_neutral = Float64[]\n    Ra_neutral = Float64[]\n\n    for k in k_range\n        evp.parameters[\"k\"] = k\n        evp.parameters[\"k2\"] = k^2\n\n        # Binary search for neutral Ra\n        Ra_lo, Ra_hi = Ra_range\n        while Ra_hi - Ra_lo > 10\n            Ra_mid = (Ra_lo + Ra_hi) / 2\n            evp.parameters[\"Ra\"] = Ra_mid\n\n            solver = Tarang.EigenvalueSolver(evp; nev=3, which=\"LR\")\n            eigenvalues, _ = Tarang.solve!(solver)\n            growth = maximum(real.(eigenvalues))\n\n            if growth > 0\n                Ra_hi = Ra_mid\n            else\n                Ra_lo = Ra_mid\n            end\n        end\n\n        push!(k_neutral, k)\n        push!(Ra_neutral, (Ra_lo + Ra_hi) / 2)\n    end\n\n    return k_neutral, Ra_neutral\nend\n\nk_range = range(2.0, 4.5, length=20)\nk_n, Ra_n = compute_neutral_curve(evp, k_range, (1000, 3000))\n\n# Find minimum (critical point)\nidx = argmin(Ra_n)\nk_crit, Ra_crit = k_n[idx], Ra_n[idx]","category":"section"},{"location":"examples/eigenvalue_analysis/#Taylor-Couette-Stability","page":"Eigenvalue Analysis Examples","title":"Taylor-Couette Stability","text":"Rotating cylinder flow stability.\n\n# Parameters\neta = 0.5  # Radius ratio\nOmega_i = 1.0  # Inner cylinder rotation\nOmega_o = 0.0  # Outer cylinder rotation\nRe = 100\n\n# Cylindrical coordinates (simplified to 1D)\nevp = Tarang.EVP([u_r, u_theta, u_z, p]; eigenvalue=:sigma)\n\n# Base flow: Couette profile\n# Add perturbation equations with centrifugal effects","category":"section"},{"location":"examples/eigenvalue_analysis/#Thermal-Instabilities","page":"Eigenvalue Analysis Examples","title":"Thermal Instabilities","text":"","category":"section"},{"location":"examples/eigenvalue_analysis/#Marangoni-Convection","page":"Eigenvalue Analysis Examples","title":"Marangoni Convection","text":"Surface tension driven flow.\n\nevp.parameters[\"Ma\"] = 1000  # Marangoni number\nevp.parameters[\"Bi\"] = 1.0   # Biot number\n\n# Free surface boundary conditions\n# Include surface tension gradient terms","category":"section"},{"location":"examples/eigenvalue_analysis/#Double-Diffusive-Convection","page":"Eigenvalue Analysis Examples","title":"Double-Diffusive Convection","text":"Two buoyancy sources (temperature and salinity).\n\nevp.parameters[\"Ra_T\"] = 1e6   # Thermal Rayleigh\nevp.parameters[\"Ra_S\"] = 5e5   # Solutal Rayleigh\nevp.parameters[\"tau\"] = 0.01   # Diffusivity ratio\n\n# Additional equation for salinity perturbation","category":"section"},{"location":"examples/eigenvalue_analysis/#Visualizing-Eigenmodes","page":"Eigenvalue Analysis Examples","title":"Visualizing Eigenmodes","text":"function plot_eigenmode(eigenvector, z_grid)\n    using Plots\n\n    u = real.(eigenvector[\"u_hat\"])\n    w = real.(eigenvector[\"w_hat\"])\n    T = real.(eigenvector[\"T_hat\"])\n\n    # Normalize\n    max_val = maximum(abs.([u; w; T]))\n    u ./= max_val\n    w ./= max_val\n    T ./= max_val\n\n    p = plot(layout=(1,3), size=(900,300))\n    plot!(p[1], u, z_grid, xlabel=\"û\", ylabel=\"z\")\n    plot!(p[2], w, z_grid, xlabel=\"ŵ\")\n    plot!(p[3], T, z_grid, xlabel=\"T̂\")\n\n    return p\nend","category":"section"},{"location":"examples/eigenvalue_analysis/#Solver-Options","page":"Eigenvalue Analysis Examples","title":"Solver Options","text":"","category":"section"},{"location":"examples/eigenvalue_analysis/#Finding-Specific-Eigenvalues","page":"Eigenvalue Analysis Examples","title":"Finding Specific Eigenvalues","text":"# Most unstable (largest real part)\nsolver = Tarang.EigenvalueSolver(evp; nev=10, which=\"LR\")\n\n# Largest magnitude\nsolver = Tarang.EigenvalueSolver(evp; nev=10, which=\"LM\")\n\n# Near a target value\nsolver = Tarang.EigenvalueSolver(evp; nev=5, target=0.1+1.5im)\n\n# Most oscillatory (largest imaginary)\nsolver = Tarang.EigenvalueSolver(evp; nev=10, which=\"LI\")","category":"section"},{"location":"examples/eigenvalue_analysis/#Convergence","page":"Eigenvalue Analysis Examples","title":"Convergence","text":"solver = Tarang.EigenvalueSolver(evp;\n    nev=20,\n    which=\"LR\",\n    tolerance=1e-12,\n    max_iterations=2000\n)","category":"section"},{"location":"examples/eigenvalue_analysis/#Tips","page":"Eigenvalue Analysis Examples","title":"Tips","text":"","category":"section"},{"location":"examples/eigenvalue_analysis/#Resolution","page":"Eigenvalue Analysis Examples","title":"Resolution","text":"Start coarse (N=32), refine until eigenvalues converge\nChebyshev provides exponential convergence\nBoundary layer modes need more resolution","category":"section"},{"location":"examples/eigenvalue_analysis/#Spurious-Modes","page":"Eigenvalue Analysis Examples","title":"Spurious Modes","text":"Check mode structure (spurious modes often oscillate wildly)\nVerify with different N\nCheck energy balance","category":"section"},{"location":"examples/eigenvalue_analysis/#Physical-Validation","page":"Eigenvalue Analysis Examples","title":"Physical Validation","text":"Compare with known analytical results\nCheck limiting cases\nVerify neutral curve shape","category":"section"},{"location":"examples/eigenvalue_analysis/#See-Also","page":"Eigenvalue Analysis Examples","title":"See Also","text":"Eigenvalue Problems Tutorial\nAPI: Solvers\nExample Gallery","category":"section"},{"location":"pages/testing/#Testing","page":"Testing","title":"Testing","text":"Guide to running and writing tests for Tarang.jl.","category":"section"},{"location":"pages/testing/#Running-Tests","page":"Testing","title":"Running Tests","text":"","category":"section"},{"location":"pages/testing/#Full-Test-Suite","page":"Testing","title":"Full Test Suite","text":"julia --project=. -e 'using Pkg; Pkg.test()'","category":"section"},{"location":"pages/testing/#Specific-Test-File","page":"Testing","title":"Specific Test File","text":"julia --project=. test/test_specific.jl","category":"section"},{"location":"pages/testing/#With-MPI","page":"Testing","title":"With MPI","text":"mpiexec -n 4 julia --project=. test/runtests.jl","category":"section"},{"location":"pages/testing/#Test-Structure","page":"Testing","title":"Test Structure","text":"test/\n├── runtests.jl              # Main test runner\n├── test_cfl.jl              # CFL condition tests\n├── test_domain_metadata.jl  # Domain tests\n├── test_solvers.jl          # Solver tests\n├── test_flow_tools.jl       # Analysis tools\n├── test_quick_domains.jl    # Domain helpers\n├── test_plot_tools.jl       # Visualization\n└── test_compatibility.jl    # Compatibility tests","category":"section"},{"location":"pages/testing/#Writing-Tests","page":"Testing","title":"Writing Tests","text":"","category":"section"},{"location":"pages/testing/#Basic-Test","page":"Testing","title":"Basic Test","text":"using Test\nusing Tarang\n\n@testset \"My Feature\" begin\n    # Setup\n    coords = CartesianCoordinates(\"x\")\n    dist = Distributor(coords; mesh=(1,), dtype=Float64)\n\n    # Test\n    @test dist.size == 1\n    @test dist.rank == 0\nend","category":"section"},{"location":"pages/testing/#Testing-Fields","page":"Testing","title":"Testing Fields","text":"@testset \"ScalarField\" begin\n    coords = CartesianCoordinates(\"x\")\n    dist = Distributor(coords; mesh=(1,), dtype=Float64)\n    basis = RealFourier(coords[\"x\"]; size=8, bounds=(0.0, 2π))\n\n    field = ScalarField(dist, \"T\", (basis,), Float64)\n\n    # Test creation\n    @test field.name == \"T\"\n    @test field.dtype == Float64\n\n    # Test data\n    Tarang.ensure_layout!(field, :g)\n    field.data_g .= 1.0\n    @test all(field.data_g .== 1.0)\nend","category":"section"},{"location":"pages/testing/#Testing-Transforms","page":"Testing","title":"Testing Transforms","text":"@testset \"Transforms\" begin\n    # Setup\n    field = ScalarField(dist, \"f\", (basis,), Float64)\n\n    # Initialize in grid space\n    Tarang.ensure_layout!(field, :g)\n    field.data_g .= sin.(x_grid)\n\n    # Transform to spectral\n    Tarang.ensure_layout!(field, :c)\n\n    # Transform back\n    Tarang.ensure_layout!(field, :g)\n\n    # Check roundtrip\n    @test field.data_g ≈ sin.(x_grid) atol=1e-10\nend","category":"section"},{"location":"pages/testing/#Testing-Solvers","page":"Testing","title":"Testing Solvers","text":"@testset \"IVP Solver\" begin\n    # Setup problem\n    problem = IVP([field])\n    Tarang.add_equation!(problem, \"∂t(f) = -f\")\n\n    # Create solver\n    solver = InitialValueSolver(problem, RK222(); dt=0.01)\n\n    # Run\n    step!(solver)\n\n    # Check\n    @test solver.sim_time ≈ 0.01\n    @test solver.iteration == 1\nend","category":"section"},{"location":"pages/testing/#Test-Patterns","page":"Testing","title":"Test Patterns","text":"","category":"section"},{"location":"pages/testing/#Analytical-Comparison","page":"Testing","title":"Analytical Comparison","text":"@testset \"Analytical Solution\" begin\n    # Solve diffusion equation\n    # Compare with exact solution\n    exact = exp.(-kappa * k^2 * t) .* initial\n\n    @test maximum(abs.(numerical .- exact)) < 1e-6\nend","category":"section"},{"location":"pages/testing/#Convergence-Test","page":"Testing","title":"Convergence Test","text":"@testset \"Convergence\" begin\n    errors = Float64[]\n\n    for N in [16, 32, 64, 128]\n        # Solve at resolution N\n        error = compute_error(N)\n        push!(errors, error)\n    end\n\n    # Check spectral convergence\n    for i in 2:length(errors)\n        @test errors[i] < errors[i-1] / 2\n    end\nend","category":"section"},{"location":"pages/testing/#MPI-Test","page":"Testing","title":"MPI Test","text":"@testset \"MPI Parallelism\" begin\n    MPI.Init()\n\n    rank = MPI.Comm_rank(MPI.COMM_WORLD)\n    size = MPI.Comm_size(MPI.COMM_WORLD)\n\n    # Test distributed computation\n    local_sum = compute_local()\n    global_sum = MPI.Allreduce(local_sum, MPI.SUM, MPI.COMM_WORLD)\n\n    @test global_sum ≈ expected_total\n\n    MPI.Finalize()\nend","category":"section"},{"location":"pages/testing/#Test-Coverage","page":"Testing","title":"Test Coverage","text":"","category":"section"},{"location":"pages/testing/#Generate-Coverage-Report","page":"Testing","title":"Generate Coverage Report","text":"using Coverage\n\n# Run tests with coverage\ncoverage = process_folder()\n\n# Print summary\nprintln(coverage)","category":"section"},{"location":"pages/testing/#Continuous-Integration","page":"Testing","title":"Continuous Integration","text":"Tests run automatically on:\n\nPull requests\nPushes to main\nScheduled (nightly)","category":"section"},{"location":"pages/testing/#See-Also","page":"Testing","title":"See Also","text":"Contributing: Development guidelines\nArchitecture: Code structure","category":"section"},{"location":"pages/solvers/#Solvers","page":"Solvers","title":"Solvers","text":"Solvers integrate PDEs in time or solve for steady states.","category":"section"},{"location":"pages/solvers/#InitialValueSolver","page":"Solvers","title":"InitialValueSolver","text":"For time-dependent problems (IVP).\n\nusing Tarang\n\n# Create solver\nsolver = InitialValueSolver(problem, RK222(); dt=0.001)\n\n# Time stepping\nwhile solver.sim_time < t_end\n    step!(solver)\nend","category":"section"},{"location":"pages/solvers/#Properties","page":"Solvers","title":"Properties","text":"solver.problem       # The IVP problem\nsolver.timestepper   # Time integration scheme\nsolver.dt            # Current timestep\nsolver.sim_time      # Current simulation time\nsolver.iteration     # Iteration count","category":"section"},{"location":"pages/solvers/#Methods","page":"Solvers","title":"Methods","text":"# Advance one step\nstep!(solver)           # Use solver.dt\nstep!(solver, dt)       # Use specified dt\n\n# Check stopping conditions\nproceed(solver)         # Returns true if should continue","category":"section"},{"location":"pages/solvers/#BoundaryValueSolver","page":"Solvers","title":"BoundaryValueSolver","text":"For steady linear problems (LBVP).\n\n# Create solver\nsolver = BoundaryValueSolver(problem)\n\n# Solve\nsolve!(solver)\n\n# Solution is in the field variables","category":"section"},{"location":"pages/solvers/#NonlinearBoundaryValueSolver","page":"Solvers","title":"NonlinearBoundaryValueSolver","text":"For steady nonlinear problems (NLBVP).\n\n# Create solver with Newton-Raphson\nsolver = NonlinearBoundaryValueSolver(problem;\n    tolerance=1e-8,\n    max_iterations=100,\n    damping=1.0\n)\n\n# Solve\nsuccess = solve!(solver)\n\nif success\n    println(\"Converged in $(solver.iterations) iterations\")\nend","category":"section"},{"location":"pages/solvers/#EigenvalueSolver","page":"Solvers","title":"EigenvalueSolver","text":"For eigenvalue problems (EVP).\n\n# Create solver\nsolver = EigenvalueSolver(problem;\n    nev=10,           # Number of eigenvalues\n    which=\"LR\",       # Largest real part\n    target=0.0+0.0im  # Target for shift-invert\n)\n\n# Solve\neigenvalues, eigenvectors = solve!(solver)","category":"section"},{"location":"pages/solvers/#Which-Eigenvalues","page":"Solvers","title":"Which Eigenvalues","text":"\"LM\": Largest magnitude\n\"SM\": Smallest magnitude\n\"LR\": Largest real part (most unstable)\n\"SR\": Smallest real part\n\"LI\": Largest imaginary part\n\"SI\": Smallest imaginary part","category":"section"},{"location":"pages/solvers/#Time-Steppers","page":"Solvers","title":"Time Steppers","text":"","category":"section"},{"location":"pages/solvers/#IMEX-Runge-Kutta","page":"Solvers","title":"IMEX Runge-Kutta","text":"RK111()  # 1st order, 1 stage\nRK222()  # 2nd order, 2 stages (recommended)\nRK443()  # 3rd order, 4 stages (higher accuracy)","category":"section"},{"location":"pages/solvers/#IMEX-Multistep-Methods","page":"Solvers","title":"IMEX Multistep Methods","text":"For problems with stiff linear terms:\n\nCNAB1()  # Crank-Nicolson Adams-Bashforth, 1st order\nCNAB2()  # Crank-Nicolson Adams-Bashforth, 2nd order\n\nSBDF1()  # Semi-implicit BDF, 1st order\nSBDF2()  # Semi-implicit BDF, 2nd order\nSBDF3()  # Semi-implicit BDF, 3rd order\nSBDF4()  # Semi-implicit BDF, 4th order","category":"section"},{"location":"pages/solvers/#Choosing-a-Timestepper","page":"Solvers","title":"Choosing a Timestepper","text":"Problem Type Recommended\nGeneral purpose RK222, RK443\nMildly stiff CNAB2, SBDF2\nVery stiff SBDF3, SBDF4","category":"section"},{"location":"pages/solvers/#Adaptive-Time-Stepping","page":"Solvers","title":"Adaptive Time Stepping","text":"","category":"section"},{"location":"pages/solvers/#CFL-Condition","page":"Solvers","title":"CFL Condition","text":"using Tarang\n\n# Create CFL calculator\ncfl = CFL(problem;\n    safety=0.5,      # Safety factor\n    max_change=1.5,  # Max dt increase per step\n    min_change=0.5   # Max dt decrease per step\n)\n\n# Register velocity field\nadd_velocity!(cfl, u)\n\n# Set limits\ncfl.max_dt = 0.01\ncfl.min_dt = 1e-8\n\n# In time loop\nwhile solver.sim_time < t_end\n    dt = compute_timestep(cfl)\n    step!(solver, dt)\nend","category":"section"},{"location":"pages/solvers/#CFL-Parameters","page":"Solvers","title":"CFL Parameters","text":"Parameter Typical Value Description\nsafety 0.3-0.5 Lower = more stable\nmax_change 1.2-2.0 Smooth dt changes\nmin_change 0.5 Prevent sudden drops","category":"section"},{"location":"pages/solvers/#Stopping-Conditions","page":"Solvers","title":"Stopping Conditions","text":"# Set stop conditions\nsolver.stop_sim_time = 10.0      # Stop at t=10\nsolver.stop_wall_time = 3600.0   # Stop after 1 hour\nsolver.stop_iteration = 10000    # Stop after 10000 steps\n\n# Use proceed() to check\nwhile proceed(solver)\n    step!(solver)\nend","category":"section"},{"location":"pages/solvers/#Complete-Example","page":"Solvers","title":"Complete Example","text":"using Tarang\nusing MPI\n\nMPI.Init()\n\n# Setup (abbreviated)\n# ... create domain, fields, problem ...\n\n# Solver\nsolver = InitialValueSolver(problem, RK222(); dt=1e-3)\n\n# CFL\ncfl = CFL(problem, safety=0.5)\nadd_velocity!(cfl, u)\n\n# Stop conditions\nsolver.stop_sim_time = 10.0\n\n# Main loop\nwhile proceed(solver)\n    dt = compute_timestep(cfl)\n    step!(solver, dt)\n\n    if solver.iteration % 100 == 0\n        println(\"t = $(solver.sim_time), dt = $dt\")\n    end\nend\n\nMPI.Finalize()","category":"section"},{"location":"pages/solvers/#See-Also","page":"Solvers","title":"See Also","text":"Problems: Problem definition\nTimesteppers: Time integration details\nAPI: Solvers: Complete reference","category":"section"},{"location":"api/operators/#Operators-API","page":"Operators API","title":"Operators API","text":"Operators compute derivatives and other mathematical operations on fields. Tarang.jl provides a symbolic syntax for natural mathematical notation in equations.","category":"section"},{"location":"api/operators/#Overview","page":"Operators API","title":"Overview","text":"Tarang.jl supports:\n\nDifferential operators: grad (∇), div, curl, lap (Δ, ∇²)\nCoordinate derivatives: ∂x, ∂y, ∂z, ∂r, etc.\nTime derivatives: ∂t\nField operations: dot (⋅), cross (×)\nCustom operators: User-defined operations","category":"section"},{"location":"api/operators/#Unicode-Operators","page":"Operators API","title":"Unicode Operators","text":"Tarang.jl uses Unicode mathematical symbols for readable, publication-quality code:\n\nSyntax Description Typing\n∇(f) Gradient \\nabla Tab\nΔ(f) or ∇²(f) Laplacian \\Delta Tab\n∂t(f) Time derivative \\partial Tab t\n∂x(f) x-derivative \\partial Tab x\n∂y(f) y-derivative \\partial Tab y\n∂z(f) z-derivative \\partial Tab z\n∂r(f) r-derivative \\partial Tab r\nu ⋅ v Dot product \\cdot Tab\nu × v Cross product \\times Tab\n\nExample - Navier-Stokes equation:\n\nadd_equation!(problem, \"∂t(u) + u⋅∇(u) = -∇(p) + nu*Δ(u)\")\n\nTyping Unicode in Julia:\n\n∇ : Type \\nabla then press Tab\nΔ : Type \\Delta then press Tab\n∂t : Type \\partial Tab \\_t Tab\n∂x : Type \\partial Tab x\n⋅ : Type \\cdot then press Tab\n× : Type \\times then press Tab\n\n","category":"section"},{"location":"api/operators/#Differential-Operators","page":"Operators API","title":"Differential Operators","text":"","category":"section"},{"location":"api/operators/#Gradient-(grad-/-)","page":"Operators API","title":"Gradient (grad / ∇)","text":"Computes the gradient of a scalar field, returning a vector field.\n\nSyntax:\n\n# In equations\nadd_equation!(problem, \"∇(p)\")  # or \"grad(p)\"\n\n# Programmatic\n∇p = ∇(p)  # or grad(p)\n\nDefinitions:\n\nCartesian:\n\nnabla p = fracpartial ppartial xhatx + fracpartial ppartial yhaty + fracpartial ppartial zhatz\n\nSpherical:\n\nnabla p = fracpartial ppartial rhatr + frac1rfracpartial ppartial thetahattheta + frac1rsinthetafracpartial ppartial phihatphi\n\nExamples:\n\n# 2D gradient\ncoords = CartesianCoordinates(\"x\", \"z\")\nproblem = IVP([u, w, p])\n\n# Pressure gradient in momentum equation\nadd_equation!(problem, \"∂t(u) = -∇(p)\")\n\n# Expands to:\n# ∂t(u_x) = -∂x(p)\n# ∂t(u_z) = -∂z(p)\n\n# 3D gradient with custom usage\n∇T = ∇(T)  # Returns VectorField\n# Components: ∇T.components[1] = ∂x(T), etc.\n\nReturn type: VectorField\n\n","category":"section"},{"location":"api/operators/#Divergence-(div)","page":"Operators API","title":"Divergence (div)","text":"Computes the divergence of a vector field, returning a scalar field.\n\nSyntax:\n\n# In equations\nadd_equation!(problem, \"div(u) = 0\")\n\n# Programmatic\ndiv_u = div(u)\n\nDefinitions:\n\nCartesian:\n\nnabla cdot mathbfu = fracpartial u_xpartial x + fracpartial u_ypartial y + fracpartial u_zpartial z\n\nSpherical:\n\nnabla cdot mathbfu = frac1r^2fracpartial (r^2 u_r)partial r + frac1rsinthetafracpartial (sintheta u_theta)partial theta + frac1rsinthetafracpartial u_phipartial phi\n\nExamples:\n\n# Incompressibility constraint\nproblem = IVP([u, v, w, p])\nadd_equation!(problem, \"div(u) = 0\")\n\n# Mass conservation with source\nadd_equation!(problem, \"div(u) = S\")\n\nReturn type: ScalarField\n\n","category":"section"},{"location":"api/operators/#Curl-(curl)","page":"Operators API","title":"Curl (curl)","text":"Computes the curl of a vector field, returning a vector field.\n\nSyntax:\n\n# In equations\nadd_equation!(problem, \"omega = curl(u)\")\n\n# Programmatic\nω = curl(u)\n\nDefinitions:\n\nCartesian (3D):\n\nnabla times mathbfu = left(fracpartial u_zpartial y - fracpartial u_ypartial zright)hatx + left(fracpartial u_xpartial z - fracpartial u_zpartial xright)haty + left(fracpartial u_ypartial x - fracpartial u_xpartial yright)hatz\n\n2D (returns scalar vorticity):\n\nomega = fracpartial vpartial x - fracpartial upartial y\n\nExamples:\n\n# Vorticity equation (3D)\nproblem = IVP([u, omega])\nadd_equation!(problem, \"∂t(omega) = curl(u × omega)\")\n\n# 2D vorticity\ncoords = CartesianCoordinates(\"x\", \"y\")\nproblem = IVP([u, v, omega])\nadd_equation!(problem, \"omega = ∂x(v) - ∂y(u)\")\n\nReturn type: VectorField (3D) or ScalarField (2D)\n\n","category":"section"},{"location":"api/operators/#Laplacian-(lap)","page":"Operators API","title":"Laplacian (lap)","text":"Computes the Laplacian (second derivative) of a field.\n\nSyntax:\n\n# In equations\nadd_equation!(problem, \"∂t(T) = kappa*Δ(T)\")\n\n# Programmatic\n∇²T = Δ(T)\n\nDefinitions:\n\nCartesian:\n\nnabla^2 f = fracpartial^2 fpartial x^2 + fracpartial^2 fpartial y^2 + fracpartial^2 fpartial z^2\n\nSpherical:\n\nnabla^2 f = frac1r^2fracpartialpartial rleft(r^2fracpartial fpartial rright) + frac1r^2sinthetafracpartialpartial thetaleft(sinthetafracpartial fpartial thetaright) + frac1r^2sin^2thetafracpartial^2 fpartial phi^2\n\nExamples:\n\n# Diffusion equation\nadd_equation!(problem, \"∂t(T) = kappa*Δ(T)\")\n\n# Viscous term in Navier-Stokes\nadd_equation!(problem, \"∂t(u) = nu*Δ(u) - ∇(p)\")\n\n# Poisson equation (BVP)\nproblem = LBVP([phi])\nadd_equation!(problem, \"Δ(phi) = rho\")\n\nWorks on: ScalarField, VectorField (applies componentwise)\n\n","category":"section"},{"location":"api/operators/#Coordinate-Derivatives","page":"Operators API","title":"Coordinate Derivatives","text":"","category":"section"},{"location":"api/operators/#First-Derivatives","page":"Operators API","title":"First Derivatives","text":"Partial derivatives with respect to coordinate directions.\n\nSyntax:\n\n∂x(field)   # ∂/∂x\n∂y(field)   # ∂/∂y\n∂z(field)   # ∂/∂z\n∂r(field)   # ∂/∂r (spherical/polar)\n∂θ(field)   # ∂/∂θ\n∂φ(field)   # ∂/∂φ\n\nExamples:\n\n# Advection term\nadd_equation!(problem, \"∂t(T) = -u*∂x(T) - w*∂z(T)\")\n\n# Shear\nadd_equation!(problem, \"S = ∂x(u) + ∂z(w)\")\n\n# Custom derivative\ndudz = ∂z(u)  # Returns field with ∂u/∂z\n\nImplementation:\n\nFourier: Multiplication by ik in spectral space\nChebyshev/Legendre: Sparse matrix multiplication using recurrence relations\n\n","category":"section"},{"location":"api/operators/#Higher-Derivatives","page":"Operators API","title":"Higher Derivatives","text":"Multiple derivatives can be composed:\n\nSyntax:\n\n# Second derivatives\n∂x(∂x(T))   # ∂²T/∂x²\n∂z(∂z(T))   # ∂²T/∂z²\n\n# Mixed derivatives\n∂x(∂z(T))   # ∂²T/∂x∂z\n\n# Higher order\n∂x(∂x(∂x(T)))  # ∂³T/∂x³\n\nExamples:\n\n# Biharmonic operator\nadd_equation!(problem, \"Δ(Δ(psi)) = omega\")\n\n# Equivalent to:\nadd_equation!(problem, \"∂x(∂x(∂x(∂x(psi)))) + 2*∂x(∂x(∂z(∂z(psi)))) + ∂z(∂z(∂z(∂z(psi)))) = omega\")\n\n# Hyperdiffusion (for numerical stability)\nadd_equation!(problem, \"∂t(T) = -nu4*Δ(Δ(T))\")\n\n","category":"section"},{"location":"api/operators/#Time-Derivatives","page":"Operators API","title":"Time Derivatives","text":"","category":"section"},{"location":"api/operators/#dt-/-t-Operator","page":"Operators API","title":"dt / ∂t Operator","text":"Time derivative for initial value problems.\n\nSyntax:\n\ndt(field)   # ASCII\n∂t(field)   # Unicode (type \\partial Tab \\_t Tab)\n\nExamples:\n\n# Evolution equations\nadd_equation!(problem, \"∂t(u) = -u*∂x(u) + nu*Δ(u)\")\nadd_equation!(problem, \"∂t(T) = -u*∂x(T) + kappa*Δ(T)\")\n\nNote: Only use in IVP (Initial Value Problems). Not valid for BVP or EVP.\n\n","category":"section"},{"location":"api/operators/#Vector-Operations","page":"Operators API","title":"Vector Operations","text":"","category":"section"},{"location":"api/operators/#Dot-Product-/-Advection","page":"Operators API","title":"Dot Product / Advection","text":"Syntax:\n\n# In equations - use vector notation directly\nadd_equation!(problem, \"∂t(T) = -u⋅∇(T)\")\n\n# For vector advection (nonlinear term)\nadd_equation!(problem, \"∂t(u) = -u⋅∇(u)\")\n\nExample:\n\n# Scalar advection: -u·∇T\nadd_equation!(problem, \"∂t(T) = -u⋅∇(T)\")\n\n# Vector advection (Navier-Stokes nonlinear term)\nadd_equation!(problem, \"∂t(u) - nu*Δ(u) + ∇(p) = -u⋅∇(u)\")\n\n","category":"section"},{"location":"api/operators/#Cross-Product","page":"Operators API","title":"Cross Product","text":"Syntax:\n\n# Use cross function or × operator\nu_cross_omega = cross(u, omega)\nu_cross_omega = u × omega  # Unicode: \\times Tab\n\nExample:\n\n# Vorticity equation: ∂ω/∂t = ∇×(u×ω)\nproblem = IVP([ux, uy, uz, omega_x, omega_y, omega_z])\n\n# Compute u × ω\nu_cross_omega = cross(u, omega)\n# Or equivalently:\nu_cross_omega = u × omega\n\n# Then: ∇×(u×ω)\nadd_equation!(problem, \"∂t(omega) = curl(u_cross_omega)\")\n\n","category":"section"},{"location":"api/operators/#Composite-Operators","page":"Operators API","title":"Composite Operators","text":"Combine operators for complex expressions.","category":"section"},{"location":"api/operators/#Vector-Laplacian","page":"Operators API","title":"Vector Laplacian","text":"# For vector field u\n# ∇²u = (∇²u_x, ∇²u_y, ∇²u_z)\n\nadd_equation!(problem, \"∂t(u) = nu*Δ(u)\")\n# Automatically applies componentwise","category":"section"},{"location":"api/operators/#Advection-Operator","page":"Operators API","title":"Advection Operator","text":"# u·∇u (nonlinear advection) - use vector notation directly\n\n# Navier-Stokes momentum equation:\nadd_equation!(problem, \"∂t(u) - nu*Δ(u) + ∇(p) = -u⋅∇(u)\")\n\n# Scalar advection:\nadd_equation!(problem, \"∂t(T) - kappa*Δ(T) = -u⋅∇(T)\")\n\n# With buoyancy (Boussinesq):\nadd_equation!(problem, \"∂t(u) - nu*Δ(u) + ∇(p) = -u⋅∇(u) + Ra*T*ez\")","category":"section"},{"location":"api/operators/#Strain-Rate-Tensor","page":"Operators API","title":"Strain Rate Tensor","text":"# S_ij = 1/2 (∂u_i/∂x_j + ∂u_j/∂x_i)\n\nfunction strain_rate_tensor(u)\n    # Returns TensorField\n    S = TensorField(u.distributor, u.coords, \"S\", u.bases, symmetric=true)\n\n    S[1,1] = ∂x(u.components[1])\n    S[1,2] = 0.5 * (∂x(u.components[2]) + ∂y(u.components[1]))\n    S[2,2] = ∂y(u.components[2])\n    # ... etc\n\n    return S\nend\n\n","category":"section"},{"location":"api/operators/#Operator-Properties","page":"Operators API","title":"Operator Properties","text":"","category":"section"},{"location":"api/operators/#Linearity","page":"Operators API","title":"Linearity","text":"All operators are linear:\n\n# ∇(αf + βg) = α∇f + β∇g\n∇(alpha*f + beta*g) == alpha*∇(f) + beta*∇(g)","category":"section"},{"location":"api/operators/#Commutativity","page":"Operators API","title":"Commutativity","text":"Partial derivatives commute:\n\n# ∂²f/∂x∂z = ∂²f/∂z∂x\n∂x(∂z(f)) == ∂z(∂x(f))","category":"section"},{"location":"api/operators/#Product-Rule","page":"Operators API","title":"Product Rule","text":"# ∇(fg) = f∇g + g∇f\n∇(f*g) == f*∇(g) + g*∇(f)\n\n","category":"section"},{"location":"api/operators/#Custom-Operators","page":"Operators API","title":"Custom Operators","text":"","category":"section"},{"location":"api/operators/#Defining-Helper-Functions","page":"Operators API","title":"Defining Helper Functions","text":"You can define helper functions that compose built-in operators:\n\n# Define helper function\nfunction my_diffusion(field, kappa)\n    # Custom operation combining derivatives\n    return kappa * Δ(field)\nend\n\n# Use programmatically\ndiffusion_term = my_diffusion(T, kappa)","category":"section"},{"location":"api/operators/#Using-Built-in-Operators-in-Equations","page":"Operators API","title":"Using Built-in Operators in Equations","text":"The equation parser recognizes all registered operators. Use them directly in equation strings:\n\n# Available operators in equations:\n# grad, div, curl, lap (or Δ), dt (or ∂t), d\n# integrate, average, interpolate, convert, lift\n# sin, cos, tan, exp, log, sqrt, abs, tanh\n\n# Example: diffusion equation\nadd_equation!(problem, \"∂t(T) = kappa*Δ(T)\")\n\n# Example: advection-diffusion\nadd_equation!(problem, \"∂t(T) + u⋅∇(T) = kappa*Δ(T)\")\n\nFor complex expressions, compute terms programmatically and use the result:\n\n# Compute complex term\nrhs_term = kappa * Δ(T) - u * ∂x(T)\n\n# Add to field's RHS\nT.rhs .+= rhs_term.data\n\n","category":"section"},{"location":"api/operators/#Equation-Parsing","page":"Operators API","title":"Equation Parsing","text":"","category":"section"},{"location":"api/operators/#Symbolic-Syntax","page":"Operators API","title":"Symbolic Syntax","text":"Tarang.jl parses equation strings into operator applications:\n\n# String equation\nadd_equation!(problem, \"∂t(u) + u*∂x(u) = nu*Δ(u) - ∂x(p)\")\n\n# Parsed as:\n# LHS: ∂t(u) + u*∂x(u)\n# RHS: nu*Δ(u) - ∂x(p)\n\nSupported operations:\n\nAddition: +\nSubtraction: -\nMultiplication: *\nDivision: /\nParentheses: (, )\nFunctions: sin, cos, exp, etc.","category":"section"},{"location":"api/operators/#Operator-Evaluation","page":"Operators API","title":"Operator Evaluation","text":"Operators are evaluated in spectral space when possible:\n\n# ∂x(u): Multiply by ik in Fourier space\n# Δ(u): Multiply by -k² in Fourier space\n# Nonlinear terms: Transform to grid space, evaluate, transform back\n\n","category":"section"},{"location":"api/operators/#Performance-Tips","page":"Operators API","title":"Performance Tips","text":"","category":"section"},{"location":"api/operators/#Minimize-Grid-Spectral-Transforms","page":"Operators API","title":"Minimize Grid-Spectral Transforms","text":"# Bad: Multiple transforms\nadd_equation!(problem, \"∂t(T) = -u*∂x(T)\")  # Transforms for each term\n\n# Better: Group operations\n# Tarang automatically optimizes transform grouping","category":"section"},{"location":"api/operators/#Precompute-Common-Terms","page":"Operators API","title":"Precompute Common Terms","text":"# If using same derivative multiple times\ndudx = ∂x(u)\n\nadd_equation!(problem, \"term1 = dudx\")\nadd_equation!(problem, \"term2 = w*dudx\")","category":"section"},{"location":"api/operators/#Use-Sparse-Differentiation","page":"Operators API","title":"Use Sparse Differentiation","text":"Chebyshev/Legendre derivatives are sparse matrix operations - very efficient.\n\n","category":"section"},{"location":"api/operators/#See-Also","page":"Operators API","title":"See Also","text":"Fields: Field types that operators act on\nProblems: Using operators in equations\nDomains: Spatial discretization for operators\nBases: Spectral bases for differentiation","category":"section"},{"location":"api/les_models/#LES-Models-API","page":"LES Models API","title":"LES Models API","text":"","category":"section"},{"location":"api/les_models/#Types","page":"LES Models API","title":"Types","text":"","category":"section"},{"location":"api/les_models/#Abstract-Types","page":"LES Models API","title":"Abstract Types","text":"abstract type SGSModel end\nabstract type EddyViscosityModel <: SGSModel end","category":"section"},{"location":"api/les_models/#SmagorinskyModel","page":"LES Models API","title":"SmagorinskyModel","text":"Classic Smagorinsky (1963) subgrid-scale model.\n\nType signature:\n\nmutable struct SmagorinskyModel{T<:AbstractFloat, N} <: EddyViscosityModel\n\nFields:\n\nField Type Description\nC_s T Smagorinsky constant\nfilter_width NTuple{N, T} Filter width (Δx, Δy, Δz)\neffective_delta T Effective Δ = (Δx Δy Δz)^(1/N)\neddy_viscosity Array{T, N} νₑ field\nstrain_magnitude Array{T, N} |S̄| field\nfield_size NTuple{N, Int} Grid dimensions\n\nConstructor:\n\nSmagorinskyModel(;\n    C_s = 0.17,\n    filter_width::NTuple{N, Real},\n    field_size::NTuple{N, Int},\n    dtype = Float64\n)","category":"section"},{"location":"api/les_models/#AMDModel","page":"LES Models API","title":"AMDModel","text":"Anisotropic Minimum Dissipation model (Rozema et al., 2015).\n\nType signature:\n\nmutable struct AMDModel{T<:AbstractFloat, N} <: EddyViscosityModel\n\nFields:\n\nField Type Description\nC T Poincaré constant\nfilter_width NTuple{N, T} Anisotropic filter widths\nfilter_width_sq NTuple{N, T} Δₖ² for each direction\neddy_viscosity Array{T, N} νₑ field\neddy_diffusivity Array{T, N} κₑ field (for scalars)\nfield_size NTuple{N, Int} Grid dimensions\nclip_negative Bool Whether to clip νₑ < 0\n\nConstructor:\n\nAMDModel(;\n    C = 1/12,\n    filter_width::NTuple{N, Real},\n    field_size::NTuple{N, Int},\n    clip_negative = true,\n    dtype = Float64\n)\n\n","category":"section"},{"location":"api/les_models/#Eddy-Viscosity-Computation","page":"LES Models API","title":"Eddy Viscosity Computation","text":"","category":"section"},{"location":"api/les_models/#compute*eddy*viscosity!","page":"LES Models API","title":"computeeddyviscosity!","text":"Compute eddy viscosity from velocity gradient components.\n\n2D Signature:\n\ncompute_eddy_viscosity!(model, ∂u∂x, ∂u∂y, ∂v∂x, ∂v∂y)\n\n3D Signature:\n\ncompute_eddy_viscosity!(model,\n    ∂u∂x, ∂u∂y, ∂u∂z,\n    ∂v∂x, ∂v∂y, ∂v∂z,\n    ∂w∂x, ∂w∂y, ∂w∂z\n)\n\nReturns: The eddy viscosity array model.eddy_viscosity","category":"section"},{"location":"api/les_models/#compute*eddy*diffusivity!","page":"LES Models API","title":"computeeddydiffusivity!","text":"Compute eddy diffusivity for scalar transport (AMD model only).\n\ncompute_eddy_diffusivity!(model::AMDModel,\n    ∂w∂x, ∂w∂y, ∂w∂z,\n    ∂b∂x, ∂b∂y, ∂b∂z\n)\n\nReturns: The eddy diffusivity array model.eddy_diffusivity\n\n","category":"section"},{"location":"api/les_models/#Subgrid-Stress","page":"LES Models API","title":"Subgrid Stress","text":"","category":"section"},{"location":"api/les_models/#compute*sgs*stress","page":"LES Models API","title":"computesgsstress","text":"Compute deviatoric SGS stress tensor τᵢⱼ = -2 νₑ S̄ᵢⱼ.\n\n2D Signature:\n\ncompute_sgs_stress(model, S11, S12, S22) -> (τ11, τ12, τ22)\n\n3D Signature:\n\ncompute_sgs_stress(model, S11, S12, S13, S22, S23, S33)\n    -> (τ11, τ12, τ13, τ22, τ23, τ33)\n\n","category":"section"},{"location":"api/les_models/#Accessors","page":"LES Models API","title":"Accessors","text":"","category":"section"},{"location":"api/les_models/#get*eddy*viscosity","page":"LES Models API","title":"geteddyviscosity","text":"Return the current eddy viscosity field.\n\nget_eddy_viscosity(model::EddyViscosityModel) -> Array{T, N}","category":"section"},{"location":"api/les_models/#get*eddy*diffusivity","page":"LES Models API","title":"geteddydiffusivity","text":"Return the current eddy diffusivity field (AMD only).\n\nget_eddy_diffusivity(model::AMDModel) -> Array{T, N}","category":"section"},{"location":"api/les_models/#get*filter*width","page":"LES Models API","title":"getfilterwidth","text":"Return the filter width tuple.\n\nget_filter_width(model::EddyViscosityModel) -> NTuple{N, T}\n\n","category":"section"},{"location":"api/les_models/#Statistics","page":"LES Models API","title":"Statistics","text":"","category":"section"},{"location":"api/les_models/#mean*eddy*viscosity","page":"LES Models API","title":"meaneddyviscosity","text":"Compute domain-averaged eddy viscosity.\n\nmean_eddy_viscosity(model::EddyViscosityModel) -> T","category":"section"},{"location":"api/les_models/#max*eddy*viscosity","page":"LES Models API","title":"maxeddyviscosity","text":"Return maximum eddy viscosity in the domain.\n\nmax_eddy_viscosity(model::EddyViscosityModel) -> T\n\n","category":"section"},{"location":"api/les_models/#Dissipation-Rate","page":"LES Models API","title":"Dissipation Rate","text":"","category":"section"},{"location":"api/les_models/#sgs_dissipation","page":"LES Models API","title":"sgs_dissipation","text":"Compute SGS dissipation rate field: εₛₛ = 2 νₑ |S̄|²\n\nsgs_dissipation(model::EddyViscosityModel, strain_magnitude) -> Array{T, N}","category":"section"},{"location":"api/les_models/#mean*sgs*dissipation","page":"LES Models API","title":"meansgsdissipation","text":"Compute domain-averaged SGS dissipation rate.\n\nmean_sgs_dissipation(model::EddyViscosityModel, strain_magnitude) -> T\n\n","category":"section"},{"location":"api/les_models/#Configuration","page":"LES Models API","title":"Configuration","text":"","category":"section"},{"location":"api/les_models/#set_constant!","page":"LES Models API","title":"set_constant!","text":"Update the model constant.\n\nset_constant!(model::SmagorinskyModel, C_s::Real)\nset_constant!(model::AMDModel, C::Real)","category":"section"},{"location":"api/les_models/#reset!","page":"LES Models API","title":"reset!","text":"Reset eddy viscosity (and diffusivity for AMD) to zero.\n\nreset!(model::EddyViscosityModel)\nreset!(model::AMDModel)  # Also resets eddy_diffusivity\n\n","category":"section"},{"location":"api/les_models/#Exports","page":"LES Models API","title":"Exports","text":"export SGSModel, EddyViscosityModel\nexport SmagorinskyModel, AMDModel\nexport compute_eddy_viscosity!, compute_eddy_diffusivity!\nexport compute_sgs_stress\nexport get_eddy_viscosity, get_eddy_diffusivity, get_filter_width\nexport mean_eddy_viscosity, max_eddy_viscosity\nexport reset!, set_constant!\nexport sgs_dissipation, mean_sgs_dissipation\n\n","category":"section"},{"location":"api/les_models/#Index","page":"LES Models API","title":"Index","text":"Pages = [\"les_models.md\"]","category":"section"},{"location":"api/les_models/#Tarang.SmagorinskyModel","page":"LES Models API","title":"Tarang.SmagorinskyModel","text":"SmagorinskyModel{T, N, A, Arch}\n\nClassic Smagorinsky (1963) subgrid-scale model.\n\nMathematical Formulation\n\nThe eddy viscosity is:\n\nνₑ = (Cₛ Δ)² |S̄|\n\nwhere:\n\nCₛ is the Smagorinsky constant (typically 0.1-0.2)\nΔ is the filter width (grid spacing)\n|S̄| = √(2 S̄ᵢⱼ S̄ᵢⱼ) is the strain rate magnitude\n\nFields\n\nC_s::T: Smagorinsky constant\nfilter_width::NTuple{N, T}: Filter width in each direction (Δx, Δy, ...)\neddy_viscosity::A: Cached eddy viscosity field (Array or CuArray)\nstrain_magnitude::A: Cached |S̄| field\narchitecture::Arch: CPU() or GPU() architecture\n\nExample\n\n# Create model for 256³ domain with Δ = 2π/256\nmodel = SmagorinskyModel(\n    C_s = 0.17,\n    filter_width = (2π/256, 2π/256, 2π/256),\n    field_size = (256, 256, 256)\n)\n\n# Create GPU model\nmodel_gpu = SmagorinskyModel(\n    C_s = 0.17,\n    filter_width = (2π/256, 2π/256, 2π/256),\n    field_size = (256, 256, 256),\n    architecture = GPU()\n)\n\n# Compute eddy viscosity from velocity gradients\ncompute_eddy_viscosity!(model, ∂u∂x, ∂u∂y, ∂u∂z, ∂v∂x, ∂v∂y, ∂v∂z, ∂w∂x, ∂w∂y, ∂w∂z)\n\n# Access the result\nνₑ = get_eddy_viscosity(model)\n\n\n\n\n\n","category":"type"},{"location":"api/les_models/#Tarang.AMDModel","page":"LES Models API","title":"Tarang.AMDModel","text":"AMDModel{T, N, A, Arch}\n\nAnisotropic Minimum Dissipation model (Rozema et al., 2015).\n\nMathematical Formulation\n\nThe eddy viscosity is:\n\nνₑ = max(0, νₑ†)\n\nwhere the predictor is:\n\nνₑ† = -C (Δₖ² ∂uᵢ/∂xₖ ∂uⱼ/∂xₖ Sᵢⱼ) / (∂uₘ/∂xₙ ∂uₘ/∂xₙ)\n\nKey features:\n\nUses anisotropic filter widths Δₖ in each direction\nAutomatically switches off in laminar/transitional regions\nProvides minimum dissipation required for subgrid energy transfer\nNo explicit filtering or test-filtering required\n\nFields\n\nC::T: Poincaré constant (model constant)\nfilter_width::NTuple{N, T}: Anisotropic filter widths (Δx, Δy, Δz)\neddy_viscosity::A: Cached eddy viscosity field (Array or CuArray)\neddy_diffusivity::A: Cached eddy diffusivity (for scalars)\narchitecture::Arch: CPU() or GPU() architecture\n\nModel Constant Recommendations\n\nDiscretization C\nSpectral methods 1/12 ≈ 0.0833\n4th-order finite difference 0.212\n2nd-order finite difference 0.3\n\nExample\n\n# Create AMD model for anisotropic grid\nmodel = AMDModel(\n    C = 1/12,  # Spectral method\n    filter_width = (2π/256, 2π/256, 2π/64),  # Anisotropic\n    field_size = (256, 256, 64)\n)\n\n# Create GPU AMD model\nmodel_gpu = AMDModel(\n    C = 1/12,\n    filter_width = (2π/256, 2π/256, 2π/64),\n    field_size = (256, 256, 64),\n    architecture = GPU()\n)\n\n# Compute eddy viscosity\ncompute_eddy_viscosity!(model, ∂u∂x, ∂u∂y, ∂u∂z, ∂v∂x, ∂v∂y, ∂v∂z, ∂w∂x, ∂w∂y, ∂w∂z)\n\nReferences\n\nRozema, W., Bae, H.J., Moin, P., Verstappen, R. (2015). \"Minimum-dissipation models for large-eddy simulation\", Physics of Fluids 27, 085107.\n\n\n\n\n\n","category":"type"},{"location":"api/les_models/#Tarang.compute_eddy_viscosity!","page":"LES Models API","title":"Tarang.compute_eddy_viscosity!","text":"compute_eddy_viscosity!(model::SmagorinskyModel, velocity_gradients...)\n\nCompute eddy viscosity from velocity gradient components.\n\nGPU-aware: Uses broadcasting for GPU arrays, optimized SIMD loops for CPU.\n\n2D Case\n\ncompute_eddy_viscosity!(model, ∂u∂x, ∂u∂y, ∂v∂x, ∂v∂y)\n\n3D Case\n\ncompute_eddy_viscosity!(model, ∂u∂x, ∂u∂y, ∂u∂z, ∂v∂x, ∂v∂y, ∂v∂z, ∂w∂x, ∂w∂y, ∂w∂z)\n\n\n\n\n\ncompute_eddy_viscosity!(model::AMDModel, velocity_gradients...)\n\nCompute AMD eddy viscosity from velocity gradient components.\n\nGPU-aware: Uses broadcasting for GPU arrays, optimized SIMD loops for CPU.\n\n2D Case\n\ncompute_eddy_viscosity!(model, ∂u∂x, ∂u∂y, ∂v∂x, ∂v∂y)\n\n3D Case\n\ncompute_eddy_viscosity!(model, ∂u∂x, ∂u∂y, ∂u∂z, ∂v∂x, ∂v∂y, ∂v∂z, ∂w∂x, ∂w∂y, ∂w∂z)\n\nThe AMD formula uses anisotropic scaling:     νₑ† = -C (Δₖ² ∂uᵢ/∂xₖ ∂uⱼ/∂xₖ Sᵢⱼ) / (∂uₘ/∂xₙ ∂uₘ/∂xₙ)\n\n\n\n\n\n","category":"function"},{"location":"api/les_models/#Tarang.compute_eddy_diffusivity!","page":"LES Models API","title":"Tarang.compute_eddy_diffusivity!","text":"compute_eddy_diffusivity!(model::AMDModel, velocity_gradients..., scalar_gradients...)\n\nCompute eddy diffusivity for scalar transport using AMD model.\n\nGPU-aware: Uses broadcasting for GPU arrays, optimized SIMD loops for CPU.\n\nFor a scalar field b with gradient ∇b, the eddy diffusivity is:\n\nκₑ = max(0, κₑ†)\n\nwhere:     κₑ† = -C (Δₖ² ∂v/∂xₖ ∂b/∂xₖ) / (∂b/∂xₙ ∂b/∂xₙ)\n\nFor 2D flows, v is the vertical velocity component. For 3D flows (buoyancy-driven), w is the vertical velocity.\n\n\n\n\n\n","category":"function"},{"location":"api/les_models/#Tarang.compute_sgs_stress","page":"LES Models API","title":"Tarang.compute_sgs_stress","text":"compute_sgs_stress(model::EddyViscosityModel, strain_components...)\n\nCompute the deviatoric subgrid stress tensor:\n\nτᵢⱼᵈ = -2 νₑ S̄ᵢⱼ\n\nGPU-aware: Uses broadcasting which works for both CPU and GPU arrays.\n\n2D Output\n\nReturns (τ11, τ12, τ22).\n\n3D Output\n\nReturns (τ11, τ12, τ13, τ22, τ23, τ33).\n\n\n\n\n\n","category":"function"},{"location":"api/les_models/#Tarang.get_eddy_viscosity","page":"LES Models API","title":"Tarang.get_eddy_viscosity","text":"get_eddy_viscosity(model::EddyViscosityModel)\n\nReturn the current eddy viscosity field.\n\n\n\n\n\n","category":"function"},{"location":"api/les_models/#Tarang.get_eddy_diffusivity","page":"LES Models API","title":"Tarang.get_eddy_diffusivity","text":"get_eddy_diffusivity(model::AMDModel)\n\nReturn the current eddy diffusivity field (AMD model only).\n\n\n\n\n\n","category":"function"},{"location":"api/les_models/#Tarang.get_filter_width","page":"LES Models API","title":"Tarang.get_filter_width","text":"get_filter_width(model::EddyViscosityModel)\n\nReturn the filter width(s).\n\n\n\n\n\n","category":"function"},{"location":"api/les_models/#Tarang.mean_eddy_viscosity","page":"LES Models API","title":"Tarang.mean_eddy_viscosity","text":"mean_eddy_viscosity(model::EddyViscosityModel)\n\nCompute the domain-averaged eddy viscosity.\n\n\n\n\n\n","category":"function"},{"location":"api/les_models/#Tarang.max_eddy_viscosity","page":"LES Models API","title":"Tarang.max_eddy_viscosity","text":"max_eddy_viscosity(model::EddyViscosityModel)\n\nReturn the maximum eddy viscosity in the domain.\n\n\n\n\n\n","category":"function"},{"location":"api/les_models/#Tarang.sgs_dissipation","page":"LES Models API","title":"Tarang.sgs_dissipation","text":"sgs_dissipation(model::EddyViscosityModel, strain_magnitude::AbstractArray)\n\nCompute the subgrid-scale dissipation rate:\n\nεₛₛ = 2 νₑ |S̄|²\n\nGPU-aware: Uses broadcasting which works for both CPU and GPU arrays. Returns the dissipation field.\n\n\n\n\n\n","category":"function"},{"location":"api/les_models/#Tarang.mean_sgs_dissipation","page":"LES Models API","title":"Tarang.mean_sgs_dissipation","text":"mean_sgs_dissipation(model::EddyViscosityModel, strain_magnitude::AbstractArray)\n\nCompute domain-averaged SGS dissipation rate. GPU-aware: Uses broadcasting and sum() which work for both CPU and GPU arrays.\n\n\n\n\n\n","category":"function"},{"location":"api/les_models/#Tarang.set_constant!","page":"LES Models API","title":"Tarang.set_constant!","text":"set_constant!(model::SmagorinskyModel, C_s::Real)\n\nUpdate the Smagorinsky constant.\n\n\n\n\n\nset_constant!(model::AMDModel, C::Real)\n\nUpdate the AMD Poincaré constant.\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#Solvers-API","page":"Solvers API","title":"Solvers API","text":"Solvers integrate PDEs in time or solve for steady states. Tarang.jl provides specialized solvers for different problem types.","category":"section"},{"location":"api/solvers/#Solver-Types","page":"Solvers API","title":"Solver Types","text":"","category":"section"},{"location":"api/solvers/#InitialValueSolver","page":"Solvers API","title":"InitialValueSolver","text":"Time-stepping solver for Initial Value Problems (IVP).\n\nConstructor:\n\nInitialValueSolver(\n    problem::IVP,\n    timestepper::TimeStepper;\n    dt::Float64=0.001,\n    device::String=\"cpu\"\n)\n\nArguments:\n\nproblem: IVP problem definition\ntimestepper: Time integration scheme (RK222, CNAB2, etc.)\ndt: Initial timestep\n\nExamples:\n\n# IMEX Runge-Kutta\nsolver = InitialValueSolver(problem, RK222(), dt=0.001)\n\n# IMEX timestepper\nsolver = InitialValueSolver(problem, CNAB2(), dt=0.01)\n\n# Higher-order timestepper\nsolver = InitialValueSolver(problem, RK443(), dt=0.001)\n\nProperties:\n\nsolver.problem          # IVP problem\nsolver.timestepper      # Time integration scheme\nsolver.dt               # Current timestep\nsolver.sim_time         # Current simulation time\nsolver.iteration        # Current iteration number\nsolver.wall_time        # Elapsed wall clock time\nsolver.state            # Current state vector\n\nMethods:","category":"section"},{"location":"api/solvers/#step!","page":"Solvers API","title":"step!","text":"Advance solution by one timestep.\n\nstep!(solver)           # Use solver.dt\nstep!(solver, dt)       # Use specified dt\n\nExample:\n\n# Fixed timestep\nwhile solver.sim_time < t_end\n    step!(solver, 0.001)\nend\n\n# Adaptive timestep (with CFL)\ncfl = CFL(problem, safety=0.5)\nadd_velocity!(cfl, u)\n\nwhile solver.sim_time < t_end\n    dt = compute_timestep(cfl)\n    step!(solver, dt)\nend","category":"section"},{"location":"api/solvers/#proceed","page":"Solvers API","title":"proceed","text":"Check if simulation should continue.\n\n# Set stop conditions\nsolver.stop_sim_time = 10.0\nsolver.stop_wall_time = 3600.0  # 1 hour\nsolver.stop_iteration = 10000\n\nwhile proceed(solver)\n    step!(solver)\nend\n\n","category":"section"},{"location":"api/solvers/#BoundaryValueSolver","page":"Solvers API","title":"BoundaryValueSolver","text":"Solver for Linear Boundary Value Problems (LBVP).\n\nConstructor:\n\nBoundaryValueSolver(\n    problem::LBVP;\n    solver_type::String=\"direct\",\n    tolerance::Float64=1e-10\n)\n\nArguments:\n\nproblem: LBVP problem definition\nsolver_type: Solution method (\"direct\", \"iterative\", \"multigrid\")\ntolerance: Convergence tolerance for iterative solvers\n\nExamples:\n\n# Direct solver (for small problems)\nsolver = BoundaryValueSolver(problem, solver_type=\"direct\")\n\n# Iterative solver (for large problems)\nsolver = BoundaryValueSolver(problem, solver_type=\"iterative\", tolerance=1e-8)\n\nMethods:","category":"section"},{"location":"api/solvers/#solve!","page":"Solvers API","title":"solve!","text":"Solve the boundary value problem.\n\nsolve!(solver)\n\nReturns: Solution fields are updated in place\n\nExample:\n\n# Poisson equation\nproblem = LBVP([phi])\nadd_equation!(problem, \"Δ(phi) = rho\")\nadd_equation!(problem, \"phi(z=0) = 0\")\nadd_equation!(problem, \"phi(z=1) = 0\")\n\nsolver = BoundaryValueSolver(problem)\nsolve!(solver)\n\n# Solution is now in phi field\nphi_grid = get_grid_data(phi)\n\n","category":"section"},{"location":"api/solvers/#NonlinearBoundaryValueSolver","page":"Solvers API","title":"NonlinearBoundaryValueSolver","text":"Newton-Raphson solver for Nonlinear Boundary Value Problems (NLBVP).\n\nConstructor:\n\nNonlinearBoundaryValueSolver(\n    problem::NLBVP;\n    tolerance::Float64=1e-8,\n    max_iterations::Int=100,\n    damping::Float64=1.0\n)\n\nArguments:\n\nproblem: NLBVP problem definition\ntolerance: Convergence tolerance\nmax_iterations: Maximum Newton iterations\ndamping: Damping factor for Newton steps (0 < damping ≤ 1)\n\nExamples:\n\n# Standard Newton solver\nsolver = NonlinearBoundaryValueSolver(problem, tolerance=1e-8)\n\n# With damping for stability\nsolver = NonlinearBoundaryValueSolver(problem, damping=0.5, max_iterations=50)\n\nMethods:","category":"section"},{"location":"api/solvers/#solve!-2","page":"Solvers API","title":"solve!","text":"Solve using Newton-Raphson iteration.\n\nsuccess = solve!(solver)\n\nReturns: true if converged, false otherwise\n\nExample:\n\n# Steady Navier-Stokes\nproblem = NLBVP([u, v, p])\nadd_equation!(problem, \"u*∂x(u) + v*∂z(u) + ∂x(p) = nu*Δ(u)\")\nadd_equation!(problem, \"u*∂x(v) + v*∂z(v) + ∂z(p) = nu*Δ(v)\")\nadd_equation!(problem, \"∂x(u) + ∂z(v) = 0\")\n\nsolver = NonlinearBoundaryValueSolver(problem)\n\nif solve!(solver)\n    println(\"Converged in $(solver.iterations) iterations\")\nelse\n    println(\"Failed to converge\")\nend\n\nProperties:\n\nsolver.iterations       # Number of iterations performed\nsolver.residual         # Final residual norm\nsolver.converged        # Convergence status\n\n","category":"section"},{"location":"api/solvers/#EigenvalueSolver","page":"Solvers API","title":"EigenvalueSolver","text":"Solver for Eigenvalue Problems (EVP).\n\nConstructor:\n\nEigenvalueSolver(\n    problem::EVP;\n    nev::Int=10,\n    target::Complex{Float64}=0.0+0.0im,\n    which::String=\"LM\"\n)\n\nArguments:\n\nproblem: EVP problem definition\nnev: Number of eigenvalues to compute\ntarget: Target eigenvalue for shift-invert\nwhich: Which eigenvalues to find (\"LM\", \"SM\", \"LR\", \"SR\", \"LI\", \"SI\")\n\nWhich options:\n\n\"LM\": Largest magnitude\n\"SM\": Smallest magnitude\n\"LR\": Largest real part\n\"SR\": Smallest real part\n\"LI\": Largest imaginary part\n\"SI\": Smallest imaginary part\n\nExamples:\n\n# Find 10 eigenvalues with largest growth rate\nsolver = EigenvalueSolver(problem, nev=10, which=\"LR\")\n\n# Find eigenvalues near target\nsolver = EigenvalueSolver(problem, nev=5, target=0.1+1.5im)\n\n# Most unstable modes\nsolver = EigenvalueSolver(problem, nev=20, which=\"LR\")\n\nMethods:","category":"section"},{"location":"api/solvers/#solve!-3","page":"Solvers API","title":"solve!","text":"Compute eigenvalues and eigenvectors.\n\neigenvalues, eigenvectors = solve!(solver)\n\nReturns:\n\neigenvalues: Array of complex eigenvalues\neigenvectors: Array of eigenvector fields\n\nExample:\n\n# Rayleigh-Bénard stability\nproblem = EVP([u, v, p, T], eigenvalue=:sigma)\n# ... add equations and BCs ...\n\nsolver = EigenvalueSolver(problem, nev=10, which=\"LR\")\neigenvalues, eigenvectors = solve!(solver)\n\n# Find critical mode\nmax_idx = argmax(real.(eigenvalues))\ngrowth_rate = real(eigenvalues[max_idx])\nfrequency = imag(eigenvalues[max_idx])\n\nprintln(\"Maximum growth rate: $growth_rate\")\nprintln(\"Frequency: $frequency\")\n\n# Extract critical mode\ncritical_mode = eigenvectors[max_idx]\n\n","category":"section"},{"location":"api/solvers/#Solver-State-Management","page":"Solvers API","title":"Solver State Management","text":"","category":"section"},{"location":"api/solvers/#Saving-and-Loading-State","page":"Solvers API","title":"Saving and Loading State","text":"# Save solver state\nsave_state(solver, \"checkpoint.h5\")\n\n# Load solver state\nload_state!(solver, \"checkpoint.h5\")\n\n# Resume simulation\nwhile proceed(solver)\n    step!(solver)\nend","category":"section"},{"location":"api/solvers/#State-Vector-Access","page":"Solvers API","title":"State Vector Access","text":"# Get state vector\nstate = get_state(solver)\n\n# Set state vector\nset_state!(solver, new_state)\n\n# Useful for custom initialization or analysis\n\n","category":"section"},{"location":"api/solvers/#Time-Integration","page":"Solvers API","title":"Time Integration","text":"","category":"section"},{"location":"api/solvers/#Time-Stepping-Loop","page":"Solvers API","title":"Time Stepping Loop","text":"Basic pattern for time integration:\n\n# Create solver\nsolver = InitialValueSolver(problem, RK222(), dt=0.001)\n\n# Set stop conditions\nt_end = 10.0\n\n# Time loop\nwhile solver.sim_time < t_end\n    step!(solver)\n\n    # Optional: output and diagnostics\n    if solver.iteration % 100 == 0\n        println(\"t = $(solver.sim_time), iteration = $(solver.iteration)\")\n    end\nend","category":"section"},{"location":"api/solvers/#Adaptive-Time-Stepping","page":"Solvers API","title":"Adaptive Time Stepping","text":"With CFL condition:\n\n# Create CFL calculator\ncfl = CFL(problem, safety=0.5, max_change=1.5, min_change=0.5)\nadd_velocity!(cfl, u)\n\n# Adaptive loop\nwhile solver.sim_time < t_end\n    # Compute adaptive timestep\n    dt = compute_timestep(cfl)\n\n    # Take step\n    step!(solver, dt)\nend","category":"section"},{"location":"api/solvers/#Output-During-Integration","page":"Solvers API","title":"Output During Integration","text":"# Setup output handler\noutput = add_netcdf_handler(\n    solver,\n    \"output\",\n    fields=[u, p, T],\n    write_interval=0.1\n)\n\n# Time loop with automatic output\nwhile solver.sim_time < t_end\n    dt = compute_timestep(cfl)\n    step!(solver, dt)\n    # Output written automatically when t > next_write_time\nend\n\n","category":"section"},{"location":"api/solvers/#Solver-Options","page":"Solvers API","title":"Solver Options","text":"","category":"section"},{"location":"api/solvers/#Convergence-Criteria","page":"Solvers API","title":"Convergence Criteria","text":"For iterative and nonlinear solvers:\n\nsolver.tolerance = 1e-10           # Residual tolerance\nsolver.max_iterations = 1000       # Maximum iterations\nsolver.relative_tolerance = 1e-8   # Relative change tolerance","category":"section"},{"location":"api/solvers/#Performance-Options","page":"Solvers API","title":"Performance Options","text":"# Parallel options\nsolver.use_threading = true\nsolver.num_threads = 4\n\n# Memory options\nsolver.preallocate_work = true\nsolver.work_array_count = 5\n\n","category":"section"},{"location":"api/solvers/#Advanced-Solver-Features","page":"Solvers API","title":"Advanced Solver Features","text":"","category":"section"},{"location":"api/solvers/#Preconditioners","page":"Solvers API","title":"Preconditioners","text":"For iterative solvers:\n\n# Set preconditioner type\nsolver.preconditioner = \"jacobi\"  # or \"ilu\", \"multigrid\"\n\n# Custom preconditioner\nfunction my_preconditioner(A, b)\n    # Custom preconditioning operation\n    return P \\ b\nend\n\nsolver.preconditioner = my_preconditioner","category":"section"},{"location":"api/solvers/#Matrix-Free-Methods","page":"Solvers API","title":"Matrix-Free Methods","text":"For large problems:\n\n# Use matrix-free Krylov methods\nsolver.matrix_free = true\nsolver.krylov_method = \"gmres\"  # or \"bicgstab\", \"cg\"","category":"section"},{"location":"api/solvers/#Continuation-Methods","page":"Solvers API","title":"Continuation Methods","text":"For nonlinear problems:\n\n# Parameter continuation\nRa_values = [1e4, 5e4, 1e5, 5e5, 1e6]\n\nsolution = nothing\nfor Ra in Ra_values\n    problem.parameters[\"Ra\"] = Ra\n\n    if solution !== nothing\n        # Use previous solution as initial guess\n        set_state!(solver, solution)\n    end\n\n    solve!(solver)\n    solution = get_state(solver)\n\n    println(\"Solved for Ra = $Ra\")\nend\n\n","category":"section"},{"location":"api/solvers/#Solver-Diagnostics","page":"Solvers API","title":"Solver Diagnostics","text":"","category":"section"},{"location":"api/solvers/#Convergence-Monitoring","page":"Solvers API","title":"Convergence Monitoring","text":"# Enable convergence monitoring\nsolver.verbose = true\nsolver.print_interval = 10\n\n# Custom convergence callback\nfunction convergence_callback(solver, iteration, residual)\n    if iteration % 10 == 0\n        println(\"Iteration $iteration: residual = $residual\")\n    end\nend\n\nsolver.convergence_callback = convergence_callback","category":"section"},{"location":"api/solvers/#Performance-Profiling","page":"Solvers API","title":"Performance Profiling","text":"# Enable profiling\nsolver.profile = true\n\n# After solving\nprint_performance_summary(solver)\n# Outputs:\n# - Time per iteration\n# - Time in different solver phases\n# - Memory usage\n# - Communication time (MPI)\n\n","category":"section"},{"location":"api/solvers/#Error-Handling","page":"Solvers API","title":"Error Handling","text":"","category":"section"},{"location":"api/solvers/#Solver-Failures","page":"Solvers API","title":"Solver Failures","text":"try\n    solve!(solver)\ncatch e\n    if isa(e, ConvergenceError)\n        println(\"Failed to converge: $(e.message)\")\n        println(\"Residual: $(e.residual)\")\n    elseif isa(e, LinearAlgebraError)\n        println(\"Linear algebra error: $(e.message)\")\n    else\n        rethrow(e)\n    end\nend","category":"section"},{"location":"api/solvers/#Recovery-Strategies","page":"Solvers API","title":"Recovery Strategies","text":"# For nonlinear solvers\nif !solver.converged\n    # Try with damping\n    solver.damping = 0.5\n    solve!(solver)\n\n    if !solver.converged\n        # Try with better initial guess\n        # ... provide better initialization\n        solve!(solver)\n    end\nend\n\n","category":"section"},{"location":"api/solvers/#Complete-Example","page":"Solvers API","title":"Complete Example","text":"","category":"section"},{"location":"api/solvers/#Time-Dependent-Simulation","page":"Solvers API","title":"Time-Dependent Simulation","text":"using Tarang, MPI\n\nMPI.Init()\n\n# Setup problem (2D Rayleigh-Bénard)\ncoords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords, mesh=(2, 2))\n\nx_basis = RealFourier(coords[\"x\"], size=256, bounds=(0.0, 4.0))\nz_basis = ChebyshevT(coords[\"z\"], size=64, bounds=(0.0, 1.0))\n\ndomain = Domain(dist, (x_basis, z_basis))\n\nu = VectorField(dist, coords, \"u\", (x_basis, z_basis))\np = ScalarField(dist, \"p\", (x_basis, z_basis))\nT = ScalarField(dist, \"T\", (x_basis, z_basis))\n\n# Define problem\nproblem = IVP([u.components[1], u.components[2], p, T])\nproblem.parameters[\"Ra\"] = 1e6\nproblem.parameters[\"Pr\"] = 1.0\n\nadd_equation!(problem, \"∂t(u) + u*∂x(u) + w*∂z(u) + ∂x(p) = Pr*Δ(u)\")\nadd_equation!(problem, \"∂t(w) + u*∂x(w) + w*∂z(w) + ∂z(p) = Pr*Δ(w) + Ra*Pr*T\")\nadd_equation!(problem, \"∂x(u) + ∂z(w) = 0\")\nadd_equation!(problem, \"∂t(T) + u*∂x(T) + w*∂z(T) = Δ(T)\")\n\n# Boundary conditions\nadd_equation!(problem, \"u(z=0) = 0\")\nadd_equation!(problem, \"w(z=0) = 0\")\nadd_equation!(problem, \"T(z=0) = 1\")\nadd_equation!(problem, \"u(z=1) = 0\")\nadd_equation!(problem, \"w(z=1) = 0\")\nadd_equation!(problem, \"T(z=1) = 0\")\n\n# Initialize fields\n# ... set initial conditions ...\n\n# Create solver\nsolver = InitialValueSolver(problem, RK222(), dt=1e-4)\n\n# CFL condition\ncfl = CFL(problem, safety=0.5)\nadd_velocity!(cfl, u)\n\n# Output\noutput = add_netcdf_handler(solver, \"output\", fields=[u, p, T], write_interval=0.1)\n\n# Time integration\nt_end = 10.0\nwhile solver.sim_time < t_end\n    dt = compute_timestep(cfl)\n    step!(solver, dt)\n\n    if solver.iteration % 100 == 0 && MPI.Comm_rank(MPI.COMM_WORLD) == 0\n        println(\"t = $(solver.sim_time), dt = $dt\")\n    end\nend\n\nMPI.Finalize()\n\n","category":"section"},{"location":"api/solvers/#See-Also","page":"Solvers API","title":"See Also","text":"Problems: Problem definition\nTimesteppers: Time integration schemes\nAnalysis: CFL conditions and diagnostics\nTutorial: IVP: Complete example","category":"section"},{"location":"pages/gql_approximation/#Generalized-Quasi-Linear-(GQL)-Approximation","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Generalized Quasi-Linear (GQL) Approximation","text":"Wavenumber-based scale separation for turbulence modeling and wave-mean flow interactions.\n\nReference: Marston, Chini & Tobias (2016). \"Generalized Quasilinear Approximation: Application to Zonal Jets\". Phys. Rev. Lett. 116, 214501.\n\n","category":"section"},{"location":"pages/gql_approximation/#TL;DR-Quick-Summary","page":"Generalized Quasi-Linear (GQL) Approximation","title":"TL;DR - Quick Summary","text":"What: Splits fields into large-scale (|k| ≤ Λ) and small-scale (|k| > Λ) components in Fourier spaceWhy: Enables systematic approximations between full nonlinear (NL) and quasi-linear (QL) dynamicsKey insight: By varying Λ from 0 to k_max, you interpolate between QL (cheap) and NL (expensive)Which system to use:GQLDecomposition - Pure spectral decomposition (you handle FFTs)\nGQLWaveMeanSystem - Combined GQL + temporal filtering for complete wave-mean analysis\n\n","category":"section"},{"location":"pages/gql_approximation/#Quick-Start","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Quick Start","text":"","category":"section"},{"location":"pages/gql_approximation/#Basic-GQL-Decomposition-(4-lines-of-code)","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Basic GQL Decomposition (4 lines of code)","text":"using Tarang\nusing FFTW\n\n# 1. Create GQL decomposition: 64×64 grid, domain 2π×2π, cutoff |k| ≤ 4\ngql = GQLDecomposition((64, 64), (2π, 2π); Λ=4.0)\n\n# 2. Decompose your spectral field\nf_hat = rfft(f)  # Your field in spectral space\nf_large, f_small = decompose!(gql, f_hat)\n\n# 3. Use in your simulation\n# f_large: large-scale modes (|k| ≤ Λ)\n# f_small: small-scale modes (|k| > Λ)","category":"section"},{"location":"pages/gql_approximation/#Complete-Working-Example","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Complete Working Example","text":"using Tarang\nusing FFTW\n\n# Domain setup\nNx, Ny = 64, 64\nLx, Ly = 2π, 2π\nx = range(0, Lx, length=Nx+1)[1:end-1]\ny = range(0, Ly, length=Ny+1)[1:end-1]\n\n# Create test field: large-scale + small-scale\nf = zeros(Nx, Ny)\nfor j in 1:Ny, i in 1:Nx\n    # Large scale: k = 2\n    f[i,j] += sin(2*x[i]) * cos(2*y[j])\n    # Small scale: k = 10\n    f[i,j] += 0.3 * sin(10*x[i]) * cos(10*y[j])\nend\n\n# Create GQL decomposition with cutoff Λ = 5\n# This will separate k ≤ 5 (large) from k > 5 (small)\ngql = GQLDecomposition((Nx, Ny), (Lx, Ly); Λ=5.0)\n\n# Decompose\nf_hat = rfft(f)\nf_L_hat, f_S_hat = decompose!(gql, f_hat)\n\n# Transform back to physical space\nf_large = irfft(f_L_hat, Nx)  # Contains only k=2 mode\nf_small = irfft(f_S_hat, Nx)  # Contains only k=10 mode\n\n# Verify\nprintln(\"Large-scale max: \", maximum(abs.(f_large)))  # ≈ 1.0\nprintln(\"Small-scale max: \", maximum(abs.(f_small)))  # ≈ 0.3\nprintln(\"f ≈ f_L + f_S: \", maximum(abs.(f - f_large - f_small)))  # ≈ 0\n\n","category":"section"},{"location":"pages/gql_approximation/#Understanding-the-GQL-Approximation","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Understanding the GQL Approximation","text":"","category":"section"},{"location":"pages/gql_approximation/#Scale-Separation-in-Fourier-Space","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Scale Separation in Fourier Space","text":"The GQL approximation splits any field f into two parts based on wavenumber magnitude:\n\nf = f_L + f_S\n\nwhere:\n\nf_L = Large-scale (low wavenumber): modes with |k| ≤ Λ\nf_S = Small-scale (high wavenumber): modes with |k| > Λ\n\nWavenumber space (2D example):\n                    ky\n                    ↑\n                    │    Small-scale\n                    │      (|k| > Λ)\n            ────────┼────────\n           /        │        \\\n          /    ┌────┼────┐    \\\n         │     │    │    │     │\n    ─────┼─────┼────┼────┼─────┼───→ kx\n         │     │ Large   │     │\n          \\    │ scale  │    /\n           \\   └────────┘   /\n            ────────────────\n                    │\n\n    Inner circle: |k| ≤ Λ (Large-scale)\n    Outer region: |k| > Λ (Small-scale)","category":"section"},{"location":"pages/gql_approximation/#The-GQL-Hierarchy","page":"Generalized Quasi-Linear (GQL) Approximation","title":"The GQL Hierarchy","text":"By varying the cutoff Λ, you get different approximations:\n\nΛ Value Name Nonlinear Terms Cost Accuracy\nΛ = 0 QL (Quasi-Linear) Only NL(fL, fL) Cheapest Lowest\n0 < Λ < k_max GQL NL(fL, fL) + NL(fS, fS) projected to L Intermediate Better\nΛ = k_max Full NL All terms Most expensive Exact","category":"section"},{"location":"pages/gql_approximation/#GQL-Equations","page":"Generalized Quasi-Linear (GQL) Approximation","title":"GQL Equations","text":"For a generic nonlinear PDE ∂f/∂t = NL(f, f) + L(f):\n\nLarge-scale equation:\n\n∂f_L/∂t = NL(f_L, f_L) + P_L[NL(f_S, f_S)] + L(f_L)\n                         ↑ eddy feedback\n\nSmall-scale equation:\n\n∂f_S/∂t = NL(f_L, f_S) + NL(f_S, f_L) + L(f_S)\n          ↑ linear in f_S (no f_S self-interaction!)\n\nKey simplification: The NL(fS, fS) term is dropped from the small-scale equation!\n\n","category":"section"},{"location":"pages/gql_approximation/#API-Reference","page":"Generalized Quasi-Linear (GQL) Approximation","title":"API Reference","text":"","category":"section"},{"location":"pages/gql_approximation/#GQLDecomposition","page":"Generalized Quasi-Linear (GQL) Approximation","title":"GQLDecomposition","text":"Pure wavenumber decomposition without temporal filtering.\n\n# Constructor\ngql = GQLDecomposition(field_size, domain_size; Λ, dtype=Float64)\n\n# Arguments:\n#   field_size  - Physical space size, e.g., (Nx, Ny) or (Nx, Ny, Nz)\n#   domain_size - Horizontal domain size, e.g., (Lx, Ly)\n#   Λ           - Cutoff wavenumber\n#   dtype       - Element type (default: Float64)","category":"section"},{"location":"pages/gql_approximation/#Methods","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Methods","text":"Function Description\ndecompose!(gql, f_hat) Split into (flarge, fsmall)\nproject_large!(gql, f_hat) Zero out k > Λ (in-place)\nproject_small!(gql, f_hat) Zero out k ≤ Λ (in-place)\nget_cutoff(gql) Get current Λ\nset_cutoff!(gql, Λ_new) Change Λ (rebuilds mask)\ncount_large_modes(gql) Number of large-scale modes\ncount_small_modes(gql) Number of small-scale modes","category":"section"},{"location":"pages/gql_approximation/#Example:-In-place-Projection","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Example: In-place Projection","text":"# Instead of decompose!, you can project in-place\nf_hat = rfft(f)\n\n# Option 1: Get both components\nf_L, f_S = decompose!(gql, f_hat)\n\n# Option 2: Project in-place (modifies f_hat)\nf_hat_copy = copy(f_hat)\nproject_large!(gql, f_hat_copy)  # Now contains only modes with k ≤ Λ\n\n","category":"section"},{"location":"pages/gql_approximation/#GQLWaveMeanSystem","page":"Generalized Quasi-Linear (GQL) Approximation","title":"GQLWaveMeanSystem","text":"Combined GQL decomposition with temporal filtering for wave-mean flow analysis.\n\n# Constructor\nsys = GQLWaveMeanSystem(field_size, domain_size; Λ, α, horizontal_dims=(1,2), dtype=Float64)\n\n# Arguments:\n#   field_size      - Physical space size\n#   domain_size     - Horizontal domain size\n#   Λ               - GQL wavenumber cutoff\n#   α               - Temporal filter parameter (1/averaging_time)\n#   horizontal_dims - Dimensions for horizontal averaging","category":"section"},{"location":"pages/gql_approximation/#Methods-2","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Methods","text":"Function Description\nadd_field!(sys, :u) Register field for decomposition\nadd_flux!(sys, :uw) Register flux product ⟨u'w'⟩\nupdate!(sys, fields_hat, fields_phys, dt) Update decomposition and filters\nget_large(sys, :u) Large-scale spectral component\nget_small(sys, :u) Small-scale spectral component\nget_mean(sys, :u) Time-filtered mean profile (1D)\nget_flux(sys, :uw) Filtered wave flux profile\nget_cutoff(sys) Get Λ\nset_cutoff!(sys, Λ_new) Change Λ\n\n","category":"section"},{"location":"pages/gql_approximation/#Complete-GQL-Simulation-Example","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Complete GQL Simulation Example","text":"","category":"section"},{"location":"pages/gql_approximation/#2D-Barotropic-Vorticity-(β-plane)","page":"Generalized Quasi-Linear (GQL) Approximation","title":"2D Barotropic Vorticity (β-plane)","text":"using Tarang\nusing FFTW\nusing LinearAlgebra\n\n# ============================================================================\n# GQL simulation of 2D turbulence with β-effect (zonal jet formation)\n# ============================================================================\n\n# Grid\nNx, Ny = 128, 128\nLx, Ly = 2π, 2π\ndx, dy = Lx/Nx, Ly/Ny\n\n# Wavenumbers\nkx = rfftfreq(Nx, 2π/dx)\nky = fftfreq(Ny, 2π/dy)\nKX = [kx[i] for i in 1:length(kx), j in 1:Ny]\nKY = [ky[j] for i in 1:length(kx), j in 1:Ny]\nK2 = KX.^2 .+ KY.^2\nK2[1,1] = 1  # Avoid division by zero\n\n# Physical parameters\nβ = 10.0     # β-effect (planetary vorticity gradient)\nν = 1e-4     # Viscosity\ndt = 0.001\nnsteps = 10000\n\n# GQL setup: cutoff at Λ = 4 (only large scales interact nonlinearly)\nΛ = 4.0\ngql = GQLDecomposition((Nx, Ny), (Lx, Ly); Λ=Λ)\n\nprintln(\"GQL cutoff Λ = \", Λ)\nprintln(\"Large-scale modes: \", count_large_modes(gql))\nprintln(\"Small-scale modes: \", count_small_modes(gql))\n\n# Initial condition: small random perturbation\nζ = 0.1 * randn(Nx, Ny)\nζ_hat = rfft(ζ)\n\n# Preallocate\nψ_hat = similar(ζ_hat)\nu_hat = similar(ζ_hat)\nv_hat = similar(ζ_hat)\nNL_hat = similar(ζ_hat)\n\n# Time stepping (RK4)\nfunction compute_rhs!(rhs, ζ_hat, gql, K2, KX, KY, β, ν)\n    # Stream function: ψ = -ζ/k²\n    @. ψ_hat = -ζ_hat / K2\n\n    # Velocity: u = -∂ψ/∂y, v = ∂ψ/∂x\n    @. u_hat = -im * KY * ψ_hat\n    @. v_hat =  im * KX * ψ_hat\n\n    # Transform to physical space\n    ζ = irfft(ζ_hat, Nx)\n    u = irfft(u_hat, Nx)\n    v = irfft(v_hat, Nx)\n\n    # ========================================\n    # GQL APPROXIMATION: Decompose velocity\n    # ========================================\n    u_hat_full = rfft(u)\n    v_hat_full = rfft(v)\n\n    # Large-scale velocity\n    u_L_hat, u_S_hat = decompose!(gql, u_hat_full)\n    u_L = irfft(copy(u_L_hat), Nx)\n\n    v_L_hat, v_S_hat = decompose!(gql, v_hat_full)\n    v_L = irfft(copy(v_L_hat), Nx)\n\n    # Small-scale velocity\n    u_S = irfft(copy(u_S_hat), Nx)\n    v_S = irfft(copy(v_S_hat), Nx)\n\n    # Vorticity decomposition\n    ζ_L_hat, ζ_S_hat = decompose!(gql, copy(ζ_hat))\n    ζ_L = irfft(copy(ζ_L_hat), Nx)\n    ζ_S = irfft(copy(ζ_S_hat), Nx)\n\n    # ========================================\n    # GQL Nonlinear terms\n    # ========================================\n    # Large-scale: NL(u_L, ζ_L) + project_L(NL(u_S, ζ_S))\n    NL_LL = u_L .* irfft(im * KX .* ζ_L_hat, Nx) .+\n            v_L .* irfft(im * KY .* ζ_L_hat, Nx)\n\n    NL_SS = u_S .* irfft(im * KX .* ζ_S_hat, Nx) .+\n            v_S .* irfft(im * KY .* ζ_S_hat, Nx)\n    NL_SS_hat = rfft(NL_SS)\n    project_large!(gql, NL_SS_hat)  # Keep only |k| ≤ Λ\n\n    # Small-scale: NL(u_L, ζ_S) + NL(u_S, ζ_L)  [NO NL(u_S, ζ_S)]\n    NL_LS = u_L .* irfft(im * KX .* ζ_S_hat, Nx) .+\n            v_L .* irfft(im * KY .* ζ_S_hat, Nx)\n    NL_SL = u_S .* irfft(im * KX .* ζ_L_hat, Nx) .+\n            v_S .* irfft(im * KY .* ζ_L_hat, Nx)\n\n    # Combine\n    NL_large = rfft(NL_LL) .+ NL_SS_hat\n    NL_small = rfft(NL_LS .+ NL_SL)\n\n    # Total advection (GQL)\n    @. NL_hat = NL_large + NL_small\n\n    # RHS: -u·∇ζ - βv + ν∇²ζ\n    @. rhs = -NL_hat - β * im * KX * ψ_hat - ν * K2 * ζ_hat\nend\n\n# Main time loop\nk1, k2, k3, k4 = similar(ζ_hat), similar(ζ_hat), similar(ζ_hat), similar(ζ_hat)\nζ_tmp = similar(ζ_hat)\n\nfor step in 1:nsteps\n    # RK4 stages\n    compute_rhs!(k1, ζ_hat, gql, K2, KX, KY, β, ν)\n    @. ζ_tmp = ζ_hat + 0.5*dt*k1\n    compute_rhs!(k2, ζ_tmp, gql, K2, KX, KY, β, ν)\n    @. ζ_tmp = ζ_hat + 0.5*dt*k2\n    compute_rhs!(k3, ζ_tmp, gql, K2, KX, KY, β, ν)\n    @. ζ_tmp = ζ_hat + dt*k3\n    compute_rhs!(k4, ζ_tmp, gql, K2, KX, KY, β, ν)\n\n    @. ζ_hat = ζ_hat + (dt/6) * (k1 + 2*k2 + 2*k3 + k4)\n\n    # Diagnostics\n    if step % 1000 == 0\n        ζ = irfft(ζ_hat, Nx)\n        enstrophy = sum(ζ.^2) * dx * dy / (Lx * Ly)\n\n        # Zonal mean (x-average)\n        u = irfft(-im * KY .* (-ζ_hat ./ K2), Nx)\n        u_zonal = vec(mean(u, dims=1))\n\n        println(\"Step $step: Enstrophy = $(round(enstrophy, digits=4)), max|u_zonal| = $(round(maximum(abs.(u_zonal)), digits=4))\")\n    end\nend\n\n","category":"section"},{"location":"pages/gql_approximation/#Combining-GQL-with-Wave-Mean-Decomposition","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Combining GQL with Wave-Mean Decomposition","text":"For problems with clear wave-mean separation (e.g., internal waves + zonal flow):\n\nusing Tarang\nusing FFTW\n\n# Domain\nNx, Ny, Nz = 64, 64, 32\nLx, Ly = 2π, 2π\ndt = 0.01\n\n# Combined system: GQL (Λ=4) + temporal filter (α=0.1)\nsys = GQLWaveMeanSystem((Nx, Ny, Nz), (Lx, Ly); Λ=4.0, α=0.1)\n\n# Register fields\nadd_field!(sys, :u)\nadd_field!(sys, :v)\nadd_field!(sys, :w)\nadd_field!(sys, :b)\n\n# Register fluxes for Reynolds stress\nadd_flux!(sys, :uw)  # ⟨u'w'⟩\nadd_flux!(sys, :vw)  # ⟨v'w'⟩\nadd_flux!(sys, :wb)  # ⟨w'b'⟩\n\n# Time loop\nfor step in 1:nsteps\n    # Your PDE solver advances u, v, w, b\n    # ...\n\n    # Update GQL + temporal filtering\n    update!(sys, Dict(:u => u, :v => v, :w => w, :b => b), dt)\n\n    # Access decomposed fields\n    u_L = get_large(sys, :u)      # Large-scale (|k| ≤ Λ) in spectral space\n    u_S = get_small(sys, :u)      # Small-scale (|k| > Λ) in spectral space\n    u_mean = get_mean(sys, :u)    # Time-filtered horizontal mean ū(z)\n\n    # Access filtered Reynolds stress\n    R_uw = get_flux(sys, :uw)     # ⟨u'w'⟩(z) profile\n    R_wb = get_flux(sys, :wb)     # ⟨w'b'⟩(z) profile\n\n    # Use for forcing in mean equations:\n    # ∂ū/∂t = ... - ∂⟨u'w'⟩/∂z\n    # ∂b̄/∂t = ... - ∂⟨w'b'⟩/∂z\nend\n\n","category":"section"},{"location":"pages/gql_approximation/#Choosing-the-Cutoff-Λ","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Choosing the Cutoff Λ","text":"","category":"section"},{"location":"pages/gql_approximation/#Guidelines","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Guidelines","text":"Application Suggested Λ Rationale\nZonal jets (β-plane) 2-6 Capture jet scale, parameterize eddies\nConvection 4-10 Large convective cells are \"mean\"\nShear flow 1-4 Mean shear + harmonics\nTesting QL validity 0 then increase Compare QL → GQL → NL","category":"section"},{"location":"pages/gql_approximation/#Diagnostic:-Mode-Count","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Diagnostic: Mode Count","text":"gql = GQLDecomposition((128, 128), (2π, 2π); Λ=4.0)\n\nn_large = count_large_modes(gql)\nn_small = count_small_modes(gql)\nn_total = n_large + n_small\n\nprintln(\"Large-scale modes: $n_large ($(round(100*n_large/n_total, digits=1))%)\")\nprintln(\"Small-scale modes: $n_small ($(round(100*n_small/n_total, digits=1))%)\")\n\n# Typical output for Λ=4:\n# Large-scale modes: 49 (0.6%)\n# Small-scale modes: 8143 (99.4%)","category":"section"},{"location":"pages/gql_approximation/#Sweeping-Λ-to-Test-Convergence","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Sweeping Λ to Test Convergence","text":"# Test GQL accuracy by varying Λ\nfor Λ in [0, 2, 4, 8, 16, Inf]\n    gql = GQLDecomposition((64, 64), (2π, 2π); Λ=Λ)\n    # Run simulation...\n    # Compare statistics (energy, enstrophy, mean profiles)\nend\n\n","category":"section"},{"location":"pages/gql_approximation/#Performance-Considerations","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Performance Considerations","text":"","category":"section"},{"location":"pages/gql_approximation/#Memory","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Memory","text":"System Arrays per Field Notes\nGQLDecomposition 2 complex flarge, fsmall work arrays\nGQLWaveMeanSystem 2 complex + 3 real Plus temporal filter storage","category":"section"},{"location":"pages/gql_approximation/#Computational-Cost","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Computational Cost","text":"Mask application: O(N) per field, very fast\nFFT/IFFT: O(N log N), dominates cost\nGQL vs NL: Similar cost per step, but GQL may allow larger Λ (fewer modes in expensive nonlinear terms)","category":"section"},{"location":"pages/gql_approximation/#Optimization-Tips","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Optimization Tips","text":"Reuse FFT plans: Pre-compute plan_rfft and plan_irfft\nIn-place operations: Use project_large! instead of decompose! when possible\nBatch updates: Update all fields before computing fluxes\n\n","category":"section"},{"location":"pages/gql_approximation/#Theory:-Why-GQL-Works","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Theory: Why GQL Works","text":"","category":"section"},{"location":"pages/gql_approximation/#The-Eddy-Mean-Decomposition","page":"Generalized Quasi-Linear (GQL) Approximation","title":"The Eddy-Mean Decomposition","text":"Traditional Reynolds decomposition: f = f̄ + f'\n\nGQL generalizes this to spectral space:\n\nf_L contains the \"mean\" (but can include some wave structure)\nf_S contains the \"eddies\" (high-k fluctuations)","category":"section"},{"location":"pages/gql_approximation/#Scale-Interactions","page":"Generalized Quasi-Linear (GQL) Approximation","title":"Scale Interactions","text":"The nonlinear term NL(f, f) produces wavenumber triads (k₁, k₂, k₃) where k₁ + k₂ = k₃.\n\nGQL assumption: Small-scale self-interactions NL(f_S, f_S) that stay in the small scales can be neglected.\n\nThis is valid when:\n\nSmall scales are \"slaved\" to large scales\nEnergy cascade is local (not inverse cascade dominated)\nScale separation exists","category":"section"},{"location":"pages/gql_approximation/#When-GQL-Fails","page":"Generalized Quasi-Linear (GQL) Approximation","title":"When GQL Fails","text":"GQL may not capture:\n\nStrong inverse cascades (2D turbulence without β)\nIntermittency and extreme events\nSmall-scale instabilities\n\nAlways validate against full NL for your specific problem!\n\n","category":"section"},{"location":"pages/gql_approximation/#References","page":"Generalized Quasi-Linear (GQL) Approximation","title":"References","text":"Marston, Chini & Tobias (2016). \"Generalized Quasilinear Approximation: Application to Zonal Jets\". Phys. Rev. Lett. 116, 214501.\nTobias & Marston (2017). \"Three-dimensional rotating Couette flow via the generalised quasilinear approximation\". J. Fluid Mech. 810, 412-428.\nMarston, Chini & Tobias (2019). \"Generalized Quasilinear Approximation of the Interaction of Convection and Mean Flows\". Proc. R. Soc. A 474, 20180422.\nConstantinou & Parker (2018). \"Magnetic suppression of zonal flows on a beta plane\". Astrophys. J. 863, 46.\n\n","category":"section"},{"location":"pages/gql_approximation/#See-Also","page":"Generalized Quasi-Linear (GQL) Approximation","title":"See Also","text":"Temporal Filters - Time-domain filtering for wave-mean separation\nLES Models - Subgrid-scale modeling (alternative to GQL)\nStochastic Forcing - Adding stochastic terms to equations","category":"section"},{"location":"pages/analysis/#Analysis","page":"Analysis","title":"Analysis","text":"Analysis tools for computing diagnostics, statistics, and derived quantities.","category":"section"},{"location":"pages/analysis/#CFL-Condition","page":"Analysis","title":"CFL Condition","text":"Compute stable timesteps based on flow velocity.\n\nusing Tarang\n\n# Create CFL calculator\ncfl = CFL(problem;\n    safety=0.5,      # Safety factor (0.3-0.5 typical)\n    max_change=1.5,  # Max dt increase per step\n    min_change=0.5   # Max dt decrease per step\n)\n\n# Register velocity field\nadd_velocity!(cfl, u)\n\n# Optional limits\ncfl.max_dt = 0.01\ncfl.min_dt = 1e-8\n\n# Compute timestep\ndt = compute_timestep(cfl)","category":"section"},{"location":"pages/analysis/#Global-Reductions","page":"Analysis","title":"Global Reductions","text":"Compute global statistics across MPI processes.\n\nusing MPI\n\n# Create reducer\nreducer = GlobalArrayReducer(MPI.COMM_WORLD)\n\n# Maximum value\nglobal_max = reduce_scalar(reducer, local_max, MPI.MAX)\n\n# Sum\nglobal_sum = reduce_scalar(reducer, local_sum, MPI.SUM)\n\n# Mean (requires division by total elements)\nglobal_mean = global_sum / total_elements","category":"section"},{"location":"pages/analysis/#Flow-Statistics","page":"Analysis","title":"Flow Statistics","text":"","category":"section"},{"location":"pages/analysis/#Kinetic-Energy","page":"Analysis","title":"Kinetic Energy","text":"function compute_kinetic_energy(u, reducer)\n    local_energy = 0.0\n\n    for component in u.components\n        Tarang.ensure_layout!(component, :g)\n        local_energy += sum(component.data_g.^2) / 2\n    end\n\n    return reduce_scalar(reducer, local_energy, MPI.SUM)\nend","category":"section"},{"location":"pages/analysis/#Enstrophy","page":"Analysis","title":"Enstrophy","text":"function compute_enstrophy(u, reducer)\n    # For 2D: ω = ∂v/∂x - ∂u/∂y\n    # Enstrophy = ∫ ω² dV\n\n    ux, uy = u.components[1], u.components[2]\n\n    # Compute vorticity (simplified)\n    # ... derivative calculation ...\n\n    return reduce_scalar(reducer, local_enstrophy, MPI.SUM)\nend","category":"section"},{"location":"pages/analysis/#Reynolds-Number","page":"Analysis","title":"Reynolds Number","text":"function compute_reynolds_number(u, nu, L, reducer)\n    Tarang.ensure_layout!(u.components[1], :g)\n\n    # RMS velocity\n    local_u2 = sum(u.components[1].data_g.^2)\n    global_u2 = reduce_scalar(reducer, local_u2, MPI.SUM)\n    u_rms = sqrt(global_u2 / total_points)\n\n    return u_rms * L / nu\nend","category":"section"},{"location":"pages/analysis/#Heat-Transfer","page":"Analysis","title":"Heat Transfer","text":"","category":"section"},{"location":"pages/analysis/#Nusselt-Number","page":"Analysis","title":"Nusselt Number","text":"function compute_nusselt(T, w, L, kappa, reducer)\n    Tarang.ensure_layout!(T, :g)\n    Tarang.ensure_layout!(w, :g)\n\n    # Convective heat flux\n    local_flux = sum(T.data_g .* w.data_g)\n    global_flux = reduce_scalar(reducer, local_flux, MPI.SUM)\n\n    # Normalize\n    flux_mean = global_flux / total_points\n\n    # Nusselt = 1 + convective/conductive\n    Nu = 1.0 + flux_mean * L / kappa\n\n    return Nu\nend","category":"section"},{"location":"pages/analysis/#Spectral-Analysis","page":"Analysis","title":"Spectral Analysis","text":"","category":"section"},{"location":"pages/analysis/#Energy-Spectrum","page":"Analysis","title":"Energy Spectrum","text":"function compute_spectrum(field, kmax)\n    Tarang.ensure_layout!(field, :c)\n\n    # Initialize spectrum bins\n    E_k = zeros(kmax)\n\n    # Get wavenumbers\n    k = get_wavenumbers(field.bases[1])\n\n    # Bin energy by wavenumber\n    for (i, ki) in enumerate(k)\n        k_bin = round(Int, abs(ki))\n        if 1 <= k_bin <= kmax\n            E_k[k_bin] += abs2(field.data_c[i])\n        end\n    end\n\n    return E_k\nend","category":"section"},{"location":"pages/analysis/#Shell-Averaged-3D-Spectrum","page":"Analysis","title":"Shell-Averaged 3D Spectrum","text":"function compute_3d_spectrum(u, kmax)\n    E_k = zeros(kmax)\n\n    for component in u.components\n        Tarang.ensure_layout!(component, :c)\n\n        kx = get_wavenumbers(component.bases[1])\n        ky = get_wavenumbers(component.bases[2])\n        kz = get_wavenumbers(component.bases[3])\n\n        for i in eachindex(kx), j in eachindex(ky), k in eachindex(kz)\n            k_mag = sqrt(kx[i]^2 + ky[j]^2 + kz[k]^2)\n            k_bin = round(Int, k_mag)\n\n            if 1 <= k_bin <= kmax\n                E_k[k_bin] += abs2(component.data_c[i,j,k])\n            end\n        end\n    end\n\n    return E_k\nend","category":"section"},{"location":"pages/analysis/#Time-Series","page":"Analysis","title":"Time Series","text":"","category":"section"},{"location":"pages/analysis/#Recording-Diagnostics","page":"Analysis","title":"Recording Diagnostics","text":"# Storage\ntimes = Float64[]\nenergies = Float64[]\nnusselts = Float64[]\n\n# During simulation\nwhile solver.sim_time < t_end\n    step!(solver, dt)\n\n    # Record\n    push!(times, solver.sim_time)\n    push!(energies, compute_kinetic_energy(u, reducer))\n    push!(nusselts, compute_nusselt(T, w, L, kappa, reducer))\nend","category":"section"},{"location":"pages/analysis/#Saving-Time-Series","page":"Analysis","title":"Saving Time Series","text":"if MPI.Comm_rank(MPI.COMM_WORLD) == 0\n    using JLD2\n    @save \"diagnostics.jld2\" times energies nusselts\nend","category":"section"},{"location":"pages/analysis/#Spatial-Averages","page":"Analysis","title":"Spatial Averages","text":"","category":"section"},{"location":"pages/analysis/#Horizontal-Average","page":"Analysis","title":"Horizontal Average","text":"function horizontal_average(field)\n    Tarang.ensure_layout!(field, :g)\n\n    # Average over x (first axis)\n    mean(field.data_g, dims=1)\nend","category":"section"},{"location":"pages/analysis/#Volume-Average","page":"Analysis","title":"Volume Average","text":"function volume_average(field, reducer)\n    Tarang.ensure_layout!(field, :g)\n\n    local_sum = sum(field.data_g)\n    global_sum = reduce_scalar(reducer, local_sum, MPI.SUM)\n\n    return global_sum / total_points\nend","category":"section"},{"location":"pages/analysis/#See-Also","page":"Analysis","title":"See Also","text":"Output: File output\nSolvers: Time integration\nAPI: Analysis: Complete reference","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Tutorial:-2D-Rayleigh-Bénard-Convection","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Tutorial: 2D Rayleigh-Bénard Convection","text":"This tutorial demonstrates solving a classic fluid dynamics problem: Rayleigh-Bénard convection. We'll set up a complete simulation including equations, boundary conditions, adaptive time stepping, and output.","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Physical-Problem","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Physical Problem","text":"Rayleigh-Bénard convection occurs when a fluid layer is heated from below. The setup:\n\nHorizontal layer of fluid between two parallel plates\nBottom plate at temperature T_hot\nTop plate at temperature T_cold\nGravity acts downward\n\nWhen the temperature difference is large enough (high Rayleigh number), the fluid becomes unstable and convection cells form.","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Governing-Equations","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Governing Equations","text":"The Boussinesq equations for thermal convection:\n\nbeginaligned\nfracpartial mathbfupartial t + mathbfu cdot nabla mathbfu = -nabla p + textPr nabla^2 mathbfu + textRa cdot textPr cdot T  hatmathbfz \nnabla cdot mathbfu = 0 \nfracpartial Tpartial t + mathbfu cdot nabla T = nabla^2 T\nendaligned\n\nDimensionless parameters:\n\nRa (Rayleigh number): textRa = fracg alpha Delta T H^3nu kappa - ratio of buoyancy to viscous forces\nPr (Prandtl number): textPr = fracnukappa - ratio of momentum to thermal diffusivity\n\nVariables:\n\nmathbfu = (u w)\n: velocity field (horizontal u, vertical w)\np\n: pressure\nT\n: temperature (deviation from linear conduction profile)","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Domain-and-Discretization","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Domain and Discretization","text":"","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Coordinate-System","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Coordinate System","text":"2D Cartesian domain:\n\nx (horizontal): periodic, length L_x\nz (vertical): bounded by plates, height H = 1","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Spectral-Bases","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Spectral Bases","text":"# Periodic horizontal direction → Fourier\nx_basis = RealFourier(coords[\"x\"]; size=256, bounds=(0.0, 4.0))\n\n# Bounded vertical direction → Chebyshev\nz_basis = ChebyshevT(coords[\"z\"]; size=64, bounds=(0.0, 1.0))\n\nResolution guidelines:\n\nHorizontal: 128-512 modes (depends on aspect ratio and Ra)\nVertical: 32-128 modes (more for higher Ra)\nAspect ratio L_xH: typically 2-4 for 2D","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Complete-Implementation","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Complete Implementation","text":"","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Setup","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Setup","text":"using Tarang\nusing MPI\nusing Printf\n\n# Initialize MPI\nMPI.Init()\nrank = MPI.Comm_rank(MPI.COMM_WORLD)\nsize = MPI.Comm_size(MPI.COMM_WORLD)\n\n# Problem parameters\nRa = 1e6  # Rayleigh number\nPr = 1.0  # Prandtl number\nLx = 4.0  # Horizontal extent\nH = 1.0   # Vertical extent\n\n# Domain setup\ncoords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords, mesh=(2, 2))\n\n# Spectral bases\nNx, Nz = 256, 64\nx_basis = RealFourier(coords[\"x\"]; size=Nx, bounds=(0.0, Lx))\nz_basis = ChebyshevT(coords[\"z\"]; size=Nz, bounds=(0.0, H))\n\ndomain = Domain(dist, (x_basis, z_basis))","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Fields","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Fields","text":"# Create velocity field (vector with 2 components)\nu = VectorField(dist, coords, \"u\", (x_basis, z_basis))\nux = u.components[1]  # Horizontal velocity\nuz = u.components[2]  # Vertical velocity\n\n# Pressure field\np = ScalarField(dist, \"p\", (x_basis, z_basis))\n\n# Temperature field\nT = ScalarField(dist, \"T\", (x_basis, z_basis))","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Tau-Fields-(for-Boundary-Conditions)","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Tau Fields (for Boundary Conditions)","text":"Tarang.jl follows the Dedalus approach: users must explicitly create tau fields and add them to equations using the lift() operator.\n\n# Tau field for pressure (removes degeneracy in continuity equation)\ntau_p = ScalarField(dist, \"tau_p\", (), dtype)\n\n# Tau fields for temperature/buoyancy BCs (one per boundary)\ntau_T1 = ScalarField(dist, \"tau_T1\", (x_basis,), dtype)   # T at z=0\ntau_T2 = ScalarField(dist, \"tau_T2\", (x_basis,), dtype)   # T at z=1\n\n# Vector tau fields for velocity BCs (uses VectorField for compact notation)\ntau_u1 = VectorField(dist, coords, \"tau_u1\", (x_basis,), dtype)  # Velocity at z=0\ntau_u2 = VectorField(dist, coords, \"tau_u2\", (x_basis,), dtype)  # Velocity at z=1\n\ntip: Vector Tau Fields\nUsing VectorField for tau fields allows compact vector notation in equations. The components are accessed via tau_u1.components[1] (x) and tau_u1.components[2] (z).","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Problem-Definition","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Problem Definition","text":"# Collect all state variables (vector fields passed directly)\nproblem = IVP([u, p, T, tau_u1, tau_u2, tau_p, tau_T1, tau_T2])\n\n# Add substitutions for parameters (Dedalus-style)\nadd_substitution!(problem, \"Ra\", Ra)\nadd_substitution!(problem, \"Pr\", Pr)\nadd_substitution!(problem, \"Lz\", H)\n\n# Equations use vector notation (Dedalus-style)\n# Continuity: ∇·u = 0\nadd_equation!(problem, \"div(u) + tau_p = 0\")\n\n# Temperature equation: ∂T/∂t - ∇²T = -u·∇T\nadd_equation!(problem, \"∂t(T) - Δ(T) + lift(tau_T2) = -u⋅∇(T)\")\n\n# Momentum (vector equation): ∂u/∂t - Pr∇²u + ∇p = -u·∇u + Ra*Pr*T*ez\n# ez is the unit vector in z-direction (buoyancy acts vertically)\nadd_equation!(problem, \"∂t(u) - Pr*Δ(u) + ∇(p) + lift(tau_u2) = -u⋅∇(u) + Ra*Pr*T*ez\")","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Boundary-Conditions","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Boundary Conditions","text":"No-slip walls (velocity = 0) and fixed temperatures, using Dedalus-style string format:\n\n# Temperature BCs\nadd_bc!(problem, \"T(z=0) = 1\")      # Hot bottom\nadd_bc!(problem, \"T(z=Lz) = 0\")     # Cold top\n\n# Velocity BCs (no-slip at both walls) - vector notation\nadd_bc!(problem, \"u(z=0) = 0\")      # No-slip bottom (sets all components)\nadd_bc!(problem, \"u(z=Lz) = 0\")     # No-slip top\n\nnote: Equation String Syntax\nTarang.jl uses Dedalus-style string equations:Unicode operators: ∂t (time derivative), Δ (Laplacian), ∇ (gradient)\nVector advection: u⋅∇(u) for nonlinear term\nScalar advection: u⋅∇(T) for temperature advection\nUnit vectors: ex, ey, ez for directions (e.g., Ra*Pr*T*ez for buoyancy)\nVector BCs: u(z=0) = 0 sets all velocity components at the boundary","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Initial-Conditions","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Initial Conditions","text":"Add random perturbations to trigger convection:\n\n# Get grid-space data\nT_grid = get_grid_data(T)\n\n# Add small random perturbations\nRandom.seed!(42 + rank)  # Different seed per rank\nT_grid .= 0.5 .+ 0.01 .* (rand(size(T_grid)...) .- 0.5)\n\n# Transform to spectral space\nto_spectral!(T)\n\n# Velocity starts at zero (already initialized)","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Time-Stepper-and-Solver","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Time Stepper and Solver","text":"# Choose timestepper\n# RK222: Good for moderate Ra\n# CNAB2 or SBDF2: Better for high Ra (more stable for stiff problems)\ntimestepper = RK222()\n\n# Create solver\nsolver = InitialValueSolver(problem, timestepper, dt=1e-4)\n\nTimestepper selection:\n\nRa < 10⁵: RK222 or RK443 (IMEX Runge-Kutta)\nRa > 10⁵: CNAB2 or SBDF2 (IMEX multistep)\nVery high Ra: SBDF3 or SBDF4","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Adaptive-Time-Stepping-(CFL)","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Adaptive Time Stepping (CFL)","text":"# Create CFL condition\ncfl = CFL(problem, safety=0.4, max_change=1.5, min_change=0.5)\n\n# Add velocity field for CFL calculation\nadd_velocity!(cfl, u)\n\n# Set maximum timestep\ncfl.max_dt = 0.01\n\nCFL parameters:\n\nsafety: Safety factor (0.2-0.5, lower = more stable)\nmax_change: Maximum timestep increase per step\nmin_change: Maximum timestep decrease per step","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Output-and-Analysis","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Output and Analysis","text":"# File output handler\noutput_handler = add_netcdf_handler(\n    solver,\n    \"rayleigh_benard_output\",\n    fields=[ux, uz, p, T],\n    write_interval=0.1  # Write every 0.1 time units\n)\n\n# Analysis: Compute Nusselt number (heat flux)\nfunction compute_nusselt(T, uz)\n    # Nu = 1 + <uz*T> (horizontally averaged)\n    T_grid = get_grid_data(T)\n    uz_grid = get_grid_data(uz)\n\n    flux = mean(uz_grid .* T_grid, dims=1)  # Average over x\n    Nu = 1.0 .+ flux\n\n    return mean(Nu)  # Average over z as well\nend","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Time-Stepping-Loop","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Time-Stepping Loop","text":"# Simulation parameters\nt_end = 10.0\noutput_dt = 0.1\nnext_output = output_dt\n\n# Diagnostics\niteration = 0\nstart_time = time()\n\nif rank == 0\n    println(\"Starting Rayleigh-Bénard simulation\")\n    println(\"Ra = $Ra, Pr = $Pr\")\n    println(\"Resolution: $Nx × $Nz\")\n    println(\"MPI processes: $size\")\n    println(\"=\" ^ 60)\nend\n\n# Main time loop\nwhile solver.sim_time < t_end\n    # Compute adaptive timestep\n    dt = compute_timestep(cfl)\n\n    # Take a step\n    step!(solver, dt)\n\n    iteration += 1\n\n    # Output and diagnostics\n    if solver.sim_time >= next_output\n        # Compute Nusselt number\n        Nu = compute_nusselt(T, uz)\n\n        if rank == 0\n            elapsed = time() - start_time\n            @printf(\"t = %.3f, dt = %.2e, Nu = %.3f, wall_time = %.1fs\\n\",\n                    solver.sim_time, dt, Nu, elapsed)\n        end\n\n        next_output += output_dt\n    end\nend\n\nif rank == 0\n    total_time = time() - start_time\n    @printf(\"\\nSimulation complete!\\n\")\n    @printf(\"Total iterations: %d\\n\", iteration)\n    @printf(\"Total wall time: %.2f s\\n\", total_time)\n    @printf(\"Time per iteration: %.3f ms\\n\", 1000 * total_time / iteration)\nend\n\n# Cleanup\nMPI.Finalize()","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Running-the-Simulation","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Running the Simulation","text":"Save the complete script as rayleigh_benard_2d.jl and run:\n\n# Set threads\nexport OMP_NUM_THREADS=1\n\n# Run with 4 MPI processes\nmpiexec -n 4 julia --project rayleigh_benard_2d.jl\n\nExpected output:\n\nStarting Rayleigh-Bénard simulation\nRa = 1000000.0, Pr = 1.0\nResolution: 256 × 64\nMPI processes: 4\n============================================================\nt = 0.100, dt = 2.45e-04, Nu = 1.023, wall_time = 3.2s\nt = 0.200, dt = 2.31e-04, Nu = 1.156, wall_time = 6.5s\n...","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Physical-Interpretation","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Physical Interpretation","text":"","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Flow-Regimes","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Flow Regimes","text":"Different Rayleigh numbers produce different behaviors:\n\nRa Regime Characteristics\n< 1708 Conduction No flow, pure diffusion\n10³-10⁴ Steady rolls Regular convection cells\n10⁵-10⁶ Transitional Time-dependent, irregular\n> 10⁶ Turbulent Chaotic, small-scale structures","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Nusselt-Number","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Nusselt Number","text":"The Nusselt number measures heat transfer enhancement:\n\ntextNu = fractextTotal heat fluxtextConductive heat flux\n\nNu = 1: Pure conduction (no convection)\nNu > 1: Enhanced heat transfer due to convection\nHigher Ra → Higher Nu\n\nFor Rayleigh-Bénard convection:\n\nNu ≈ 1.0 for Ra < 1708\nNu ∝ Ra^(1/3) approximately for turbulent regime","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Visualization","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Visualization","text":"","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Basic-Plotting","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Basic Plotting","text":"using Plots\n\n# Extract data from one field\nT_grid = get_grid_data(T)\n\n# Plot temperature field\nheatmap(T_grid', xlabel=\"x\", ylabel=\"z\", title=\"Temperature\")\nsavefig(\"temperature.png\")","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Advanced-Analysis","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Advanced Analysis","text":"# Compute kinetic energy spectrum\nfunction compute_spectrum(u)\n    u_spectral = get_spectral_data(u)\n    energy = abs2.(u_spectral)\n\n    # Bin by wavenumber magnitude\n    # ... (see Analysis tutorial for details)\n\n    return k, E_k\nend\n\nk, E_k = compute_spectrum(ux)\nplot(k, E_k, xscale=:log10, yscale=:log10,\n     xlabel=\"k\", ylabel=\"E(k)\", label=\"Kinetic Energy\")","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Parameter-Studies","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Parameter Studies","text":"","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Exploring-Rayleigh-Number","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Exploring Rayleigh Number","text":"Study the transition to turbulence:\n\nRa_values = [1e4, 1e5, 1e6, 1e7]\n\nfor Ra in Ra_values\n    problem.parameters[\"Ra\"] = Ra\n    # ... run simulation and save Nu\nend","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Aspect-Ratio-Effects","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Aspect Ratio Effects","text":"Try different domain sizes:\n\naspect_ratios = [1.0, 2.0, 4.0, 8.0]\n\nfor ar in aspect_ratios\n    Lx = ar * H\n    x_basis = RealFourier(coords[\"x\"]; size=Int(128*ar), bounds=(0.0, Lx))\n    # ... run simulation\nend","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Performance-Optimization","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Performance Optimization","text":"","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Resolution-Requirements","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Resolution Requirements","text":"For Ra = 10⁶:\n\nMinimum: 128 × 32\nRecommended: 256 × 64\nHigh-resolution: 512 × 128\n\nScaling: For Ra × 10, increase resolution by ~1.5×","category":"section"},{"location":"tutorials/ivp_2d_rbc/#MPI-Process-Mesh","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"MPI Process Mesh","text":"Processes Recommended Mesh Domain\n4 (2, 2) Square/moderate aspect\n8 (4, 2) or (2, 4) Match domain aspect ratio\n16 (4, 4) Square mesh works well","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Timestep-Control","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Timestep Control","text":"# For stability at high Ra\ncfl.safety = 0.3  # Reduce if getting NaN\n\n# For efficiency\ncfl.max_dt = 0.01  # Don't let dt grow too large\ncfl.max_change = 1.2  # Smooth timestep changes","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Troubleshooting","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Troubleshooting","text":"","category":"section"},{"location":"tutorials/ivp_2d_rbc/#NaN-in-Solution","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"NaN in Solution","text":"Causes:\n\nTimestep too large\nRa too high for resolution\nInsufficient damping\n\nSolutions:\n\n# Reduce CFL safety factor\ncfl.safety = 0.2\n\n# Use more stable timestepper\ntimestepper = CNAB2()  # instead of RK222\n\n# Increase resolution\nNz = 128  # instead of 64","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Simulation-Not-Converging","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Simulation Not Converging","text":"For steady state:\n\nRun longer (convection takes time to develop)\nCheck initial conditions have perturbations\nVerify Ra > 1708 (critical value)","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Memory-Issues","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Memory Issues","text":"Solutions:\n\n# Reduce resolution\nNx, Nz = 128, 32\n\n# Use more MPI processes\nmesh=(4, 4)  # instead of (2, 2)","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Complete-Script","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Complete Script","text":"The full script is available in examples/rayleigh_benard_2d.jl. Key points:\n\nProper MPI initialization and finalization\nAppropriate bases for boundary conditions\nExplicit tau fields for each boundary condition\nlift() operators in all equations with non-periodic BCs\nComplete equation system with nonlinear terms\nAll boundary conditions linked to tau fields\nAdaptive time stepping with CFL\nOutput and analysis\nPerformance monitoring\n\ninfo: Dedalus-Style Approach\nThis tutorial follows the Dedalus approach for boundary conditions. Users must explicitly:Create tau fields (one per BC)\nAdd tau fields to the problem\nInclude lift() terms in equations\nLink each BC to its tau fieldSee Boundary Conditions Tutorial for more details.","category":"section"},{"location":"tutorials/ivp_2d_rbc/#Next-Steps","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"Next Steps","text":"3D Extension: Add third dimension\nEigenvalue Analysis: Compute stability\nCustom Analysis: Advanced diagnostics","category":"section"},{"location":"tutorials/ivp_2d_rbc/#References","page":"Tutorial: 2D Rayleigh-Bénard Convection","title":"References","text":"Chandrasekhar, S. (1961). Hydrodynamic and Hydromagnetic Stability\nTritton, D. J. (1988). Physical Fluid Dynamics\nSpectral Methods Resources","category":"section"},{"location":"pages/les_models/#Large-Eddy-Simulation-(LES)-Models","page":"Large Eddy Simulation (LES) Models","title":"Large Eddy Simulation (LES) Models","text":"This page provides a comprehensive introduction to Large Eddy Simulation (LES) and the subgrid-scale (SGS) closure models available in Tarang.jl.\n\n","category":"section"},{"location":"pages/les_models/#What-is-Large-Eddy-Simulation?","page":"Large Eddy Simulation (LES) Models","title":"What is Large Eddy Simulation?","text":"","category":"section"},{"location":"pages/les_models/#The-Turbulence-Challenge","page":"Large Eddy Simulation (LES) Models","title":"The Turbulence Challenge","text":"Turbulent flows contain a vast range of length scales, from the largest energy-containing eddies down to the smallest dissipative scales (Kolmogorov scales). In a Direct Numerical Simulation (DNS), we resolve all these scales, which requires:\n\nN sim Re^94\n\ngrid points in 3D, where Re is the Reynolds number. For atmospheric or oceanic flows with Re sim 10^9, this is computationally impossible.","category":"section"},{"location":"pages/les_models/#The-LES-Approach","page":"Large Eddy Simulation (LES) Models","title":"The LES Approach","text":"Large Eddy Simulation offers a practical alternative:\n\nResolve the large, energy-containing eddies directly\nModel the effect of small, unresolved eddies\n\n┌─────────────────────────────────────────────────────────────┐\n│                    Energy Spectrum E(k)                      │\n│                                                              │\n│    E(k)                                                      │\n│     │                                                        │\n│     │   ╭──╮                                                 │\n│     │  ╱    ╲          k^(-5/3)                              │\n│     │ ╱      ╲___                                            │\n│     │╱            ╲___                                       │\n│     │                  ╲___                                  │\n│     │                       ╲___                             │\n│     └──────────────────────────────────────────────► k       │\n│         │                    │                               │\n│         │◄── Resolved ──────►│◄── Modeled (SGS) ──►│        │\n│         │   (large eddies)   │   (small eddies)    │        │\n│                              │                               │\n│                          filter cutoff (Δ)                   │\n└─────────────────────────────────────────────────────────────┘\n\nThe filter width Delta (typically the grid spacing) separates resolved from unresolved scales.","category":"section"},{"location":"pages/les_models/#Filtering-the-Navier-Stokes-Equations","page":"Large Eddy Simulation (LES) Models","title":"Filtering the Navier-Stokes Equations","text":"We apply a spatial filter to decompose velocity into resolved (baru) and subgrid (u) parts:\n\nu = baru + u\n\nFiltering the incompressible Navier-Stokes equations gives:\n\nfracpartial baru_ipartial t + baru_j fracpartial baru_ipartial x_j = -frac1rhofracpartial barppartial x_i + nu nabla^2 baru_i - fracpartial tau_ijpartial x_j\n\nwhere the subgrid-scale (SGS) stress tensor appears:\n\ntau_ij = overlineu_i u_j - baru_i baru_j\n\nThis tensor represents the effect of unresolved turbulent motions on the resolved flow. Since we cannot compute tau_ij directly (it involves unresolved velocities), we must model it.\n\n","category":"section"},{"location":"pages/les_models/#The-Closure-Problem","page":"Large Eddy Simulation (LES) Models","title":"The Closure Problem","text":"","category":"section"},{"location":"pages/les_models/#Why-We-Need-Models","page":"Large Eddy Simulation (LES) Models","title":"Why We Need Models","text":"The SGS stress tau_ij contains information about scales we don't resolve. This creates the closure problem: our filtered equations have more unknowns than equations.","category":"section"},{"location":"pages/les_models/#The-Eddy-Viscosity-Hypothesis","page":"Large Eddy Simulation (LES) Models","title":"The Eddy Viscosity Hypothesis","text":"Most SGS models use the Boussinesq hypothesis, which assumes the SGS stress is proportional to the resolved strain rate:\n\ntau_ij - frac13tau_kkdelta_ij = -2 nu_e barS_ij\n\nwhere:\n\nnu_e\nis the eddy viscosity (to be modeled)\nbarS_ij\nis the resolved strain rate tensor:\n\nbarS_ij = frac12left(fracpartial baru_ipartial x_j + fracpartial baru_jpartial x_iright)\n\nThis transforms the filtered momentum equation into:\n\nfracpartial baru_ipartial t + baru_j fracpartial baru_ipartial x_j = -frac1rhofracpartial barp^*partial x_i + (nu + nu_e) nabla^2 baru_i\n\nwhere we've absorbed the isotropic part into a modified pressure barp^*.\n\nKey insight: The SGS model effectively adds a spatially-varying viscosity nu_e(xt) to the molecular viscosity nu.\n\n","category":"section"},{"location":"pages/les_models/#Energy-Cascade-and-Dissipation","page":"Large Eddy Simulation (LES) Models","title":"Energy Cascade and Dissipation","text":"","category":"section"},{"location":"pages/les_models/#Forward-Energy-Cascade","page":"Large Eddy Simulation (LES) Models","title":"Forward Energy Cascade","text":"In 3D turbulence, energy flows from large scales to small scales (forward cascade):\n\nLarge eddies ──► Medium eddies ──► Small eddies ──► Dissipation\n  (production)                                        (ε = 2νSᵢⱼSᵢⱼ)\n\nThe SGS model must drain energy from resolved scales at the correct rate to maintain physical behavior.","category":"section"},{"location":"pages/les_models/#SGS-Dissipation","page":"Large Eddy Simulation (LES) Models","title":"SGS Dissipation","text":"The rate at which energy is transferred from resolved to unresolved scales is:\n\nvarepsilon_sgs = -tau_ij barS_ij = 2nu_e barS^2\n\nwhere barS = sqrt2barS_ijbarS_ij is the strain rate magnitude.\n\nA good SGS model ensures varepsilon_sgs matches the actual energy transfer rate.\n\n","category":"section"},{"location":"pages/les_models/#Available-Models-in-Tarang.jl","page":"Large Eddy Simulation (LES) Models","title":"Available Models in Tarang.jl","text":"Tarang.jl provides two eddy viscosity models:\n\nModel Year Key Feature Best For\nSmagorinsky 1963 Simple, robust Isotropic grids, fully turbulent flows\nAMD 2015 Minimum dissipation, anisotropic Transitional flows, stretched grids\n\n","category":"section"},{"location":"pages/les_models/#Smagorinsky-Model","page":"Large Eddy Simulation (LES) Models","title":"Smagorinsky Model","text":"","category":"section"},{"location":"pages/les_models/#Physical-Basis","page":"Large Eddy Simulation (LES) Models","title":"Physical Basis","text":"Joseph Smagorinsky (1963) proposed the first and most widely-used SGS model. It's based on dimensional analysis and mixing length theory.\n\nKey assumptions:\n\nThe subgrid scales are in equilibrium (production = dissipation)\nThe characteristic length scale is proportional to the filter width Delta\nThe characteristic velocity scale is Delta barS","category":"section"},{"location":"pages/les_models/#Mathematical-Formulation","page":"Large Eddy Simulation (LES) Models","title":"Mathematical Formulation","text":"The eddy viscosity is computed as:\n\nnu_e = (C_s Delta)^2 barS\n\nwhere:\n\nC_s approx 017\nis the Smagorinsky constant\nDelta = (Delta_x Delta_y Delta_z)^13\nis the effective filter width\nbarS = sqrt2 barS_ij barS_ij\nis the strain rate magnitude\n\nExpanded form for 3D:\n\nbarS = sqrt2leftleft(fracpartial barupartial xright)^2 + left(fracpartial barvpartial yright)^2 + left(fracpartial barwpartial zright)^2right + left(fracpartial barupartial y + fracpartial barvpartial xright)^2 + left(fracpartial barupartial z + fracpartial barwpartial xright)^2 + left(fracpartial barvpartial z + fracpartial barwpartial yright)^2","category":"section"},{"location":"pages/les_models/#Usage-in-Tarang.jl","page":"Large Eddy Simulation (LES) Models","title":"Usage in Tarang.jl","text":"using Tarang\n\n# Grid parameters\nN = 128                     # Grid points per direction\nL = 2π                      # Domain size\nΔ = L / N                   # Grid spacing\n\n# Create the Smagorinsky model\nsgs_model = SmagorinskyModel(\n    C_s = 0.17,                    # Smagorinsky constant\n    filter_width = (Δ, Δ, Δ),      # Grid spacing in each direction\n    field_size = (N, N, N)         # Number of grid points\n)\n\n# Compute eddy viscosity from velocity gradients\n# You need all 9 components of the velocity gradient tensor\ncompute_eddy_viscosity!(sgs_model,\n    ∂u∂x, ∂u∂y, ∂u∂z,    # Gradients of u\n    ∂v∂x, ∂v∂y, ∂v∂z,    # Gradients of v\n    ∂w∂x, ∂w∂y, ∂w∂z     # Gradients of w\n)\n\n# Retrieve the computed eddy viscosity field\nνₑ = get_eddy_viscosity(sgs_model)","category":"section"},{"location":"pages/les_models/#Choosing-the-Smagorinsky-Constant","page":"Large Eddy Simulation (LES) Models","title":"Choosing the Smagorinsky Constant","text":"The constant C_s is not universal and depends on the flow:\n\nFlow Type Recommended C_s Notes\nIsotropic turbulence 0.17 - 0.20 Theoretical value from Lilly (1967)\nChannel flow 0.10 - 0.12 Reduced due to wall effects\nMixing layers 0.10 - 0.14 Transitional regions need lower values\nFree shear flows 0.10 - 0.12 Similar to channel flow\nAtmospheric boundary layer 0.10 - 0.15 Depends on stability\n\nRule of thumb: Start with C_s = 017 and reduce if you observe over-dissipation.","category":"section"},{"location":"pages/les_models/#Limitations","page":"Large Eddy Simulation (LES) Models","title":"Limitations","text":"Over-dissipation: The model is always \"on\", even in laminar regions\nNo backscatter: Cannot represent energy transfer from small to large scales\nWall behavior: Needs damping functions near solid walls\nIsotropic assumption: Assumes same behavior in all directions\n\n","category":"section"},{"location":"pages/les_models/#Anisotropic-Minimum-Dissipation-(AMD)-Model","page":"Large Eddy Simulation (LES) Models","title":"Anisotropic Minimum Dissipation (AMD) Model","text":"","category":"section"},{"location":"pages/les_models/#Motivation","page":"Large Eddy Simulation (LES) Models","title":"Motivation","text":"The AMD model (Rozema et al., 2015) addresses key limitations of Smagorinsky:\n\nAutomatic switch-off: nu_e = 0 in laminar/transitional regions\nAnisotropic grids: Properly handles Delta_x neq Delta_y neq Delta_z\nMinimum dissipation: Adds only the dissipation needed for stability","category":"section"},{"location":"pages/les_models/#Mathematical-Formulation-2","page":"Large Eddy Simulation (LES) Models","title":"Mathematical Formulation","text":"The AMD model computes eddy viscosity as:\n\nnu_e = maxleft(0 -C frachatdelta_ij^2 fracpartial baru_ipartial x_k fracpartial baru_jpartial x_k barS_ijfracpartial baru_mpartial x_n fracpartial baru_mpartial x_nright)\n\nwhere hatdelta_ij = Delta_i delta_ij (no sum) incorporates anisotropic filter widths.\n\nSimplified form:\n\nnu_e = maxleft(0 -C fractextnumeratortextdenominatorright)\n\nNumerator: Measures alignment between velocity gradients and strain rate\nDenominator: Total velocity gradient magnitude squared\nmax(0, ...): Ensures non-negative eddy viscosity","category":"section"},{"location":"pages/les_models/#Physical-Interpretation","page":"Large Eddy Simulation (LES) Models","title":"Physical Interpretation","text":"The numerator can be negative (giving nu_e  0) when:\n\nVelocity gradients are aligned with the strain rate\nEnergy is being transferred to smaller scales\n\nThe numerator is positive (giving nu_e = 0) when:\n\nFlow is laminar or transitional\nNo SGS dissipation is needed","category":"section"},{"location":"pages/les_models/#Usage-in-Tarang.jl-2","page":"Large Eddy Simulation (LES) Models","title":"Usage in Tarang.jl","text":"# Create the AMD model\nsgs_model = AMDModel(\n    C = 1/12,                      # Poincaré constant (for spectral methods)\n    filter_width = (Δx, Δy, Δz),   # Can be different in each direction\n    field_size = (Nx, Ny, Nz),\n    clip_negative = true           # Ensure νₑ ≥ 0 (recommended)\n)\n\n# Compute eddy viscosity (same interface as Smagorinsky)\ncompute_eddy_viscosity!(sgs_model,\n    ∂u∂x, ∂u∂y, ∂u∂z,\n    ∂v∂x, ∂v∂y, ∂v∂z,\n    ∂w∂x, ∂w∂y, ∂w∂z\n)\n\nνₑ = get_eddy_viscosity(sgs_model)","category":"section"},{"location":"pages/les_models/#Choosing-the-AMD-Constant","page":"Large Eddy Simulation (LES) Models","title":"Choosing the AMD Constant","text":"The constant C depends on the numerical discretization:\n\nDiscretization Recommended C Notes\nSpectral methods 1/12 ≈ 0.0833 Theoretical value\n4th-order finite difference 0.212 From Verstappen (2011)\n2nd-order finite difference 0.3 Higher due to numerical diffusion","category":"section"},{"location":"pages/les_models/#Scalar-Transport-(Buoyancy)","page":"Large Eddy Simulation (LES) Models","title":"Scalar Transport (Buoyancy)","text":"For buoyancy-driven flows, AMD also provides eddy diffusivity for scalar transport:\n\nkappa_e = maxleft(0 -C fracDelta_k^2 fracpartial baru_ipartial x_k fracpartial barthetapartial x_k fracpartial barthetapartial x_ifracpartial barthetapartial x_n fracpartial barthetapartial x_nright)\n\n# Compute eddy diffusivity for buoyancy/temperature\ncompute_eddy_diffusivity!(sgs_model,\n    ∂w∂x, ∂w∂y, ∂w∂z,    # Vertical velocity gradients\n    ∂b∂x, ∂b∂y, ∂b∂z     # Buoyancy/scalar gradients\n)\n\nκₑ = get_eddy_diffusivity(sgs_model)\n\n","category":"section"},{"location":"pages/les_models/#Choosing-Between-Models","page":"Large Eddy Simulation (LES) Models","title":"Choosing Between Models","text":"","category":"section"},{"location":"pages/les_models/#Decision-Flowchart","page":"Large Eddy Simulation (LES) Models","title":"Decision Flowchart","text":"Start\n  │\n  ▼\nIs your grid anisotropic (Δx ≠ Δy ≠ Δz)?\n  │\n  ├── Yes ──► Use AMD (handles anisotropy naturally)\n  │\n  └── No\n       │\n       ▼\nDoes your flow have laminar or transitional regions?\n       │\n       ├── Yes ──► Use AMD (automatically switches off)\n       │\n       └── No\n            │\n            ▼\nIs computational cost a primary concern?\n            │\n            ├── Yes ──► Use Smagorinsky (slightly cheaper)\n            │\n            └── No ──► Either works; AMD is generally more accurate","category":"section"},{"location":"pages/les_models/#Summary-Comparison","page":"Large Eddy Simulation (LES) Models","title":"Summary Comparison","text":"Aspect Smagorinsky AMD\nComplexity Simple Moderate\nCost per timestep Low Slightly higher\nLaminar regions Over-dissipates Correctly gives νₑ = 0\nAnisotropic grids Needs modification Native support\nNear walls Needs damping Better behavior\nTuning required Often yes Usually not\nScalar transport Use Pr_t Built-in κₑ\n\n","category":"section"},{"location":"pages/les_models/#Complete-Example:-LES-of-Decaying-Turbulence","page":"Large Eddy Simulation (LES) Models","title":"Complete Example: LES of Decaying Turbulence","text":"This example demonstrates a complete LES setup for decaying homogeneous isotropic turbulence.\n\nusing Tarang\nusing Statistics\n\n# ============================================================\n# 1. Physical and Numerical Parameters\n# ============================================================\n\nN = 128                     # Grid points per direction\nL = 2π                      # Domain size [m]\nΔ = L / N                   # Grid spacing [m]\nν = 1e-4                    # Molecular (kinematic) viscosity [m²/s]\ndt = 0.001                  # Time step [s]\nnsteps = 1000               # Number of time steps\n\n# ============================================================\n# 2. Create the SGS Model\n# ============================================================\n\n# Option A: Smagorinsky (simple, robust)\nsgs = SmagorinskyModel(\n    C_s = 0.17,\n    filter_width = (Δ, Δ, Δ),\n    field_size = (N, N, N)\n)\n\n# Option B: AMD (recommended for most applications)\n# sgs = AMDModel(\n#     C = 1/12,\n#     filter_width = (Δ, Δ, Δ),\n#     field_size = (N, N, N)\n# )\n\n# ============================================================\n# 3. Setup Computational Domain\n# ============================================================\n\ncoords = CartesianCoordinates(\"x\", \"y\", \"z\")\ndist = Distributor(coords; mesh=(1, 1, 1))  # Single processor\n\n# Fourier bases for periodic domain\nxbasis = RealFourier(coords[\"x\"]; size=N, bounds=(0.0, L))\nybasis = RealFourier(coords[\"y\"]; size=N, bounds=(0.0, L))\nzbasis = RealFourier(coords[\"z\"]; size=N, bounds=(0.0, L))\n\ndomain = Domain(dist, (xbasis, ybasis, zbasis))\n\n# Create velocity field\nu = VectorField(dist, coords, \"u\", (xbasis, ybasis, zbasis))\n\n# ============================================================\n# 4. Initialize with Turbulent Velocity Field\n# ============================================================\n\n# (Initialize u with your preferred IC - e.g., random phases\n#  with prescribed energy spectrum)\n\n# ============================================================\n# 5. Helper Function: Compute All Velocity Gradients\n# ============================================================\n\nfunction compute_velocity_gradients(u)\n    # Uses spectral differentiation for high accuracy\n    ∂u∂x, ∂u∂y, ∂u∂z = gradient(u.components[1])\n    ∂v∂x, ∂v∂y, ∂v∂z = gradient(u.components[2])\n    ∂w∂x, ∂w∂y, ∂w∂z = gradient(u.components[3])\n    return (∂u∂x, ∂u∂y, ∂u∂z,\n            ∂v∂x, ∂v∂y, ∂v∂z,\n            ∂w∂x, ∂w∂y, ∂w∂z)\nend\n\n# ============================================================\n# 6. Time Integration Loop\n# ============================================================\n\nfor step in 1:nsteps\n    # --- Step 1: Compute velocity gradients ---\n    grads = compute_velocity_gradients(u)\n\n    # --- Step 2: Update SGS eddy viscosity ---\n    compute_eddy_viscosity!(sgs, grads...)\n\n    # --- Step 3: Get effective viscosity ---\n    νₑ = get_eddy_viscosity(sgs)\n    ν_eff = ν .+ νₑ  # Total viscosity = molecular + SGS\n\n    # --- Step 4: Advance momentum equation ---\n    # The filtered Navier-Stokes with SGS model:\n    #   ∂ū/∂t + (ū·∇)ū = -∇p̄/ρ + (ν + νₑ)∇²ū\n    #\n    # In your timestepper, use ν_eff instead of ν\n    # for the viscous term\n\n    # --- Step 5: Diagnostics ---\n    if step % 100 == 0\n        mean_νₑ = mean_eddy_viscosity(sgs)\n        max_νₑ = max_eddy_viscosity(sgs)\n\n        println(\"Step $step:\")\n        println(\"  Mean eddy viscosity: $(mean_νₑ)\")\n        println(\"  Max eddy viscosity:  $(max_νₑ)\")\n        println(\"  Ratio νₑ/ν (mean):   $(mean_νₑ/ν)\")\n    end\nend\n\n","category":"section"},{"location":"pages/les_models/#Complete-Example:-LES-of-Rayleigh-Bénard-Convection","page":"Large Eddy Simulation (LES) Models","title":"Complete Example: LES of Rayleigh-Bénard Convection","text":"For buoyancy-driven turbulence, we need both momentum and scalar closures:\n\nusing Tarang\n\n# ============================================================\n# Physical Parameters\n# ============================================================\n\nNx, Nz = 256, 128           # Grid resolution\nLx, Lz = 4.0, 1.0           # Domain size\nΔx, Δz = Lx/Nx, Lz/Nz       # Grid spacing\n\nRa = 1e8                    # Rayleigh number\nPr = 1.0                    # Prandtl number\nν = sqrt(Pr / Ra)           # Kinematic viscosity\nκ = ν / Pr                  # Thermal diffusivity\n\n# ============================================================\n# Create AMD Model (recommended for RBC)\n# ============================================================\n\nsgs = AMDModel(\n    C = 1/12,\n    filter_width = (Δx, Δz),\n    field_size = (Nx, Nz)\n)\n\n# ============================================================\n# In the Time Loop\n# ============================================================\n\nfor step in 1:nsteps\n    # Compute velocity gradients\n    ∂u∂x, ∂u∂z = gradient(u)\n    ∂w∂x, ∂w∂z = gradient(w)\n\n    # Compute temperature gradients\n    ∂T∂x, ∂T∂z = gradient(T)\n\n    # --- Momentum closure ---\n    compute_eddy_viscosity!(sgs, ∂u∂x, ∂u∂z, ∂w∂x, ∂w∂z)\n    νₑ = get_eddy_viscosity(sgs)\n    ν_eff = ν .+ νₑ\n\n    # --- Scalar (temperature) closure ---\n    compute_eddy_diffusivity!(sgs, ∂w∂x, ∂w∂z, ∂T∂x, ∂T∂z)\n    κₑ = get_eddy_diffusivity(sgs)\n    κ_eff = κ .+ κₑ\n\n    # Use ν_eff in momentum equation\n    # Use κ_eff in temperature equation\nend\n\n","category":"section"},{"location":"pages/les_models/#Diagnostics-and-Analysis","page":"Large Eddy Simulation (LES) Models","title":"Diagnostics and Analysis","text":"","category":"section"},{"location":"pages/les_models/#SGS-Energy-Dissipation","page":"Large Eddy Simulation (LES) Models","title":"SGS Energy Dissipation","text":"The SGS dissipation rate tells you how much energy is being drained by the model:\n\n# Get strain magnitude (computed during eddy viscosity calculation)\nS_mag = sgs.strain_magnitude  # Only for Smagorinsky\n\n# Or compute it yourself\nS_mag = sqrt(2 * (S11.^2 + S22.^2 + S33.^2 + 2*S12.^2 + 2*S13.^2 + 2*S23.^2))\n\n# SGS dissipation field: ε_sgs = 2 νₑ |S|²\nε_sgs = sgs_dissipation(sgs, S_mag)\n\n# Domain-averaged SGS dissipation\nε_sgs_mean = mean_sgs_dissipation(sgs, S_mag)","category":"section"},{"location":"pages/les_models/#Monitoring-Model-Behavior","page":"Large Eddy Simulation (LES) Models","title":"Monitoring Model Behavior","text":"# Check ratio of SGS to molecular viscosity\nνₑ_mean = mean_eddy_viscosity(sgs)\nprintln(\"νₑ/ν = $(νₑ_mean/ν)\")\n\n# If νₑ/ν >> 1: SGS model is dominant (typical for high Re)\n# If νₑ/ν << 1: Flow is nearly DNS-resolved\n# If νₑ/ν ~ 1: Well-resolved LES\n\n# For AMD: check how often νₑ = 0\nνₑ = get_eddy_viscosity(sgs)\nfraction_zero = sum(νₑ .== 0) / length(νₑ)\nprintln(\"Fraction with νₑ = 0: $(fraction_zero)\")\n# High fraction → flow is largely laminar/transitional\n\n","category":"section"},{"location":"pages/les_models/#Tips-for-Successful-LES","page":"Large Eddy Simulation (LES) Models","title":"Tips for Successful LES","text":"","category":"section"},{"location":"pages/les_models/#Resolution-Requirements","page":"Large Eddy Simulation (LES) Models","title":"Resolution Requirements","text":"LES still requires adequate resolution:\n\n┌────────────────────────────────────────────────────────────┐\n│  Resolution Quality for LES                                 │\n├────────────────────────────────────────────────────────────┤\n│  80% of TKE resolved      →  Minimum acceptable LES        │\n│  90% of TKE resolved      →  Good quality LES              │\n│  95%+ of TKE resolved     →  Nearly DNS quality            │\n└────────────────────────────────────────────────────────────┘\n\nRule of thumb: Grid spacing should resolve the inertial range, typically Delta lesssim L_integral10.","category":"section"},{"location":"pages/les_models/#Common-Pitfalls","page":"Large Eddy Simulation (LES) Models","title":"Common Pitfalls","text":"Symptom Likely Cause Solution\nSimulation blows up νₑ too small Increase C_s or C\nFlow looks too smooth Over-dissipation Reduce C_s, or use AMD\nCheckerboard patterns Aliasing errors Enable dealiasing (2/3 rule)\nνₑ unrealistically large Poor resolution Refine grid\nAMD gives νₑ = 0 everywhere Flow is laminar This is correct!","category":"section"},{"location":"pages/les_models/#When-LES-May-Not-Be-Appropriate","page":"Large Eddy Simulation (LES) Models","title":"When LES May Not Be Appropriate","text":"Very low Reynolds numbers: DNS may be feasible\nStrongly anisotropic turbulence: May need special treatment\nFlows with strong backscatter: Standard models don't capture this\nNear-wall regions: May need wall models or finer grids\n\n","category":"section"},{"location":"pages/les_models/#2D-Flows","page":"Large Eddy Simulation (LES) Models","title":"2D Flows","text":"Both models support 2D simulations:\n\n# 2D Smagorinsky\nsgs_2d = SmagorinskyModel(\n    C_s = 0.17,\n    filter_width = (Δx, Δy),\n    field_size = (Nx, Ny)\n)\n\n# 2D velocity gradients (4 components)\ncompute_eddy_viscosity!(sgs_2d, ∂u∂x, ∂u∂y, ∂v∂x, ∂v∂y)\n\nNote on 2D turbulence: 2D turbulence has an inverse energy cascade (energy flows to large scales), which is fundamentally different from 3D. Standard SGS models may not be appropriate for 2D flows.\n\n","category":"section"},{"location":"pages/les_models/#API-Reference","page":"Large Eddy Simulation (LES) Models","title":"API Reference","text":"","category":"section"},{"location":"pages/les_models/#Constructors","page":"Large Eddy Simulation (LES) Models","title":"Constructors","text":"SmagorinskyModel(;\n    C_s = 0.17,                    # Smagorinsky constant\n    filter_width::NTuple{N, Real}, # (Δx, Δy) or (Δx, Δy, Δz)\n    field_size::NTuple{N, Int},    # (Nx, Ny) or (Nx, Ny, Nz)\n    dtype = Float64                # Precision\n)\n\nAMDModel(;\n    C = 1/12,                      # Poincaré constant\n    filter_width::NTuple{N, Real}, # Can be anisotropic\n    field_size::NTuple{N, Int},\n    clip_negative = true,          # Ensure νₑ ≥ 0\n    dtype = Float64\n)","category":"section"},{"location":"pages/les_models/#Core-Functions","page":"Large Eddy Simulation (LES) Models","title":"Core Functions","text":"Function Description\ncompute_eddy_viscosity!(model, grads...) Compute νₑ from velocity gradients\ncompute_eddy_diffusivity!(model, grads...) Compute κₑ for scalars (AMD only)\nget_eddy_viscosity(model) Return the νₑ field\nget_eddy_diffusivity(model) Return the κₑ field (AMD)","category":"section"},{"location":"pages/les_models/#Analysis-Functions","page":"Large Eddy Simulation (LES) Models","title":"Analysis Functions","text":"Function Description\nmean_eddy_viscosity(model) Domain-averaged νₑ\nmax_eddy_viscosity(model) Maximum νₑ\nsgs_dissipation(model, S_mag) SGS dissipation field\nmean_sgs_dissipation(model, S_mag) Domain-averaged dissipation","category":"section"},{"location":"pages/les_models/#Utility-Functions","page":"Large Eddy Simulation (LES) Models","title":"Utility Functions","text":"Function Description\nset_constant!(model, C) Update model constant\nreset!(model) Reset νₑ (and κₑ) to zero\nget_filter_width(model) Return filter width tuple\ncompute_sgs_stress(model, S...) Compute full SGS stress tensor\n\n","category":"section"},{"location":"pages/les_models/#Troubleshooting","page":"Large Eddy Simulation (LES) Models","title":"Troubleshooting","text":"Problem Possible Cause Solution\nSimulation becomes unstable νₑ too small Increase C_s or C; check CFL condition\nFlow appears over-damped νₑ too large Reduce C_s; consider AMD model\nSpurious oscillations Aliasing Enable 2/3 dealiasing rule\nAMD gives νₑ = 0 everywhere Flow is laminar Correct behavior; model switches off\nUnphysical behavior near walls Poor wall resolution Refine near-wall grid; use wall functions\n\n","category":"section"},{"location":"pages/les_models/#References","page":"Large Eddy Simulation (LES) Models","title":"References","text":"","category":"section"},{"location":"pages/les_models/#Original-Papers","page":"Large Eddy Simulation (LES) Models","title":"Original Papers","text":"Smagorinsky, J. (1963). \"General circulation experiments with the primitive equations: I. The basic experiment.\" Monthly Weather Review, 91(3), 99-164.\nRozema, W., Bae, H. J., Moin, P., & Verstappen, R. (2015). \"Minimum-dissipation models for large-eddy simulation.\" Physics of Fluids, 27(8), 085107. PDF\nAbkar, M., Bae, H. J., & Moin, P. (2016). \"Minimum-dissipation scalar transport model for large-eddy simulation of turbulent flows.\" Physical Review Fluids, 1(4), 041701. Link","category":"section"},{"location":"pages/les_models/#Textbooks-and-Reviews","page":"Large Eddy Simulation (LES) Models","title":"Textbooks and Reviews","text":"Pope, S. B. (2000). Turbulent Flows. Cambridge University Press. (Chapter 13: Large-Eddy Simulation)\nSagaut, P. (2006). Large Eddy Simulation for Incompressible Flows. Springer.","category":"section"},{"location":"pages/les_models/#Related-Documentation","page":"Large Eddy Simulation (LES) Models","title":"Related Documentation","text":"dedaLES AMD Documentation\n\n","category":"section"},{"location":"pages/les_models/#See-Also","page":"Large Eddy Simulation (LES) Models","title":"See Also","text":"Solvers - Time integration methods\nOperators - Gradient and differential operators\nStochastic Forcing - Forcing for turbulence\nAPI: LES Models - Complete API reference","category":"section"},{"location":"tutorials/boundary_conditions/#Tutorial:-Boundary-Conditions","page":"Tutorial: Boundary Conditions","title":"Tutorial: Boundary Conditions","text":"This tutorial covers the different types of boundary conditions available in Tarang.jl and how to apply them effectively using the tau method with explicit tau fields.","category":"section"},{"location":"tutorials/boundary_conditions/#Overview","page":"Tutorial: Boundary Conditions","title":"Overview","text":"Boundary conditions (BCs) are essential for well-posed PDE problems. Tarang.jl supports:\n\nDirichlet: Specify field value at boundary\nNeumann: Specify derivative at boundary\nRobin: Linear combination of value and derivative\nPeriodic: Automatic for Fourier bases","category":"section"},{"location":"tutorials/boundary_conditions/#The-Tau-Method-Approach","page":"Tutorial: Boundary Conditions","title":"The Tau Method Approach","text":"Tarang.jl follows the Dedalus approach for handling boundary conditions. Users must explicitly create tau fields and add them to equations using the lift() operator.","category":"section"},{"location":"tutorials/boundary_conditions/#Why-Explicit-Tau-Fields?","page":"Tutorial: Boundary Conditions","title":"Why Explicit Tau Fields?","text":"Clarity: The mathematical structure is visible in your code\nFlexibility: Full control over tau placement\nDebugging: Easy to inspect tau field values\nConsistency: Matches the mathematical formulation","category":"section"},{"location":"tutorials/boundary_conditions/#Required-Steps","page":"Tutorial: Boundary Conditions","title":"Required Steps","text":"For any problem with non-periodic boundary conditions:\n\nCreate tau fields - One per boundary condition\nAdd tau fields to the problem - Include them in the field list\nAdd lift() terms to equations - Place tau contributions at specific modes\nSpecify boundary conditions - Link each BC to its tau field","category":"section"},{"location":"tutorials/boundary_conditions/#Complete-Example:-Poisson-Equation","page":"Tutorial: Boundary Conditions","title":"Complete Example: Poisson Equation","text":"Let's solve the Poisson equation nabla^2 u = f with Dirichlet BCs:\n\nusing Tarang\n\n# Create coordinates and bases\ncoords = CartesianCoordinates(\"x\", \"z\")\nx_basis = RealFourier(coords[\"x\"], size=64, bounds=(0.0, 2π))\nz_basis = ChebyshevT(coords[\"z\"], size=64, bounds=(0.0, 1.0))\n\n# Create distributor and fields\ndist = Distributor(coords)\nu = ScalarField(dist, \"u\", (x_basis, z_basis))\nf = ScalarField(dist, \"f\", (x_basis, z_basis))  # Source term\n\n# Step 1: Create tau fields (one per BC)\n# These live on the x-basis only (boundary is a line in 2D)\ntau_u1 = ScalarField(dist, \"tau_u1\", (x_basis,))  # For BC at z=0\ntau_u2 = ScalarField(dist, \"tau_u2\", (x_basis,))  # For BC at z=1\n\n# Step 2: Add ALL fields to problem (including tau fields)\nproblem = LBVP([u, tau_u1, tau_u2])\n\n# Step 3: Add substitution for source term\nadd_substitution!(problem, \"f\", f)\n\n# Step 4: Add equation with lift() operators (Dedalus-style string format)\nadd_equation!(problem, \"Δ(u) + lift(tau_u1) + lift(tau_u2) = f\")\n\n# Step 5: Add boundary conditions\nadd_bc!(problem, \"u(z=0) = 0\")   # u(z=0) = 0\nadd_bc!(problem, \"u(z=1) = 0\")   # u(z=1) = 0\n\n# Solve\nsolver = BoundaryValueSolver(problem)\nsolve!(solver)","category":"section"},{"location":"tutorials/boundary_conditions/#Dirichlet-Boundary-Conditions","page":"Tutorial: Boundary Conditions","title":"Dirichlet Boundary Conditions","text":"Fix the value of a field at the boundary.","category":"section"},{"location":"tutorials/boundary_conditions/#Basic-Setup","page":"Tutorial: Boundary Conditions","title":"Basic Setup","text":"# Create tau fields for each Dirichlet BC\ntau_T1 = ScalarField(dist, \"tau_T1\", (x_basis,))\ntau_T2 = ScalarField(dist, \"tau_T2\", (x_basis,))\n\n# Add to problem\nproblem = LBVP([T, tau_T1, tau_T2])\n\n# Add equation with lift terms (Dedalus-style string format)\nadd_equation!(problem, \"Δ(T) + lift(tau_T1) + lift(tau_T2) = source\")\n\n# Boundary conditions\nadd_bc!(problem, \"T(z=0) = 1\")   # T(z=0) = 1\nadd_bc!(problem, \"T(z=1) = 0\")   # T(z=1) = 0","category":"section"},{"location":"tutorials/boundary_conditions/#No-Slip-Velocity-(Vector-Fields)","page":"Tutorial: Boundary Conditions","title":"No-Slip Velocity (Vector Fields)","text":"For viscous flows at solid walls, use vector fields for compact notation:\n\n# Vector field for velocity\nu = VectorField(dist, coords, \"u\", (x_basis, z_basis))\np = ScalarField(dist, \"p\", (x_basis, z_basis))\n\n# Vector tau fields for BCs at each wall\ntau_u1 = VectorField(dist, coords, \"tau_u1\", (x_basis,))  # Wall at z=0\ntau_u2 = VectorField(dist, coords, \"tau_u2\", (x_basis,))  # Wall at z=1\ntau_p = ScalarField(dist, \"tau_p\", ())\n\n# Pass vector fields directly to problem\nproblem = IVP([u, p, tau_u1, tau_u2, tau_p])\n\n# Add substitutions\nadd_substitution!(problem, \"nu\", nu)\n\n# Momentum equation (single vector equation)\nadd_equation!(problem, \"∂t(u) - nu*Δ(u) + ∇(p) + lift(tau_u2) = -u⋅∇(u)\")\n\n# Continuity with tau_p (removes degeneracy)\nadd_equation!(problem, \"div(u) + tau_p = 0\")\n\n# No-slip boundary conditions (vector notation)\nadd_bc!(problem, \"u(z=0) = 0\")   # No-slip bottom (all components)\nadd_bc!(problem, \"u(z=1) = 0\")   # No-slip top (all components)","category":"section"},{"location":"tutorials/boundary_conditions/#Neumann-Boundary-Conditions","page":"Tutorial: Boundary Conditions","title":"Neumann Boundary Conditions","text":"Specify the derivative (flux) at the boundary.","category":"section"},{"location":"tutorials/boundary_conditions/#Basic-Setup-2","page":"Tutorial: Boundary Conditions","title":"Basic Setup","text":"# Tau fields for Neumann BCs\ntau_T1 = ScalarField(dist, \"tau_T1\", (x_basis,))\ntau_T2 = ScalarField(dist, \"tau_T2\", (x_basis,))\n\nproblem = LBVP([T, tau_T1, tau_T2])\n\nadd_equation!(problem, \"Δ(T) + lift(tau_T1) + lift(tau_T2) = source\")\n\n# Neumann: specify derivative at boundary\nadd_bc!(problem, \"∂z(T)(z=0) = 1\")   # ∂T/∂z(z=0) = 1\nadd_bc!(problem, \"∂z(T)(z=1) = 0\")   # ∂T/∂z(z=1) = 0","category":"section"},{"location":"tutorials/boundary_conditions/#Stress-Free-Conditions","page":"Tutorial: Boundary Conditions","title":"Stress-Free Conditions","text":"For free surfaces or slip boundaries (∂u/∂z = 0):\n\n# Mixed: no-slip at bottom, stress-free at top\nadd_bc!(problem, \"u_x(z=0) = 0\")      # No-slip at bottom\nadd_bc!(problem, \"∂z(u_x)(z=1) = 0\")  # Stress-free at top (∂u/∂z = 0)","category":"section"},{"location":"tutorials/boundary_conditions/#Robin-Boundary-Conditions","page":"Tutorial: Boundary Conditions","title":"Robin Boundary Conditions","text":"Linear combination: alpha u + beta fracpartial upartial n = gamma\n\ntau_T1 = ScalarField(dist, \"tau_T1\", (x_basis,))\ntau_T2 = ScalarField(dist, \"tau_T2\", (x_basis,))\n\nproblem = LBVP([T, tau_T1, tau_T2])\n\n# Add parameters\nadd_substitution!(problem, \"h\", 10.0)   # Heat transfer coefficient\nadd_substitution!(problem, \"k\", 1.0)    # Thermal conductivity\nadd_substitution!(problem, \"T_amb\", 25.0)\n\nadd_equation!(problem, \"Δ(T) + lift(tau_T1) + lift(tau_T2) = source\")\n\n# Convective heat transfer at top: h*T + k*dT/dn = h*T_ambient\nadd_bc!(problem, \"h*T(z=1) + k*∂z(T)(z=1) = h*T_amb\")\n\n# Dirichlet at bottom\nadd_bc!(problem, \"T(z=0) = 100\")","category":"section"},{"location":"tutorials/boundary_conditions/#Periodic-Boundary-Conditions","page":"Tutorial: Boundary Conditions","title":"Periodic Boundary Conditions","text":"Periodic boundaries are automatically handled by Fourier bases - no tau fields needed!\n\n# Fourier basis implies periodicity\nx_basis = RealFourier(coords[\"x\"], size=128, bounds=(0.0, 2π))\n\n# No boundary conditions or tau fields needed for x-direction\n# The Fourier representation automatically enforces u(x=0) = u(x=2π)\n\nwarning: Mixing Periodic and Non-Periodic\nWhen using Fourier (periodic) and Chebyshev (non-periodic) bases together, only create tau fields and boundary conditions for the non-periodic directions.","category":"section"},{"location":"tutorials/boundary_conditions/#The-lift()-Operator","page":"Tutorial: Boundary Conditions","title":"The lift() Operator","text":"The lift() operator places tau corrections at specific spectral modes. In the string equation format:\n\n\"Δ(u) + lift(tau_u1) + lift(tau_u2) = f\"\n\nThe tau field name in the lift() operator should match the tau field name you created.","category":"section"},{"location":"tutorials/boundary_conditions/#Mode-Selection-Guidelines","page":"Tutorial: Boundary Conditions","title":"Mode Selection Guidelines","text":"Operator Order Number of BCs Number of lift() terms\n1st (∂/∂z) 1 1\n2nd (∂²/∂z²) 2 2\n4th (∇⁴) 4 4","category":"section"},{"location":"tutorials/boundary_conditions/#Example:-Fourth-Order-Problem","page":"Tutorial: Boundary Conditions","title":"Example: Fourth-Order Problem","text":"For a biharmonic equation (∇⁴u = f) with 4 boundary conditions:\n\n# Four tau fields needed\ntau_u1 = ScalarField(dist, \"tau_u1\", (x_basis,))\ntau_u2 = ScalarField(dist, \"tau_u2\", (x_basis,))\ntau_u3 = ScalarField(dist, \"tau_u3\", (x_basis,))\ntau_u4 = ScalarField(dist, \"tau_u4\", (x_basis,))\n\nproblem = LBVP([u, tau_u1, tau_u2, tau_u3, tau_u4])\n\n# Biharmonic equation with all four lift terms\nadd_equation!(problem, \"Δ(Δ(u)) + lift(tau_u1) + lift(tau_u2) + lift(tau_u3) + lift(tau_u4) = f\")\n\n# Clamped beam: u = 0 and du/dz = 0 at both ends\nadd_bc!(problem, \"u(z=0) = 0\")\nadd_bc!(problem, \"∂z(u)(z=0) = 0\")\nadd_bc!(problem, \"u(z=1) = 0\")\nadd_bc!(problem, \"∂z(u)(z=1) = 0\")","category":"section"},{"location":"tutorials/boundary_conditions/#Complete-Examples","page":"Tutorial: Boundary Conditions","title":"Complete Examples","text":"","category":"section"},{"location":"tutorials/boundary_conditions/#Channel-Flow-(Poiseuille-Flow)","page":"Tutorial: Boundary Conditions","title":"Channel Flow (Poiseuille Flow)","text":"using Tarang\n\ncoords = CartesianCoordinates(\"x\", \"z\")\nx_basis = RealFourier(coords[\"x\"]; size=64, bounds=(0.0, 2π))\nz_basis = ChebyshevT(coords[\"z\"]; size=64, bounds=(0.0, 1.0))\ndist = Distributor(coords)\n\n# Vector velocity field\nu = VectorField(dist, coords, \"u\", (x_basis, z_basis))\np = ScalarField(dist, \"p\", (x_basis, z_basis))\n\n# Vector tau fields for velocity BCs at each wall\ntau_u1 = VectorField(dist, coords, \"tau_u1\", (x_basis,))  # Wall at z=0\ntau_u2 = VectorField(dist, coords, \"tau_u2\", (x_basis,))  # Wall at z=1\n\n# Tau for pressure (removes degeneracy)\ntau_p = ScalarField(dist, \"tau_p\", ())\n\n# Parameters\nnu = 0.01\ndpdx = -1.0\n\n# Create problem with all fields\nproblem = IVP([u, p, tau_u1, tau_u2, tau_p])\n\n# Add parameter substitutions\nadd_substitution!(problem, \"nu\", nu)\nadd_substitution!(problem, \"dpdx\", dpdx)\n\n# Momentum equation (vector form) - dpdx is the driving pressure gradient\nadd_equation!(problem, \"∂t(u) - nu*Δ(u) + ∇(p) + lift(tau_u2) = -u⋅∇(u) - dpdx*ex\")\n\n# Continuity with tau_p (removes degeneracy)\nadd_equation!(problem, \"div(u) + tau_p = 0\")\n\n# No-slip at both walls (vector notation)\nadd_bc!(problem, \"u(z=0) = 0\")\nadd_bc!(problem, \"u(z=1) = 0\")","category":"section"},{"location":"tutorials/boundary_conditions/#Rayleigh-Bénard-Convection","page":"Tutorial: Boundary Conditions","title":"Rayleigh-Bénard Convection","text":"using Tarang\n\ncoords = CartesianCoordinates(\"x\", \"z\")\nx_basis = RealFourier(coords[\"x\"]; size=128, bounds=(0.0, 4.0))\nz_basis = ChebyshevT(coords[\"z\"]; size=64, bounds=(0.0, 1.0))\ndist = Distributor(coords)\n\n# Vector velocity field and scalar fields\nu = VectorField(dist, coords, \"u\", (x_basis, z_basis))\np = ScalarField(dist, \"p\", (x_basis, z_basis))\nT = ScalarField(dist, \"T\", (x_basis, z_basis))\n\n# Vector tau fields for velocity BCs\ntau_u1 = VectorField(dist, coords, \"tau_u1\", (x_basis,))  # Wall at z=0\ntau_u2 = VectorField(dist, coords, \"tau_u2\", (x_basis,))  # Wall at z=1\n\n# Scalar tau fields for temperature BCs\ntau_T1 = ScalarField(dist, \"tau_T1\", (x_basis,))  # BC at z=0\ntau_T2 = ScalarField(dist, \"tau_T2\", (x_basis,))  # BC at z=1\n\n# Tau for pressure (removes degeneracy)\ntau_p = ScalarField(dist, \"tau_p\", ())\n\n# Parameters\nRa = 1e6   # Rayleigh number\nPr = 1.0   # Prandtl number\n\n# Create problem with all fields\nproblem = IVP([u, p, T, tau_u1, tau_u2, tau_T1, tau_T2, tau_p])\n\n# Add parameter substitutions\nadd_substitution!(problem, \"Ra\", Ra)\nadd_substitution!(problem, \"Pr\", Pr)\n\n# Momentum equation (vector form with buoyancy)\n# ez is the unit vector in z-direction\nadd_equation!(problem, \"∂t(u) - Pr*Δ(u) + ∇(p) + lift(tau_u2) = -u⋅∇(u) + Ra*Pr*T*ez\")\n\n# Continuity with tau_p (removes degeneracy)\nadd_equation!(problem, \"div(u) + tau_p = 0\")\n\n# Temperature equation\nadd_equation!(problem, \"∂t(T) - Δ(T) + lift(tau_T2) = -u⋅∇(T)\")\n\n# Boundary conditions (vector notation for velocity)\nadd_bc!(problem, \"u(z=0) = 0\")   # No-slip bottom\nadd_bc!(problem, \"u(z=1) = 0\")   # No-slip top\n\n# Fixed temperature\nadd_bc!(problem, \"T(z=0) = 1\")   # Hot bottom\nadd_bc!(problem, \"T(z=1) = 0\")   # Cold top","category":"section"},{"location":"tutorials/boundary_conditions/#Validation","page":"Tutorial: Boundary Conditions","title":"Validation","text":"","category":"section"},{"location":"tutorials/boundary_conditions/#Checking-BC-Satisfaction","page":"Tutorial: Boundary Conditions","title":"Checking BC Satisfaction","text":"# After solving, verify BCs are satisfied\nfunction check_dirichlet_bc(field, coord, location, expected_value; tol=1e-10)\n    to_grid!(field)\n    data = get_grid_data(field)\n\n    # Get boundary values\n    if coord == \"z\" && location == :left\n        bc_values = data[:, 1]\n    elseif coord == \"z\" && location == :right\n        bc_values = data[:, end]\n    end\n\n    error = maximum(abs.(bc_values .- expected_value))\n    @assert error < tol \"BC error: $error\"\n\n    return error\nend\n\n# Usage\ncheck_dirichlet_bc(T, \"z\", :left, 1.0)\ncheck_dirichlet_bc(T, \"z\", :right, 0.0)","category":"section"},{"location":"tutorials/boundary_conditions/#Troubleshooting","page":"Tutorial: Boundary Conditions","title":"Troubleshooting","text":"","category":"section"},{"location":"tutorials/boundary_conditions/#Missing-Tau-Fields","page":"Tutorial: Boundary Conditions","title":"Missing Tau Fields","text":"Error: ArgumentError: Missing tau field specifications for boundary conditions\n\nSolution: Create tau fields and include lift() terms in your equations:\n\n# Wrong: No tau fields or lift terms\nadd_equation!(problem, \"Δ(u) = f\")\nadd_bc!(problem, \"u(z=0) = 0\")\n\n# Correct: Create tau fields and add lift terms\ntau_u1 = ScalarField(dist, \"tau_u1\", (x_basis,))\ntau_u2 = ScalarField(dist, \"tau_u2\", (x_basis,))\nadd_equation!(problem, \"Δ(u) + lift(tau_u1) + lift(tau_u2) = f\")\nadd_bc!(problem, \"u(z=0) = 0\")\nadd_bc!(problem, \"u(z=1) = 0\")","category":"section"},{"location":"tutorials/boundary_conditions/#Over-Specified-System","page":"Tutorial: Boundary Conditions","title":"Over-Specified System","text":"Problem: Too many boundary conditions cause singular matrices.\n\nSolution: Match the number of BCs (and tau fields) to the operator order in each direction.","category":"section"},{"location":"tutorials/boundary_conditions/#Under-Specified-System","page":"Tutorial: Boundary Conditions","title":"Under-Specified System","text":"Problem: Not enough BCs lead to non-unique solutions.\n\nSolution: Add appropriate boundary conditions for the problem physics.","category":"section"},{"location":"tutorials/boundary_conditions/#Tau-Field-Dimension-Mismatch","page":"Tutorial: Boundary Conditions","title":"Tau Field Dimension Mismatch","text":"Problem: Tau field has wrong dimensionality.\n\nSolution: Tau fields should live on the boundary, not the full domain:\n\n# For a 2D problem with x-basis (periodic) and z-basis (non-periodic):\n# Boundaries are at constant z, so tau fields live on x-basis only\ntau_u = ScalarField(dist, \"tau_u\", (x_basis,))  # Correct: 1D on x\n\n# NOT:\ntau_u = ScalarField(dist, \"tau_u\", (x_basis, z_basis))  # Wrong: 2D","category":"section"},{"location":"tutorials/boundary_conditions/#See-Also","page":"Tutorial: Boundary Conditions","title":"See Also","text":"Tau Method (Advanced): Mathematical details\nProblems API: Problem definition\nBases API: Spectral basis selection\n2D Rayleigh-Bénard Tutorial: Complete example with BCs","category":"section"},{"location":"tutorials/overview/#Tutorials-Overview","page":"Tutorials Overview","title":"Tutorials Overview","text":"This section contains comprehensive tutorials that guide you through solving various types of PDEs with Tarang.jl. Each tutorial builds on concepts from previous ones, so we recommend following them in order if you're new to spectral methods or Tarang.jl.","category":"section"},{"location":"tutorials/overview/#Tutorial-Path","page":"Tutorials Overview","title":"Tutorial Path","text":"","category":"section"},{"location":"tutorials/overview/#For-Beginners","page":"Tutorials Overview","title":"For Beginners","text":"If you're new to spectral methods or Tarang.jl, start here:\n\nFirst Steps - Basic workflow and simple diffusion problem\n2D Rayleigh-Bénard Convection - Complete fluid dynamics example\nBoundary Conditions - Master the boundary condition system","category":"section"},{"location":"tutorials/overview/#Intermediate-Topics","page":"Tutorials Overview","title":"Intermediate Topics","text":"Once comfortable with basics:\n\n3D Turbulent Flow - 3D problems with advanced parallelization\nAnalysis and Output - Data management and visualization\nEigenvalue Problems - Linear stability analysis","category":"section"},{"location":"tutorials/overview/#Advanced-Topics","page":"Tutorials Overview","title":"Advanced Topics","text":"For experienced users:\n\nCustom Operators - Define new differential operators\nOptimization Guide - Performance tuning","category":"section"},{"location":"tutorials/overview/#Tutorial-List","page":"Tutorials Overview","title":"Tutorial List","text":"","category":"section"},{"location":"tutorials/overview/#Initial-Value-Problems-(IVP)","page":"Tutorials Overview","title":"Initial Value Problems (IVP)","text":"Time-evolution problems where you integrate PDEs forward in time.\n\nTutorial Description Complexity Key Features\n2D Rayleigh-Bénard Thermal convection in 2D Intermediate Navier-Stokes, buoyancy, CFL\n3D Taylor-Green Vortex 3D turbulence simulation Advanced 3D FFTs, energy spectra\nChannel Flow Turbulent channel flow Advanced Wall-bounded, statistics","category":"section"},{"location":"tutorials/overview/#Boundary-Value-Problems-(BVP)","page":"Tutorials Overview","title":"Boundary Value Problems (BVP)","text":"Steady-state problems with boundary conditions.\n\nTutorial Description Complexity Key Features\nSteady Convection Fixed temperature Rayleigh-Bénard Intermediate LBVP, sparse linear solve\nStokes Flow Low Reynolds number flow Beginner Simple BVP example","category":"section"},{"location":"tutorials/overview/#Eigenvalue-Problems-(EVP)","page":"Tutorials Overview","title":"Eigenvalue Problems (EVP)","text":"Linear stability analysis and normal modes.\n\nTutorial Description Complexity Key Features\nStability Analysis Eigenvalue problem setup Advanced EVP, eigensolvers","category":"section"},{"location":"tutorials/overview/#Surface-and-Boundary-Dynamics","page":"Tutorials Overview","title":"Surface and Boundary Dynamics","text":"Problems with dynamics confined to surfaces or boundaries.\n\nTutorial Description Complexity Key Features\nSurface Dynamics SQG, QG, boundary advection-diffusion Advanced Fractional Laplacian, coupled systems","category":"section"},{"location":"tutorials/overview/#Wave-Mean-Flow-Analysis","page":"Tutorials Overview","title":"Wave-Mean Flow Analysis","text":"Tutorial Description Complexity Key Features\nRotating Shallow Water Inertia-gravity wave filtering Intermediate Temporal filters, wave-mean separation\nGQL Approximation Generalized Quasi-Linear methods Advanced Wavenumber cutoff, zonal jets","category":"section"},{"location":"tutorials/overview/#Special-Topics","page":"Tutorials Overview","title":"Special Topics","text":"Tutorial Description Complexity Key Features\nBoundary Conditions All BC types and usage Intermediate Dirichlet, Neumann, Robin\nAnalysis & Output Data management Intermediate NetCDF, HDF5, analysis","category":"section"},{"location":"tutorials/overview/#Problem-Types-Explained","page":"Tutorials Overview","title":"Problem Types Explained","text":"","category":"section"},{"location":"tutorials/overview/#Initial-Value-Problems-(IVP)-2","page":"Tutorials Overview","title":"Initial Value Problems (IVP)","text":"When to use: Time-dependent PDEs where you know the initial state and want to evolve forward in time.\n\nExamples:\n\nFluid dynamics (Navier-Stokes)\nHeat diffusion\nWave propagation\nReaction-diffusion systems\n\nTypical structure:\n\nproblem = IVP(fields)\nadd_equation!(problem, \"∂t(u) = -u*∂x(u) + nu*Δ(u)\")\nsolver = InitialValueSolver(problem, RK222())\n\nwhile solver.sim_time < t_end\n    step!(solver, dt)\nend","category":"section"},{"location":"tutorials/overview/#Boundary-Value-Problems-(BVP)-2","page":"Tutorials Overview","title":"Boundary Value Problems (BVP)","text":"When to use: Steady-state problems where you solve for the spatial distribution given boundary conditions.\n\nTypes:\n\nLBVP: Linear boundary value problems\nNLBVP: Nonlinear boundary value problems (require iteration)\n\nExamples:\n\nSteady-state heat conduction\nPoisson equation\nSteady Stokes flow\n\nTypical structure:\n\nproblem = LBVP(fields)\nadd_equation!(problem, \"lap(T) = f\")\nadd_bc!(problem, \"T(z=0) = 0\")\nadd_bc!(problem, \"T(z=1) = 1\")\n\nsolver = BoundaryValueSolver(problem)\nsolve!(solver)","category":"section"},{"location":"tutorials/overview/#Eigenvalue-Problems-(EVP)-2","page":"Tutorials Overview","title":"Eigenvalue Problems (EVP)","text":"When to use: Linear stability analysis, computing normal modes, or finding eigenvalues of differential operators.\n\nExamples:\n\nHydrodynamic stability\nNormal mode analysis\nResonance frequencies\n\nTypical structure:\n\nproblem = EVP(fields, eigenvalue=:sigma)\nadd_equation!(problem, \"sigma*u = -lap(u) + f\")\nadd_bc!(problem, \"u(z=0) = 0\")\n\nsolver = EigenvalueSolver(problem)\neigenvalues = solve!(solver, nev=10)","category":"section"},{"location":"tutorials/overview/#Choosing-a-Tutorial","page":"Tutorials Overview","title":"Choosing a Tutorial","text":"","category":"section"},{"location":"tutorials/overview/#By-Physics","page":"Tutorials Overview","title":"By Physics","text":"Fluid Dynamics:\n\nStart: 2D Rayleigh-Bénard\nAdvanced: 3D Turbulence, Channel Flow\n\nGeophysical Flows:\n\nStart: Surface Dynamics (SQG, QG)\nIntermediate: Rotating Shallow Water (wave-mean separation)\nAdvanced: GQL Approximation (zonal jets, turbulence closure)\n\nHeat Transfer:\n\nStart: First Steps (diffusion)\nAdvanced: 2D Rayleigh-Bénard (convection)\n\nStability Analysis:\n\nStart: Eigenvalue Problems","category":"section"},{"location":"tutorials/overview/#By-Technique","page":"Tutorials Overview","title":"By Technique","text":"Want to learn:\n\nMPI parallelization → Running with MPI\nBoundary conditions → Boundary Conditions\nOutput and analysis → Analysis and Output\n3D problems → 3D Turbulence","category":"section"},{"location":"tutorials/overview/#By-Complexity","page":"Tutorials Overview","title":"By Complexity","text":"Beginner: Basic concepts, single field\n\nFirst Steps\n\nIntermediate: Multiple fields, coupled equations\n\n2D Rayleigh-Bénard\nBoundary Conditions\nAnalysis and Output\n\nAdvanced: 3D problems, advanced analysis\n\n3D Turbulence\nEigenvalue Problems","category":"section"},{"location":"tutorials/overview/#Common-Patterns","page":"Tutorials Overview","title":"Common Patterns","text":"","category":"section"},{"location":"tutorials/overview/#Setting-Up-a-Simulation","page":"Tutorials Overview","title":"Setting Up a Simulation","text":"Every tutorial follows this pattern:\n\n# 1. MPI initialization\nusing Tarang, MPI\nMPI.Init()\n\n# 2. Domain setup\ncoords = CartesianCoordinates(...)\ndist = Distributor(coords, mesh=...)\nbases = (basis1, basis2, ...)\ndomain = Domain(dist, bases)\n\n# 3. Fields\nfield1 = ScalarField(...)\nfield2 = VectorField(...)\n\n# 4. Problem\nproblem = IVP([field1, field2, ...])\nadd_equation!(problem, \"...\")\nadd_bc!(problem, \"...\")\n\n# 5. Solver\nsolver = InitialValueSolver(problem, timestepper)\n\n# 6. Time loop\nwhile solver.sim_time < t_end\n    step!(solver, dt)\nend\n\n# 7. Cleanup\nMPI.Finalize()","category":"section"},{"location":"tutorials/overview/#Adding-Analysis","page":"Tutorials Overview","title":"Adding Analysis","text":"Common analysis tasks:\n\n# CFL condition\ncfl = CFL(problem)\nadd_velocity!(cfl, u)\n\n# File output\nhandler = add_netcdf_handler(\n    solver,\n    \"outputs\",\n    fields=[u, p, T],\n    write_interval=0.1\n)\n\n# Custom diagnostics\nfunction compute_diagnostics(solver, u, T)\n    ke = 0.5 * mean(u.data .^ 2)\n    temp_mean = mean(T.data)\n    return (ke=ke, temp=temp_mean)\nend","category":"section"},{"location":"tutorials/overview/#Getting-Help","page":"Tutorials Overview","title":"Getting Help","text":"If you're stuck on a tutorial:\n\nCheck the complete example at the end of each tutorial\nLook at the source code in the examples/ directory\nSearch the API reference for function documentation\nAsk on GitHub Discussions for community help","category":"section"},{"location":"tutorials/overview/#Contributing-Tutorials","page":"Tutorials Overview","title":"Contributing Tutorials","text":"We welcome tutorial contributions! See the Contributing Guide for details on:\n\nTutorial format and style\nAdding Jupyter notebooks\nIncluding visualizations\nTesting tutorial code","category":"section"},{"location":"tutorials/overview/#Next-Steps","page":"Tutorials Overview","title":"Next Steps","text":"Ready to start? Pick a tutorial from the list above or continue with:\n\n2D Rayleigh-Bénard Convection for a complete fluid dynamics example\nBoundary Conditions to master BC specification\nRunning with MPI for parallel computing details","category":"section"},{"location":"api/stochastic_forcing/#Stochastic-Forcing-API","page":"Stochastic Forcing API","title":"Stochastic Forcing API","text":"","category":"section"},{"location":"api/stochastic_forcing/#Types","page":"Stochastic Forcing API","title":"Types","text":"","category":"section"},{"location":"api/stochastic_forcing/#Abstract-Types","page":"Stochastic Forcing API","title":"Abstract Types","text":"abstract type Forcing end\nabstract type StochasticForcingType <: Forcing end\nabstract type DeterministicForcingType <: Forcing end","category":"section"},{"location":"api/stochastic_forcing/#StochasticForcing","page":"Stochastic Forcing API","title":"StochasticForcing","text":"Stochastic forcing in Fourier space with white-noise temporal correlation.\n\nType signature:\n\nmutable struct StochasticForcing{T<:AbstractFloat, N} <: StochasticForcingType\n\nFields:\n\nField Type Description\nforcing_spectrum Array{T, N} √Q̂(k) - amplitude spectrum\nenergy_injection_rate T Target ε\nk_forcing T Central forcing wavenumber\ndk_forcing T Forcing bandwidth\ndt T Current timestep\ndomain_size NTuple{N, T} Domain extent (Lx, Ly, ...)\nfield_size NTuple{N, Int} Grid size (Nx, Ny, ...)\nwavenumbers NTuple{N, Vector{T}} Wavenumber arrays (kx, ky, ...)\ncached_forcing Array{Complex{T}, N} Cached F̂ (constant within timestep)\nprevsol Union{Nothing, Array{Complex{T}, N}} Previous solution for Stratonovich work\nrng AbstractRNG Random number generator\nlast_update_time T Time of last forcing update\nspectrum_type Symbol Type of forcing spectrum\n\nConstructor:\n\nStochasticForcing(;\n    field_size::NTuple{N, Int},                    # Required\n    domain_size::NTuple{N, Real} = ntuple(i -> 2π, N),\n    energy_injection_rate::Real = 1.0,\n    k_forcing::Real = 4.0,\n    dk_forcing::Real = 1.0,\n    dt::Real = 0.01,\n    spectrum_type::Symbol = :ring,\n    rng::AbstractRNG = Random.GLOBAL_RNG,\n    dtype::Type{T} = Float64\n) where {T<:AbstractFloat, N}\n\nSpectrum types:\n\nSymbol Description Formula\n:ring Gaussian ring around k_f exp(-(\n:band Sharp band [kf - δf, kf + δf] 1 if\n:lowk Low wavenumber forcing 1 if\n:kolmogorov Large-scale Kolmogorov Smooth large-scale forcing","category":"section"},{"location":"api/stochastic_forcing/#DeterministicForcing","page":"Stochastic Forcing API","title":"DeterministicForcing","text":"Deterministic (non-random) forcing.\n\nType signature:\n\nmutable struct DeterministicForcing{T<:AbstractFloat, N, A<:AbstractArray{T, N}} <: DeterministicForcingType\n\nFields:\n\nField Type Description\nforcing_function Function f(x, y, ..., t, params) → forcing\nfield_size NTuple{N, Int} Grid size\ncached_forcing A Cached forcing values on the chosen architecture\nparameters Dict{Symbol, Any} Parameters for forcing function\narchitecture AbstractArchitecture CPU() or GPU() backend\n\nConstructor:\n\nDeterministicForcing(\n    forcing_function::Function,\n    field_size::NTuple{N, Int};\n    parameters::Dict{Symbol, Any} = Dict{Symbol, Any}(),\n    dtype::Type{T} = Float64,\n    architecture::AbstractArchitecture = CPU()\n)\n\n","category":"section"},{"location":"api/stochastic_forcing/#Forcing-Generation","page":"Stochastic Forcing API","title":"Forcing Generation","text":"","category":"section"},{"location":"api/stochastic_forcing/#generate_forcing!","page":"Stochastic Forcing API","title":"generate_forcing!","text":"Generate forcing realization. Returns cached value for substeps > 1.\n\nSignatures:\n\n# Stochastic forcing\ngenerate_forcing!(forcing::StochasticForcing, t::Real, substep::Int=1)\ngenerate_forcing!(forcing::StochasticForcing, t::Real)\n\n# Deterministic forcing\ngenerate_forcing!(forcing::DeterministicForcing, grid, t::Real)\n\nKey behavior:\n\nsubstep == 1: Generates new random forcing\nsubstep > 1: Returns cached forcing (same as substep 1)\nTime check: Won't regenerate if already updated at this time\n\nReturns: The cached forcing array forcing.cached_forcing","category":"section"},{"location":"api/stochastic_forcing/#apply_forcing!","page":"Stochastic Forcing API","title":"apply_forcing!","text":"Add forcing to a field in spectral space.\n\nSignature:\n\napply_forcing!(\n    rhs::AbstractArray{Complex{T}, N},\n    forcing::StochasticForcing{T, N},\n    t::Real,\n    substep::Int=1\n) where {T, N}\n\nEquivalent to: rhs .+= generate_forcing!(forcing, t, substep)\n\n","category":"section"},{"location":"api/stochastic_forcing/#Configuration","page":"Stochastic Forcing API","title":"Configuration","text":"","category":"section"},{"location":"api/stochastic_forcing/#set_dt!","page":"Stochastic Forcing API","title":"set_dt!","text":"Update the timestep used for Stratonovich scaling.\n\nset_dt!(forcing::StochasticForcing{T, N}, dt::Real) where {T, N}\n\nCall this when dt changes (e.g., adaptive timestepping).","category":"section"},{"location":"api/stochastic_forcing/#reset_forcing!","page":"Stochastic Forcing API","title":"reset_forcing!","text":"Reset forcing cache. Forces regeneration on next generate_forcing! call.\n\nreset_forcing!(forcing::StochasticForcing{T, N}) where {T, N}\n\n","category":"section"},{"location":"api/stochastic_forcing/#Work-Calculation","page":"Stochastic Forcing API","title":"Work Calculation","text":"","category":"section"},{"location":"api/stochastic_forcing/#store_prevsol!","page":"Stochastic Forcing API","title":"store_prevsol!","text":"Store the current solution for Stratonovich work calculation.\n\nstore_prevsol!(forcing::StochasticForcing{T, N}, sol::AbstractArray{Complex{T}, N})\n\nCall at the beginning of each timestep, before advancing.","category":"section"},{"location":"api/stochastic_forcing/#work_stratonovich","page":"Stochastic Forcing API","title":"work_stratonovich","text":"Compute work done using Stratonovich interpretation.\n\nwork_stratonovich(forcing::StochasticForcing{T, N}, sol::AbstractArray{Complex{T}, N}) -> T\n\nFormula:\n\nW = -textReleftlangle fracpsi^n + psi^n+12 cdot hatF^* rightrangle\n\nUses midpoint evaluation (requires store_prevsol! called first).","category":"section"},{"location":"api/stochastic_forcing/#work_ito","page":"Stochastic Forcing API","title":"work_ito","text":"Compute work done using Itô interpretation.\n\nwork_ito(forcing::StochasticForcing{T, N}, sol_prev::AbstractArray{Complex{T}, N}) -> T\n\nFormula:\n\nW_textItô = -textRelangle psi^n cdot hatF^* rangle cdot dt + varepsilon cdot dt\n\nUses initial value plus drift correction.\n\n","category":"section"},{"location":"api/stochastic_forcing/#Diagnostics","page":"Stochastic Forcing API","title":"Diagnostics","text":"","category":"section"},{"location":"api/stochastic_forcing/#mean*energy*injection_rate","page":"Stochastic Forcing API","title":"meanenergyinjection_rate","text":"Return the target (mean) energy injection rate ε.\n\nmean_energy_injection_rate(forcing::StochasticForcing) -> T","category":"section"},{"location":"api/stochastic_forcing/#instantaneous_power","page":"Stochastic Forcing API","title":"instantaneous_power","text":"Compute instantaneous power input P(t) = dW/dt.\n\ninstantaneous_power(forcing::StochasticForcing{T, N}, sol::AbstractArray{Complex{T}, N}) -> T\n\nThis fluctuates around the mean ε due to randomness.","category":"section"},{"location":"api/stochastic_forcing/#forcing*enstrophy*injection_rate","page":"Stochastic Forcing API","title":"forcingenstrophyinjection_rate","text":"Compute mean enstrophy injection rate (for 2D vorticity forcing).\n\nforcing_enstrophy_injection_rate(forcing::StochasticForcing{T, N}) -> T\n\nFormula:\n\neta = sum_k k^2 hatQ(k)  2","category":"section"},{"location":"api/stochastic_forcing/#get*forcing*spectrum","page":"Stochastic Forcing API","title":"getforcingspectrum","text":"Return the forcing amplitude spectrum √Q̂(k).\n\nget_forcing_spectrum(forcing::StochasticForcing) -> Array{T, N}","category":"section"},{"location":"api/stochastic_forcing/#get*cached*forcing","page":"Stochastic Forcing API","title":"getcachedforcing","text":"Return the current cached forcing F̂(k).\n\nget_cached_forcing(forcing::StochasticForcing) -> Array{Complex{T}, N}\n\n","category":"section"},{"location":"api/stochastic_forcing/#Internal-Functions","page":"Stochastic Forcing API","title":"Internal Functions","text":"","category":"section"},{"location":"api/stochastic_forcing/#build_wavenumbers","page":"Stochastic Forcing API","title":"build_wavenumbers","text":"Build wavenumber arrays for each dimension.\n\nbuild_wavenumbers(\n    field_size::NTuple{N, Int},\n    domain_size::NTuple{N, Real},\n    dtype::Type{T}\n) -> NTuple{N, Vector{T}}","category":"section"},{"location":"api/stochastic_forcing/#compute*forcing*spectrum","page":"Stochastic Forcing API","title":"computeforcingspectrum","text":"Compute the forcing amplitude spectrum √Q̂(k).\n\ncompute_forcing_spectrum(\n    wavenumbers::NTuple{N, Vector{T}},\n    k_f::Real,\n    dk_f::Real,\n    ε::Real,\n    domain_size::NTuple{N, Real},\n    spectrum_type::Symbol,\n    dtype::Type{T}\n) -> Array{T, N}\n\nThe spectrum is normalized such that energy injection rate equals ε.\n\n","category":"section"},{"location":"api/stochastic_forcing/#Exports","page":"Stochastic Forcing API","title":"Exports","text":"export Forcing, StochasticForcingType, DeterministicForcingType\nexport StochasticForcing, DeterministicForcing\nexport generate_forcing!, apply_forcing!\nexport reset_forcing!, set_dt!\nexport store_prevsol!, work_stratonovich, work_ito\nexport mean_energy_injection_rate, instantaneous_power\nexport forcing_enstrophy_injection_rate\nexport get_forcing_spectrum, get_cached_forcing\n\n","category":"section"},{"location":"api/stochastic_forcing/#Index","page":"Stochastic Forcing API","title":"Index","text":"Pages = [\"stochastic_forcing.md\"]","category":"section"},{"location":"api/stochastic_forcing/#Tarang.StochasticForcing","page":"Stochastic Forcing API","title":"Tarang.StochasticForcing","text":"StochasticForcing{T, N, A<:AbstractArray}\n\nStochastic forcing in Fourier space with white-noise temporal correlation. Supports both CPU and GPU architectures.\n\nMathematical Properties\n\nThe forcing F̂(k,t) satisfies:\n\n⟨F̂(k,t)⟩ = 0                                          (zero mean)\n⟨F̂(k,t) F̂*(k',t')⟩ = Q̂(k) δ(k-k') δ(t-t')/(dt)     (white noise)\n\nImplementation\n\nAt each timestep, the forcing is computed as:     F̂(k) = √(Q̂(k)) · ξ(k) / √(dt)\n\nwhere ξ(k) is complex white noise with |ξ| = 1 and random phase.\n\nFields\n\nforcing_spectrum::A: √Q̂(k) - square root of power spectrum\nenergy_injection_rate::T: Target energy injection rate ε\nk_forcing::T: Central forcing wavenumber k_f\ndk_forcing::T: Forcing bandwidth δ_f\ndt::T: Current timestep (for proper scaling)\ndomain_size::NTuple{N,T}: Domain size (Lx, Ly, ...)\nfield_size::NTuple{N,Int}: Grid size (Nx, Ny, ...)\nwavenumbers::NTuple{N,Vector{T}}: Wavenumber arrays (kx, ky, ...)\ncached_forcing::AbstractArray{Complex{T},N}: Cached forcing (constant within timestep)\nprevsol::Union{Nothing,AbstractArray{Complex{T},N}}: Previous solution (for Stratonovich work)\nrng::AbstractRNG: Random number generator (CPU-side; GPU uses device RNG when available)\nrandom_phases::AbstractArray{T,N}: Pre-allocated random phase buffer (on target architecture)\nlast_update_time::T: Time of last forcing update\nspectrum_type::Symbol: Type of forcing spectrum\nenforce_hermitian::Bool: Enforce Hermitian symmetry for real-valued fields\narchitecture::AbstractArchitecture: CPU() or GPU() architecture\n\n\n\n\n\n","category":"type"},{"location":"api/stochastic_forcing/#Tarang.DeterministicForcing","page":"Stochastic Forcing API","title":"Tarang.DeterministicForcing","text":"DeterministicForcing{T, N}\n\nDeterministic (non-random) forcing.\n\nExample\n\n# Sinusoidal forcing\nforcing = DeterministicForcing(\n    (x, y, t, p) -> p[:A] * sin(p[:k] * x) * cos(p[:ω] * t),\n    (64, 64);\n    parameters = Dict(:A => 1.0, :k => 4.0, :ω => 1.0)\n)\n\n\n\n\n\n","category":"type"},{"location":"api/stochastic_forcing/#Tarang.generate_forcing!","page":"Stochastic Forcing API","title":"Tarang.generate_forcing!","text":"generate_forcing!(forcing::StochasticForcing, t::Real, substep::Int=1)\n\nGenerate stochastic forcing at time t. Works on both CPU and GPU.\n\nKey Points\n\nForcing is regenerated only on substep 1 - ensures forcing stays constant within a timestep for IMEX and multi-stage methods.\nScaling: F̂(k) = √Q̂(k) · exp(2πi·rand) / √dt\nZero mean: The k=0 mode is always set to zero.\nHermitian symmetry (optional): F̂(-k) = F̂(k)* so that ifft produces real fields.\nGPU support: Random phases are generated on the target architecture when possible, then combined with the spectrum using broadcasted operations.\n\nArguments\n\nforcing: StochasticForcing configuration\nt: Current simulation time\nsubstep: Current substep (1 for first substep)\n\nReturns\n\nThe cached forcing array (modified in-place).\n\n\n\n\n\ngenerate_forcing!(forcing::StochasticForcing, t::Real)\n\nGenerate forcing without substep tracking. Equivalent to substep=1.\n\n\n\n\n\ngenerate_forcing!(forcing::DeterministicForcing, grid, t::Real)\n\nEvaluate deterministic forcing at time t on the given grid.\n\n\n\n\n\n","category":"function"},{"location":"api/stochastic_forcing/#Tarang.apply_forcing!","page":"Stochastic Forcing API","title":"Tarang.apply_forcing!","text":"apply_forcing!(rhs::AbstractArray, forcing::StochasticForcing, t::Real, substep::Int=1)\n\nAdd stochastic forcing to the RHS in spectral space. Works on both CPU and GPU.\n\nArguments\n\nrhs: Right-hand side array (modified in-place)\nforcing: StochasticForcing configuration\nt: Current simulation time\nsubstep: Current substep number\n\n\n\n\n\n","category":"function"},{"location":"api/stochastic_forcing/#Tarang.set_dt!","page":"Stochastic Forcing API","title":"Tarang.set_dt!","text":"set_dt!(forcing::StochasticForcing, dt::Real)\n\nUpdate the timestep for Stratonovich scaling.\n\nCall this when dt changes (e.g., adaptive timestepping).\n\n\n\n\n\n","category":"function"},{"location":"api/stochastic_forcing/#Tarang.reset_forcing!","page":"Stochastic Forcing API","title":"Tarang.reset_forcing!","text":"reset_forcing!(forcing::StochasticForcing)\n\nReset the forcing cache, causing regeneration on next call. Works on both CPU and GPU.\n\n\n\n\n\n","category":"function"},{"location":"api/stochastic_forcing/#Tarang.store_prevsol!","page":"Stochastic Forcing API","title":"Tarang.store_prevsol!","text":"store_prevsol!(forcing::StochasticForcing, sol::AbstractArray)\n\nStore the current solution for Stratonovich work calculation. Works on both CPU and GPU arrays.\n\nCall this at the beginning of each timestep, before advancing.\n\n\n\n\n\n","category":"function"},{"location":"api/stochastic_forcing/#Tarang.work_stratonovich","page":"Stochastic Forcing API","title":"Tarang.work_stratonovich","text":"work_stratonovich(forcing::StochasticForcing, sol::AbstractArray)\n\nCompute work done by forcing using Stratonovich interpretation. Works on both CPU and GPU arrays.\n\nFormula\n\nW = Re⟨(ψⁿ + ψⁿ⁺¹)/2 · ΔF̂*⟩\n\nwhere ΔF̂ = √Q̂ · ξ · √dt is the forcing increment over dt.\n\nThis correctly accounts for the correlation between forcing and response.\n\nArguments\n\nforcing: StochasticForcing with prevsol stored\nsol: Current solution ψⁿ⁺¹\n\nReturns\n\nWork done during this timestep (scalar, units of energy).\n\n\n\n\n\n","category":"function"},{"location":"api/stochastic_forcing/#Tarang.work_ito","page":"Stochastic Forcing API","title":"Tarang.work_ito","text":"work_ito(forcing::StochasticForcing, sol::AbstractArray)\n\nCompute work done by forcing using Itô interpretation. Works on both CPU and GPU arrays.\n\nFormula\n\nW_Itô = Re⟨ψⁿ · ΔF̂*⟩ + ε · dt\n\nwhere ΔF̂ = √Q̂ · ξ · √dt is the forcing increment.\n\nThe drift correction ε · dt accounts for the Itô-Stratonovich conversion. In Itô calculus, ψⁿ is independent of Fⁿ⁺¹, so ⟨ψⁿ · ΔF̂⟩ = 0. The drift ensures ⟨WItô⟩ = ⟨WStratonovich⟩ = ε · dt.\n\n\n\n\n\n","category":"function"},{"location":"api/stochastic_forcing/#Tarang.mean_energy_injection_rate","page":"Stochastic Forcing API","title":"Tarang.mean_energy_injection_rate","text":"mean_energy_injection_rate(forcing::StochasticForcing)\n\nReturn the target (mean) energy injection rate ε.\n\nThis is the ensemble average of work done per unit time.\n\n\n\n\n\n","category":"function"},{"location":"api/stochastic_forcing/#Tarang.instantaneous_power","page":"Stochastic Forcing API","title":"Tarang.instantaneous_power","text":"instantaneous_power(forcing::StochasticForcing, sol::AbstractArray)\n\nCompute instantaneous power input P = Re⟨ψ · F̂*⟩ / A. Works on both CPU and GPU arrays.\n\nThis is the correlation between the solution and forcing at a given instant. For white noise forcing, the expected value depends on which solution is passed:\n\n⟨P⟩ = 0 if sol is the solution BEFORE the forcing was applied (independent)\n⟨P⟩ = ε if sol is the MIDPOINT (ψⁿ + ψⁿ⁺¹)/2\n⟨P⟩ = 2ε if sol is the solution AFTER forcing (includes full response)\n\nNote: For the Stratonovich-consistent time-averaged power over the timestep, use work_stratonovich(forcing, sol) / forcing.dt instead.\n\nReturns\n\nInstantaneous power (energy per unit time).\n\n\n\n\n\n","category":"function"},{"location":"api/stochastic_forcing/#Tarang.forcing_enstrophy_injection_rate","page":"Stochastic Forcing API","title":"Tarang.forcing_enstrophy_injection_rate","text":"forcing_enstrophy_injection_rate(forcing::StochasticForcing)\n\nCompute mean enstrophy injection rate (for 2D turbulence).\n\nη = ∑_k |k|² Q̂(k) / (2 · domain_area)\n\nNote: This assumes the forcing spectrum Q̂(k) corresponds to direct field forcing. For vorticity forcing, enstrophy injection is simply ε. For streamfunction forcing, this formula gives the enstrophy injection rate.\n\n\n\n\n\n","category":"function"},{"location":"api/stochastic_forcing/#Tarang.get_forcing_spectrum","page":"Stochastic Forcing API","title":"Tarang.get_forcing_spectrum","text":"get_forcing_spectrum(forcing::StochasticForcing)\n\nReturn the forcing amplitude spectrum √Q̂(k).\n\n\n\n\n\n","category":"function"},{"location":"api/stochastic_forcing/#Tarang.get_cached_forcing","page":"Stochastic Forcing API","title":"Tarang.get_cached_forcing","text":"get_cached_forcing(forcing::StochasticForcing)\n\nReturn the current cached forcing F̂(k).\n\n\n\n\n\nget_cached_forcing(state::TimestepperState)\n\nGet the cached forcing array. Returns nothing if no forcing is configured.\n\n\n\n\n\n","category":"function"},{"location":"pages/bases/#Spectral-Bases","page":"Spectral Bases","title":"Spectral Bases","text":"Spectral bases define how functions are represented in each coordinate direction.","category":"section"},{"location":"pages/bases/#Basis-Selection-Guide","page":"Spectral Bases","title":"Basis Selection Guide","text":"Boundary Type Recommended Basis Grid Points\nPeriodic RealFourier Uniform\nNon-periodic (walls) ChebyshevT Gauss-Lobatto\nNon-periodic (alternative) Legendre Gauss-Lobatto","category":"section"},{"location":"pages/bases/#Fourier-Bases","page":"Spectral Bases","title":"Fourier Bases","text":"","category":"section"},{"location":"pages/bases/#RealFourier","page":"Spectral Bases","title":"RealFourier","text":"For periodic directions with real-valued data.\n\nusing Tarang\n\ncoords = CartesianCoordinates(\"x\")\nx = coords[\"x\"]\n\n# Basic usage\nbasis = RealFourier(x; size=128, bounds=(0.0, 2π))\n\n# With dealiasing (recommended for nonlinear problems)\nbasis = RealFourier(x; size=128, bounds=(0.0, 2π), dealias=3/2)\n\nParameters:\n\nsize: Number of modes (should be even)\nbounds: Domain boundaries (min, max)\ndealias: Dealiasing factor (1.0 = none, 1.5 = 3/2 rule)\n\nProperties:\n\nbasis.size        # Number of modes\nbasis.bounds      # (min, max) tuple\nbasis.grid_size   # Number of grid points","category":"section"},{"location":"pages/bases/#ComplexFourier","page":"Spectral Bases","title":"ComplexFourier","text":"For complex-valued data or full complex FFT.\n\nbasis = ComplexFourier(x; size=128, bounds=(0.0, 2π))","category":"section"},{"location":"pages/bases/#Chebyshev-Bases","page":"Spectral Bases","title":"Chebyshev Bases","text":"","category":"section"},{"location":"pages/bases/#ChebyshevT","page":"Spectral Bases","title":"ChebyshevT","text":"Chebyshev polynomials of the first kind. Best for bounded domains with walls.\n\ncoords = CartesianCoordinates(\"z\")\nz = coords[\"z\"]\n\nbasis = ChebyshevT(z; size=64, bounds=(0.0, 1.0))\n\nGrid Points: Chebyshev-Gauss-Lobatto points, clustered near boundaries.\n\n# Grid points in [-1, 1]:\n# ξ_i = cos(πi / (N-1)),  i = 0, 1, ..., N-1\n\n# Mapped to [a, b]:\n# x_i = (a+b)/2 + (b-a)/2 * ξ_i","category":"section"},{"location":"pages/bases/#ChebyshevU","page":"Spectral Bases","title":"ChebyshevU","text":"Chebyshev polynomials of the second kind. Grid excludes endpoints.\n\nbasis = ChebyshevU(z; size=64, bounds=(0.0, 1.0))","category":"section"},{"location":"pages/bases/#Legendre-Basis","page":"Spectral Bases","title":"Legendre Basis","text":"Alternative to Chebyshev for bounded domains.\n\nbasis = Legendre(z; size=64, bounds=(0.0, 1.0))\n\nWhen to use:\n\nSome problems with specific weight functions\nAlternative numerical properties\nGenerally similar to ChebyshevT","category":"section"},{"location":"pages/bases/#Resolution-Guidelines","page":"Spectral Bases","title":"Resolution Guidelines","text":"","category":"section"},{"location":"pages/bases/#Fourier-Resolution","page":"Spectral Bases","title":"Fourier Resolution","text":"# Rule of thumb: resolve smallest scales\nL = 2π              # Domain length\nη = (ν^3/ε)^(1/4)   # Kolmogorov scale (turbulence)\nN = L / η           # Required modes (minimum)\n\nFlow Type Typical Resolution\nLaminar 64-128\nTransitional 128-256\nTurbulent 256-1024+","category":"section"},{"location":"pages/bases/#Chebyshev-Resolution","page":"Spectral Bases","title":"Chebyshev Resolution","text":"Feature Typical Modes\nSmooth profiles 32-64\nBoundary layers 64-128\nSteep gradients 128-256","category":"section"},{"location":"pages/bases/#Dealiasing","page":"Spectral Bases","title":"Dealiasing","text":"Prevents aliasing errors in nonlinear terms.","category":"section"},{"location":"pages/bases/#3/2-Rule","page":"Spectral Bases","title":"3/2 Rule","text":"Most common dealiasing strategy:\n\n# Grid is padded by 3/2 during transforms\nbasis = RealFourier(x; size=128, dealias=1.5)\n# Transforms use 192 grid points\n# Only 128 modes retained","category":"section"},{"location":"pages/bases/#2/1-Rule","page":"Spectral Bases","title":"2/1 Rule","text":"For highly nonlinear problems:\n\nbasis = RealFourier(x; size=128, dealias=2.0)","category":"section"},{"location":"pages/bases/#No-Dealiasing","page":"Spectral Bases","title":"No Dealiasing","text":"For linear problems only:\n\nbasis = RealFourier(x; size=128, dealias=1.0)","category":"section"},{"location":"pages/bases/#Multi-Dimensional-Domains","page":"Spectral Bases","title":"Multi-Dimensional Domains","text":"Combine bases for each direction:\n\ncoords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords; mesh=(2, 2))\n\n# Periodic x, bounded z\nx_basis = RealFourier(coords[\"x\"]; size=256, bounds=(0.0, 4.0))\nz_basis = ChebyshevT(coords[\"z\"]; size=64, bounds=(0.0, 1.0))\n\n# Create domain\ndomain = Domain(dist, (x_basis, z_basis))","category":"section"},{"location":"pages/bases/#Grid-and-Spectral-Space","page":"Spectral Bases","title":"Grid and Spectral Space","text":"","category":"section"},{"location":"pages/bases/#Transforms","page":"Spectral Bases","title":"Transforms","text":"# Field starts in spectral space\nfield = ScalarField(dist, \"T\", (x_basis, z_basis), Float64)\n\n# Transform to grid space\nTarang.ensure_layout!(field, :g)\n\n# Access grid data\ndata = field.data_g\n\n# Transform back to spectral\nTarang.ensure_layout!(field, :c)","category":"section"},{"location":"pages/bases/#Grid-Points","page":"Spectral Bases","title":"Grid Points","text":"# Get grid for a basis\nx_grid = get_grid(x_basis)\nz_grid = get_grid(z_basis)\n\n# Create 2D meshgrid\nX = repeat(x_grid, 1, length(z_grid))\nZ = repeat(z_grid', length(x_grid), 1)","category":"section"},{"location":"pages/bases/#Performance-Tips","page":"Spectral Bases","title":"Performance Tips","text":"Power-of-2 sizes: Use N = 2^m for fastest FFTs\nDealiasing cost: ~50% more computation with 3/2 rule\nChebyshev efficiency: Sparse differentiation matrices\nMemory: RealFourier uses ~50% memory of ComplexFourier","category":"section"},{"location":"pages/bases/#See-Also","page":"Spectral Bases","title":"See Also","text":"Coordinates: Coordinate systems\nDomains: Creating full domains\nAPI: Bases: Complete reference","category":"section"},{"location":"pages/operators/#Operators","page":"Operators","title":"Operators","text":"Operators perform mathematical operations on fields, including differentiation and vector calculus.","category":"section"},{"location":"pages/operators/#Differential-Operators","page":"Operators","title":"Differential Operators","text":"","category":"section"},{"location":"pages/operators/#First-Derivatives","page":"Operators","title":"First Derivatives","text":"# Syntax in equations\n∂x(field)   # ∂/∂x\n∂y(field)   # ∂/∂y\n∂z(field)   # ∂/∂z\n\n# Example\nadd_equation!(problem, \"∂t(T) = -u*∂x(T) - w*∂z(T)\")","category":"section"},{"location":"pages/operators/#Second-Derivatives","page":"Operators","title":"Second Derivatives","text":"# Composed derivatives\n∂x(∂x(field))   # ∂²/∂x²\n∂z(∂z(field))   # ∂²/∂z²\n∂x(∂z(field))   # ∂²/∂x∂z","category":"section"},{"location":"pages/operators/#Laplacian","page":"Operators","title":"Laplacian","text":"# Δ(f) = ∇²f\nΔ(field)\n\n# Example: Diffusion equation\nadd_equation!(problem, \"∂t(T) = kappa*Δ(T)\")","category":"section"},{"location":"pages/operators/#Fractional-Laplacian","page":"Operators","title":"Fractional Laplacian","text":"The fractional Laplacian (-Δ)^α generalizes the Laplacian to non-integer powers:\n\n# fraclap(f, α) = (-Δ)^α f\nfraclap(field, 0.5)    # Square root: (-Δ)^(1/2)\nfraclap(field, -0.5)   # Inverse square root: (-Δ)^(-1/2)\nfraclap(field, 1.0)    # Standard Laplacian: (-Δ)^1 = -Δ\nfraclap(field, 2.0)    # Biharmonic: (-Δ)^2 = Δ²\n\n# Convenience functions\nsqrtlap(field)         # Same as fraclap(f, 0.5)\ninvsqrtlap(field)      # Same as fraclap(f, -0.5)\n\nIn spectral space: Multiplication by |k|^(2α) where k is the wavenumber.\n\nApplications:\n\nSQG dynamics: ψ = (-Δ)^(-1/2) θ for streamfunction from buoyancy\nFractional diffusion: ∂θ/∂t = -κ(-Δ)^α θ for anomalous diffusion\nHyperviscosity: (-Δ)^n for numerical dissipation at small scales\n\n# SQG buoyancy equation with fractional dissipation\nadd_equation!(problem, \"∂t(θ) = -u⋅∇(θ) + κ*fraclap(θ, 0.5)\")\n\n# Can also be used on LHS (implicit treatment)\nadd_equation!(problem, \"∂t(θ) + κ*fraclap(θ, 0.5) = -u⋅∇(θ)\")","category":"section"},{"location":"pages/operators/#Hyperviscosity-(Higher-Order-Laplacian)","page":"Operators","title":"Hyperviscosity (Higher-Order Laplacian)","text":"For turbulence simulations, hyperviscosity provides selective dissipation at small scales while preserving large-scale dynamics:\n\n# General form: hyperlap(f, n) = (-Δ)^n = |k|^(2n) in Fourier space\nhyperlap(field, 2)   # Biharmonic: (-Δ)² = |k|⁴\nhyperlap(field, 4)   # 8th-order: (-Δ)⁴ = |k|⁸\nhyperlap(field, 8)   # 16th-order: (-Δ)⁸ = |k|¹⁶\n\n# Unicode shortcuts (preferred)\nΔ²(field)   # Biharmonic (4th-order derivative)\nΔ⁴(field)   # 8th-order derivative\nΔ⁶(field)   # 12th-order derivative\nΔ⁸(field)   # 16th-order derivative\n\nIn spectral space: Multiplication by |k|^(2n) - very efficient for Fourier bases.\n\nUsage in equations:\n\n# 2D turbulence with biharmonic hyperviscosity\nadd_equation!(problem, \"∂t(ω) = -u⋅∇(ω) - ν₄*Δ²(ω)\")\n\n# 3D turbulence with 8th-order hyperviscosity\nadd_equation!(problem, \"∂t(u) = -u⋅∇(u) - ∇(p) - ν₈*Δ⁴(u)\")\n\n# General n-th order using hyperlap\nadd_equation!(problem, \"∂t(u) = -u⋅∇(u) - ν*hyperlap(u, 4)\")\n\nWhy use hyperviscosity?\n\nOrder Operator Spectral Use Case\n2 Δ -k² Standard viscosity\n4 Δ² k⁴ Mild scale separation\n8 Δ⁴ k⁸ Strong scale separation\n16 Δ⁸ k¹⁶ Extreme Reynolds numbers\n\nHigher orders concentrate dissipation at the smallest resolved scales, extending the inertial range.\n\nTyping Unicode:\n\nSymbol Type\nΔ² \\Delta + Tab, \\^2 + Tab\nΔ⁴ \\Delta + Tab, \\^4 + Tab\nΔ⁶ \\Delta + Tab, \\^6 + Tab\nΔ⁸ \\Delta + Tab, \\^8 + Tab","category":"section"},{"location":"pages/operators/#Vector-Calculus","page":"Operators","title":"Vector Calculus","text":"","category":"section"},{"location":"pages/operators/#Gradient","page":"Operators","title":"Gradient","text":"Converts scalar to vector field.\n\n# grad(p) = ∇p\nadd_equation!(problem, \"∂t(u) = -grad(p)\")\n\n# Components:\n# ∂p/∂x, ∂p/∂y, ∂p/∂z","category":"section"},{"location":"pages/operators/#Divergence","page":"Operators","title":"Divergence","text":"Converts vector to scalar field.\n\n# div(u) = ∇·u\nadd_equation!(problem, \"div(u) = 0\")\n\n# Expands to:\n# ∂u_x/∂x + ∂u_y/∂y + ∂u_z/∂z = 0","category":"section"},{"location":"pages/operators/#Curl","page":"Operators","title":"Curl","text":"For 3D vector fields (returns vector):\n\n# curl(u) = ∇×u\nomega = curl(u)\n\nFor 2D (returns scalar vorticity):\n\n# ω = ∂v/∂x - ∂u/∂y\nadd_equation!(problem, \"omega = ∂x(v) - ∂y(u)\")","category":"section"},{"location":"pages/operators/#Perpendicular-Gradient","page":"Operators","title":"Perpendicular Gradient","text":"For 2D flows, the perpendicular gradient creates a divergence-free velocity from a streamfunction:\n\n# perp_grad(ψ) = ∇⊥ψ = (-∂ψ/∂y, ∂ψ/∂x)\nu = perp_grad(psi)\n\n# This gives: u_x = -∂ψ/∂y, u_y = ∂ψ/∂x\n# Automatically satisfies: ∇·u = 0\n\nApplications:\n\n2D incompressible flow: u = ∇⊥ψ from streamfunction\nSQG velocity: u = ∇⊥((-Δ)^(-1/2) θ)\nQG geostrophic flow: u = ∇⊥ψ","category":"section"},{"location":"pages/operators/#Time-Derivatives","page":"Operators","title":"Time Derivatives","text":"# ∂t(field) for IVP equations\nadd_equation!(problem, \"∂t(u) = rhs\")\n\n# Only valid in Initial Value Problems","category":"section"},{"location":"pages/operators/#Unicode-Operators","page":"Operators","title":"Unicode Operators","text":"Tarang supports Unicode mathematical notation for cleaner, more readable code:\n\nUnicode ASCII Equivalent Description\n∇ grad Gradient\nΔ lap Laplacian\n∇² lap Laplacian (alternative)\n∂t dt Time derivative\n⋅ dot Dot product\n× cross Cross product\n∇⊥ perp_grad Perpendicular gradient\nΔᵅ fraclap Fractional Laplacian","category":"section"},{"location":"pages/operators/#In-Equations","page":"Operators","title":"In Equations","text":"# Unicode syntax\nadd_equation!(problem, \"∂t(u) + u⋅∇(u) = nu*Δ(u) - ∇(p)\")","category":"section"},{"location":"pages/operators/#In-Code","page":"Operators","title":"In Code","text":"# ASCII\nvelocity = grad(pressure)\nvorticity = curl(velocity)\n\n# Unicode (equivalent)\nvelocity = ∇(pressure)\nvorticity = curl(velocity)\n\n# Mixed - use what's clearest\nu = ∇⊥(ψ)        # Perpendicular gradient\ndissipation = Δ(T)  # Laplacian","category":"section"},{"location":"pages/operators/#Typing-Unicode-in-Julia","page":"Operators","title":"Typing Unicode in Julia","text":"In Julia REPL or editors with Julia support:\n\nSymbol Type\n∇ \\nabla + Tab\nΔ \\Delta + Tab\n∂ \\partial + Tab\n⋅ \\cdot + Tab\n× \\times + Tab\n⊥ \\perp + Tab\nα \\alpha + Tab\n½ \\^1 + Tab, then type /2","category":"section"},{"location":"pages/operators/#Using-Operators-in-Equations","page":"Operators","title":"Using Operators in Equations","text":"","category":"section"},{"location":"pages/operators/#Symbolic-Syntax","page":"Operators","title":"Symbolic Syntax","text":"# Equations are strings parsed symbolically\nadd_equation!(problem, \"∂t(T) + u*∂x(T) = kappa*Δ(T)\")\n\n# Supports:\n# - Addition/subtraction: +, -\n# - Multiplication: *\n# - Division: /\n# - Parentheses: (, )\n# - Function calls: sin, cos, exp, etc.","category":"section"},{"location":"pages/operators/#Common-Patterns","page":"Operators","title":"Common Patterns","text":"# Advection\n\"u*∂x(f) + w*∂z(f)\"\n\n# Diffusion\n\"nu*Δ(u)\"\n\n# Pressure gradient\n\"∂x(p)\"  # or \"∇(p)\" for vector\n\n# Navier-Stokes viscous term\n\"nu*(∂x(∂x(u)) + ∂z(∂z(u)))\"\n# or simply:\n\"nu*Δ(u)\"","category":"section"},{"location":"pages/operators/#Implementation-Details","page":"Operators","title":"Implementation Details","text":"","category":"section"},{"location":"pages/operators/#Fourier-Differentiation","page":"Operators","title":"Fourier Differentiation","text":"For Fourier bases, differentiation is multiplication by wavenumber:\n\nfracpartialpartial x sum_k hatf_k e^ikx = sum_k (ik) hatf_k e^ikx","category":"section"},{"location":"pages/operators/#Chebyshev-Differentiation","page":"Operators","title":"Chebyshev Differentiation","text":"Uses recurrence relations:\n\nfracdT_ndx = n U_n-1(x)\n\nImplemented as sparse matrix operations.","category":"section"},{"location":"pages/operators/#Computational-Cost","page":"Operators","title":"Computational Cost","text":"Operation Cost\nFourier derivative O(N)\nChebyshev derivative O(N²) sparse\nLaplacian Same as 2× first derivative","category":"section"},{"location":"pages/operators/#Custom-Operators","page":"Operators","title":"Custom Operators","text":"","category":"section"},{"location":"pages/operators/#Helper-Functions","page":"Operators","title":"Helper Functions","text":"function advection(u, field)\n    # u·∇f\n    result = u.components[1] * ∂x(field)\n    for i in 2:length(u.components)\n        result += u.components[i] * d[i](field)\n    end\n    return result\nend","category":"section"},{"location":"pages/operators/#Using-Built-in-Operators-in-Equations","page":"Operators","title":"Using Built-in Operators in Equations","text":"The equation parser recognizes all built-in operators:\n\n# Available operators in equations:\n# grad, div, curl, lap (or Δ), dt (or ∂t), d\n# integrate, average, interpolate, convert, lift\n# sin, cos, tan, exp, log, sqrt, abs, tanh\n\n# Use operators directly\nadd_equation!(problem, \"∂t(T) = -ux*∂x(T) - uz*∂z(T) + kappa*Δ(T)\")","category":"section"},{"location":"pages/operators/#Performance-Tips","page":"Operators","title":"Performance Tips","text":"Minimize transforms: Group operations in same space\nUse Laplacian: Δ(f) is optimized vs ∂x(∂x(f)) + ∂z(∂z(f))\nSpectral derivatives: Free in Fourier, cheap in Chebyshev\nNonlinear terms: Require transform to grid space","category":"section"},{"location":"pages/operators/#See-Also","page":"Operators","title":"See Also","text":"Fields: What operators act on\nProblems: Using operators in PDEs\nSurface Dynamics: SQG, QG, and boundary advection-diffusion\nAPI: Operators: Complete reference","category":"section"},{"location":"pages/problems/#Problems","page":"Problems","title":"Problems","text":"Problems define the PDE system to be solved, including equations and boundary conditions.","category":"section"},{"location":"pages/problems/#Problem-Types","page":"Problems","title":"Problem Types","text":"","category":"section"},{"location":"pages/problems/#IVP-Initial-Value-Problem","page":"Problems","title":"IVP - Initial Value Problem","text":"Time-dependent PDEs with initial conditions.\n\nusing Tarang\n\n# Create IVP\nproblem = IVP([u, v, p, T])\n\n# Add evolution equations\nadd_equation!(problem, \"∂t(u) = -u*∂x(u) + nu*Δ(u)\")\nadd_equation!(problem, \"∂t(T) = -u*∂x(T) + kappa*Δ(T)\")","category":"section"},{"location":"pages/problems/#LBVP-Linear-Boundary-Value-Problem","page":"Problems","title":"LBVP - Linear Boundary Value Problem","text":"Steady-state linear PDEs.\n\n# Create LBVP\nproblem = LBVP([phi])\n\n# Add equations\nadd_equation!(problem, \"Δ(phi) = rho\")","category":"section"},{"location":"pages/problems/#NLBVP-Nonlinear-Boundary-Value-Problem","page":"Problems","title":"NLBVP - Nonlinear Boundary Value Problem","text":"Steady-state nonlinear PDEs.\n\n# Create NLBVP\nproblem = NLBVP([u, p])\n\n# Add nonlinear equations\nadd_equation!(problem, \"u*∂x(u) + ∂x(p) = nu*Δ(u)\")","category":"section"},{"location":"pages/problems/#EVP-Eigenvalue-Problem","page":"Problems","title":"EVP - Eigenvalue Problem","text":"Linear stability and eigenvalue analysis.\n\n# Create EVP with eigenvalue name\nevp = EVP([u_hat, p_hat]; eigenvalue=:sigma)\n\n# Add eigenvalue equations\nadd_equation!(evp, \"sigma*u_hat = Δ(u_hat)\")","category":"section"},{"location":"pages/problems/#Adding-Equations","page":"Problems","title":"Adding Equations","text":"","category":"section"},{"location":"pages/problems/#Equation-Syntax","page":"Problems","title":"Equation Syntax","text":"# Format: \"LHS = RHS\"\nadd_equation!(problem, \"∂t(u) = rhs_expression\")\n\n# Multiple terms\nadd_equation!(problem, \"∂t(u) + u*∂x(u) = nu*Δ(u) - ∂x(p)\")","category":"section"},{"location":"pages/problems/#Supported-Operations","page":"Problems","title":"Supported Operations","text":"Derivatives: ∂x, ∂y, ∂z, ∂t, Δ, ∇, div, curl\nArithmetic: +, -, *, /\nFunctions: sin, cos, exp, sqrt\nParameters: Any name in problem.parameters","category":"section"},{"location":"pages/problems/#Parameters","page":"Problems","title":"Parameters","text":"# Define parameters\nproblem.parameters[\"nu\"] = 0.01\nproblem.parameters[\"Ra\"] = 1e6\nproblem.parameters[\"Pr\"] = 1.0\n\n# Use in equations\nadd_equation!(problem, \"∂t(u) = nu*Δ(u)\")\nadd_equation!(problem, \"∂t(T) = Ra*Pr*w + Δ(T)\")","category":"section"},{"location":"pages/problems/#Boundary-Conditions","page":"Problems","title":"Boundary Conditions","text":"Boundary conditions use the same add_equation! function as PDEs. The Dedalus-style syntax field(coord=value) is auto-detected and converted to the appropriate boundary condition.","category":"section"},{"location":"pages/problems/#Dirichlet-(Value)","page":"Problems","title":"Dirichlet (Value)","text":"# u = value at location\nadd_equation!(problem, \"u(z=0) = 0\")  # u=0 at z=0\nadd_equation!(problem, \"T(z=1) = 0\")  # T=0 at z=1","category":"section"},{"location":"pages/problems/#Neumann-(Derivative)","page":"Problems","title":"Neumann (Derivative)","text":"# du/dz = value at location\nadd_equation!(problem, \"∂z(T)(z=1) = 0\")  # ∂T/∂z=0 at z=1","category":"section"},{"location":"pages/problems/#Robin-(Mixed)","page":"Problems","title":"Robin (Mixed)","text":"# α*u + β*du/dn = γ\nadd_equation!(problem, \"1.0*T(z=0) + 1.0*∂z(T)(z=0) = 0\")","category":"section"},{"location":"pages/problems/#Stress-Free","page":"Problems","title":"Stress-Free","text":"# du/dz = 0 (free surface)\nadd_equation!(problem, \"∂z(u)(z=1) = 0\")","category":"section"},{"location":"pages/problems/#No-Slip","page":"Problems","title":"No-Slip","text":"# u = 0 (solid wall)\nadd_equation!(problem, \"u(z=0) = 0\")","category":"section"},{"location":"pages/problems/#Problem-Validation","page":"Problems","title":"Problem Validation","text":"# Check problem is well-posed\nis_valid = validate_problem(problem)\n\n# Reports issues:\n# - Missing boundary conditions\n# - Incompatible equation counts\n# - Parameter issues","category":"section"},{"location":"pages/problems/#Common-Problem-Patterns","page":"Problems","title":"Common Problem Patterns","text":"","category":"section"},{"location":"pages/problems/#Heat-Equation","page":"Problems","title":"Heat Equation","text":"problem = IVP([T])\nproblem.parameters[\"kappa\"] = 0.01\nadd_equation!(problem, \"∂t(T) = kappa*Δ(T)\")\nadd_equation!(problem, \"T(z=0) = 1\")\nadd_equation!(problem, \"T(z=1) = 0\")","category":"section"},{"location":"pages/problems/#Incompressible-Navier-Stokes","page":"Problems","title":"Incompressible Navier-Stokes","text":"problem = IVP([ux, uz, p])\nproblem.parameters[\"nu\"] = 0.01\n\n# Momentum\nadd_equation!(problem, \"∂t(ux) + ux*∂x(ux) + uz*∂z(ux) + ∂x(p) = nu*Δ(ux)\")\nadd_equation!(problem, \"∂t(uz) + ux*∂x(uz) + uz*∂z(uz) + ∂z(p) = nu*Δ(uz)\")\n\n# Continuity\nadd_equation!(problem, \"∂x(ux) + ∂z(uz) = 0\")\n\n# No-slip walls\nfor field in [\"ux\", \"uz\"]\n    add_equation!(problem, \"$(field)(z=0) = 0\")\n    add_equation!(problem, \"$(field)(z=1) = 0\")\nend","category":"section"},{"location":"pages/problems/#Rayleigh-Bénard","page":"Problems","title":"Rayleigh-Bénard","text":"problem = IVP([ux, uz, p, T])\nproblem.parameters[\"Ra\"] = 1e6\nproblem.parameters[\"Pr\"] = 1.0\n\nadd_equation!(problem, \"∂t(ux) + ux*∂x(ux) + uz*∂z(ux) + ∂x(p) = Pr*Δ(ux)\")\nadd_equation!(problem, \"∂t(uz) + ux*∂x(uz) + uz*∂z(uz) + ∂z(p) = Pr*Δ(uz) + Ra*Pr*T\")\nadd_equation!(problem, \"∂x(ux) + ∂z(uz) = 0\")\nadd_equation!(problem, \"∂t(T) + ux*∂x(T) + uz*∂z(T) = Δ(T)\")\n\n# Boundary conditions\nadd_equation!(problem, \"ux(z=0) = 0\")\nadd_equation!(problem, \"ux(z=1) = 0\")\nadd_equation!(problem, \"uz(z=0) = 0\")\nadd_equation!(problem, \"uz(z=1) = 0\")\nadd_equation!(problem, \"T(z=0) = 1\")  # Hot bottom\nadd_equation!(problem, \"T(z=1) = 0\")  # Cold top","category":"section"},{"location":"pages/problems/#Poisson-Equation-(BVP)","page":"Problems","title":"Poisson Equation (BVP)","text":"problem = LBVP([phi])\nadd_equation!(problem, \"Δ(phi) = rho\")\nadd_equation!(problem, \"phi(z=0) = 0\")\nadd_equation!(problem, \"phi(z=1) = 0\")","category":"section"},{"location":"pages/problems/#See-Also","page":"Problems","title":"See Also","text":"Solvers: Solving problems\nBoundary Conditions Tutorial: Detailed BC guide\nAPI: Problems: Complete reference","category":"section"},{"location":"getting_started/installation/#Installation","page":"Installation","title":"Installation","text":"This guide walks you through installing Tarang.jl and its dependencies.","category":"section"},{"location":"getting_started/installation/#System-Requirements","page":"Installation","title":"System Requirements","text":"","category":"section"},{"location":"getting_started/installation/#Julia","page":"Installation","title":"Julia","text":"Tarang.jl requires Julia 1.6 or later. We recommend using the latest stable release of Julia.\n\nDownload Julia:\n\nVisit julialang.org/downloads\nFor Linux/macOS: Use juliaup for easy version management\nFor Windows: Download the installer from the Julia website\n\nVerify installation:\n\njulia --version","category":"section"},{"location":"getting_started/installation/#MPI-Library","page":"Installation","title":"MPI Library","text":"Tarang.jl requires an MPI implementation for parallel computing.","category":"section"},{"location":"getting_started/installation/#Linux-(Ubuntu/Debian)","page":"Installation","title":"Linux (Ubuntu/Debian)","text":"sudo apt-get install openmpi-bin libopenmpi-dev","category":"section"},{"location":"getting_started/installation/#macOS","page":"Installation","title":"macOS","text":"brew install open-mpi","category":"section"},{"location":"getting_started/installation/#Windows","page":"Installation","title":"Windows","text":"Download and install Microsoft MPI or use WSL with Linux MPI.\n\nVerify MPI installation:\n\nmpiexec --version","category":"section"},{"location":"getting_started/installation/#Optional:-HPC-Clusters","page":"Installation","title":"Optional: HPC Clusters","text":"On HPC systems, load the appropriate MPI module:\n\nmodule load openmpi/4.1.0  # or your system's MPI module\n\nwarning: MPI Compatibility\nEnsure that MPI.jl is built against the same MPI library you plan to use. See the MPI.jl documentation for details on configuring MPI.","category":"section"},{"location":"getting_started/installation/#Installing-Tarang.jl","page":"Installation","title":"Installing Tarang.jl","text":"","category":"section"},{"location":"getting_started/installation/#From-GitHub-(Recommended)","page":"Installation","title":"From GitHub (Recommended)","text":"The package is currently hosted on GitHub and can be installed directly:\n\nusing Pkg\nPkg.add(url=\"https://github.com/subhk/Tarang.jl\")","category":"section"},{"location":"getting_started/installation/#Development-Installation","page":"Installation","title":"Development Installation","text":"For development or to get the latest features:\n\ngit clone https://github.com/subhk/Tarang.jl.git\ncd Tarang.jl\njulia --project=. -e 'using Pkg; Pkg.instantiate()'\n\nThen in Julia:\n\nusing Pkg\nPkg.develop(path=\"/path/to/Tarang.jl\")","category":"section"},{"location":"getting_started/installation/#Installing-Dependencies","page":"Installation","title":"Installing Dependencies","text":"Tarang.jl will automatically install most Julia dependencies. Key packages include:\n\nMPI.jl: MPI bindings for Julia\nPencilArrays.jl: Distributed array library for spectral methods\nPencilFFTs.jl: Parallel FFT transforms\nFFTW.jl: Fast Fourier Transform library\nHDF5.jl: HDF5 file I/O\nLinearAlgebra: Standard library (included with Julia)\nSparseArrays: Standard library (included with Julia)","category":"section"},{"location":"getting_started/installation/#Configuring-MPI.jl","page":"Installation","title":"Configuring MPI.jl","text":"If you need to use a system-provided MPI:\n\nusing Pkg\nENV[\"JULIA_MPI_BINARY\"] = \"system\"\nPkg.build(\"MPI\"; verbose=true)\n\nVerify MPI configuration:\n\nusing MPI\nMPI.versioninfo()","category":"section"},{"location":"getting_started/installation/#Verification","page":"Installation","title":"Verification","text":"Test your installation:\n\nusing Tarang\nusing MPI\n\nprintln(\"Tarang.jl version: \", Tarang.__version__)\nprintln(\"MPI available: \", MPI.Initialized() || MPI.Init())\n\nRun the test suite:\n\nusing Pkg\nPkg.test(\"Tarang\")","category":"section"},{"location":"getting_started/installation/#Quick-Test-Run","page":"Installation","title":"Quick Test Run","text":"Create a test file test_tarang.jl:\n\nusing Tarang, MPI\n\nMPI.Init()\n\nrank = MPI.Comm_rank(MPI.COMM_WORLD)\nsize = MPI.Comm_size(MPI.COMM_WORLD)\n\nif rank == 0\n    println(\"Running Tarang on $size MPI processes\")\nend\n\n# Create simple 2D domain\ncoords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords, mesh=(2, 2))\n\nx = RealFourier(coords[\"x\"]; size=64, bounds=(0.0, 2π))\nz = ChebyshevT(coords[\"z\"]; size=32, bounds=(0.0, 1.0))\n\ndomain = Domain(dist, (x, z))\n\nif rank == 0\n    println(\"Successfully created domain!\")\nend\n\nMPI.Finalize()\n\nRun with MPI:\n\nmpiexec -n 4 julia test_tarang.jl","category":"section"},{"location":"getting_started/installation/#Troubleshooting","page":"Installation","title":"Troubleshooting","text":"","category":"section"},{"location":"getting_started/installation/#MPI-Issues","page":"Installation","title":"MPI Issues","text":"Problem: ERROR: MPI has not been built\n\nSolution: Build MPI.jl manually:\n\nusing Pkg\nPkg.build(\"MPI\")\n\nProblem: MPI version mismatch\n\nSolution: Rebuild MPI.jl against system MPI:\n\nENV[\"JULIA_MPI_BINARY\"] = \"system\"\nPkg.build(\"MPI\"; verbose=true)","category":"section"},{"location":"getting_started/installation/#Performance-Issues","page":"Installation","title":"Performance Issues","text":"Problem: Warning about OMP_NUM_THREADS\n\nSolution: Set the environment variable:\n\nexport OMP_NUM_THREADS=1\nmpiexec -n 4 julia your_script.jl","category":"section"},{"location":"getting_started/installation/#FFTW-Issues","page":"Installation","title":"FFTW Issues","text":"Problem: FFTW planning errors\n\nSolution: Use a different FFTW planning rigor in your configuration:\n\nENV[\"FFTW_PLANNING_RIGOR\"] = \"FFTW_ESTIMATE\"","category":"section"},{"location":"getting_started/installation/#HDF5-Issues","page":"Installation","title":"HDF5 Issues","text":"Problem: HDF5 library conflicts\n\nSolution: Rebuild HDF5.jl:\n\nusing Pkg\nPkg.build(\"HDF5\")","category":"section"},{"location":"getting_started/installation/#Next-Steps","page":"Installation","title":"Next Steps","text":"Now that Tarang.jl is installed, continue to:\n\nFirst Steps: Create your first simulation\nRunning with MPI: Learn about parallel execution\nTutorials: Detailed examples and guides","category":"section"},{"location":"getting_started/installation/#System-Specific-Notes","page":"Installation","title":"System-Specific Notes","text":"","category":"section"},{"location":"getting_started/installation/#macOS-Apple-Silicon-(M1/M2)","page":"Installation","title":"macOS Apple Silicon (M1/M2)","text":"Julia and all dependencies work natively on Apple Silicon. Use the ARM64 Julia build for best performance.","category":"section"},{"location":"getting_started/installation/#HPC-Clusters","page":"Installation","title":"HPC Clusters","text":"Most HPC systems have modules for MPI and HDF5. Load them before using Julia:\n\nmodule load julia/1.9\nmodule load openmpi/4.1\nmodule load hdf5/1.12\n\nConfigure MPI.jl to use the system MPI as shown above.","category":"section"},{"location":"getting_started/installation/#Containers","page":"Installation","title":"Containers","text":"Tarang.jl works well in containers. Example Dockerfile:\n\nFROM julia:1.9\n\nRUN apt-get update && apt-get install -y \\\n    openmpi-bin \\\n    libopenmpi-dev \\\n    libhdf5-dev \\\n    && rm -rf /var/lib/apt/lists/*\n\nRUN julia -e 'using Pkg; \\\n    Pkg.add(url=\"https://github.com/subhk/Tarang.jl\"); \\\n    Pkg.precompile()'\n\nWORKDIR /work","category":"section"},{"location":"examples/heat_transfer/#Heat-Transfer-Examples","page":"Heat Transfer Examples","title":"Heat Transfer Examples","text":"Collection of heat transfer simulations with Tarang.jl.","category":"section"},{"location":"examples/heat_transfer/#Pure-Diffusion","page":"Heat Transfer Examples","title":"Pure Diffusion","text":"","category":"section"},{"location":"examples/heat_transfer/#1D-Heat-Equation","page":"Heat Transfer Examples","title":"1D Heat Equation","text":"using Tarang, MPI\nMPI.Init()\n\ncoords = CartesianCoordinates(\"x\")\ndist = Distributor(coords; mesh=(1,), dtype=Float64)\nbasis = ChebyshevT(coords[\"x\"]; size=64, bounds=(0.0, 1.0))\n\nT = ScalarField(dist, \"T\", (basis,), Float64)\n\nproblem = IVP([T])\nproblem.parameters[\"kappa\"] = 0.01\n\nTarang.add_equation!(problem, \"∂t(T) = kappa*Δ(T)\")\nTarang.add_equation!(problem, \"T(x=0) = 1\")  # Hot\nTarang.add_equation!(problem, \"T(x=1) = 0\")  # Cold\n\nsolver = InitialValueSolver(problem, CNAB2(); dt=0.01)\n\n# Initial condition: step function\nTarang.ensure_layout!(T, :g)\nx = get_grid(basis)\nT.data_g .= x .< 0.5\n\n# Solve to steady state\nwhile solver.sim_time < 10.0\n    step!(solver)\nend\n# Steady state: linear profile\n\nMPI.Finalize()","category":"section"},{"location":"examples/heat_transfer/#2D-Diffusion","page":"Heat Transfer Examples","title":"2D Diffusion","text":"coords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords; mesh=(2, 2), dtype=Float64)\n\nx_basis = ChebyshevT(coords[\"x\"]; size=64, bounds=(0.0, 1.0))\nz_basis = ChebyshevT(coords[\"z\"]; size=64, bounds=(0.0, 1.0))\n\nT = ScalarField(dist, \"T\", (x_basis, z_basis), Float64)\n\nproblem = IVP([T])\nproblem.parameters[\"kappa\"] = 0.1\n\nTarang.add_equation!(problem, \"∂t(T) = kappa*Δ(T)\")\n\n# Dirichlet on all boundaries\nTarang.add_equation!(problem, \"T(x=0) = 0\")\nTarang.add_equation!(problem, \"T(x=1) = 0\")\nTarang.add_equation!(problem, \"T(z=0) = 1\")\nTarang.add_equation!(problem, \"T(z=1) = 0\")","category":"section"},{"location":"examples/heat_transfer/#Convection-Diffusion","page":"Heat Transfer Examples","title":"Convection-Diffusion","text":"","category":"section"},{"location":"examples/heat_transfer/#Advection-by-Known-Velocity","page":"Heat Transfer Examples","title":"Advection by Known Velocity","text":"# Given velocity field U (not solved)\nU = 1.0  # Constant advection velocity\n\nproblem = IVP([T])\nproblem.parameters[\"U\"] = U\nproblem.parameters[\"kappa\"] = 0.01\n\nTarang.add_equation!(problem, \"∂t(T) + U*∂x(T) = kappa*Δ(T)\")","category":"section"},{"location":"examples/heat_transfer/#Natural-Convection","page":"Heat Transfer Examples","title":"Natural Convection","text":"Buoyancy-driven flow with temperature coupling.\n\nproblem = IVP([ux, uz, p, T])\nproblem.parameters[\"Ra\"] = 1e5\nproblem.parameters[\"Pr\"] = 0.7\n\nTarang.add_equation!(problem, \"∂t(ux) + ... + ∂x(p) = Pr*Δ(ux)\")\nTarang.add_equation!(problem, \"∂t(uz) + ... + ∂z(p) = Pr*Δ(uz) + Ra*Pr*T\")\nTarang.add_equation!(problem, \"∂x(ux) + ∂z(uz) = 0\")\nTarang.add_equation!(problem, \"∂t(T) + ux*∂x(T) + uz*∂z(T) = Δ(T)\")","category":"section"},{"location":"examples/heat_transfer/#Boundary-Conditions","page":"Heat Transfer Examples","title":"Boundary Conditions","text":"","category":"section"},{"location":"examples/heat_transfer/#Convective-(Robin)-BC","page":"Heat Transfer Examples","title":"Convective (Robin) BC","text":"Heat transfer to environment.\n\n# h*T + k*∂T/∂n = h*T_ambient\nh = 10.0   # Heat transfer coefficient\nk = 1.0    # Thermal conductivity\nT_amb = 0.0\n\nTarang.add_equation!(problem, \"$(h)*T(z=1) + $(k)*∂z(T)(z=1) = $(h*T_amb)\")","category":"section"},{"location":"examples/heat_transfer/#Insulated-(Neumann)-BC","page":"Heat Transfer Examples","title":"Insulated (Neumann) BC","text":"Zero heat flux.\n\nTarang.add_equation!(problem, \"∂z(T)(z=1) = 0\")  # ∂T/∂z = 0","category":"section"},{"location":"examples/heat_transfer/#Time-Varying-BC","page":"Heat Transfer Examples","title":"Time-Varying BC","text":"# Oscillating temperature boundary\nfunction update_bc!(problem, t)\n    T_bc = sin(2π * t)\n    # Update boundary condition value\nend","category":"section"},{"location":"examples/heat_transfer/#Steady-State-Problems","page":"Heat Transfer Examples","title":"Steady-State Problems","text":"","category":"section"},{"location":"examples/heat_transfer/#Laplace-Equation","page":"Heat Transfer Examples","title":"Laplace Equation","text":"Steady heat conduction.\n\nproblem = LBVP([T])\nTarang.add_equation!(problem, \"Δ(T) = 0\")\n\n# Boundary conditions define the solution\nTarang.add_equation!(problem, \"T(x=0) = 0\")\nTarang.add_equation!(problem, \"T(x=1) = 1\")\nTarang.add_equation!(problem, \"∂z(T)(z=0) = 0\")\nTarang.add_equation!(problem, \"∂z(T)(z=1) = 0\")\n\nsolver = BoundaryValueSolver(problem)\nsolve!(solver)","category":"section"},{"location":"examples/heat_transfer/#Poisson-Equation","page":"Heat Transfer Examples","title":"Poisson Equation","text":"With heat source.\n\n# Heat source (e.g., volumetric heating)\nq = ScalarField(dist, \"q\", bases, Float64)\nTarang.ensure_layout!(q, :g)\n# Define heat source distribution\nq.data_g .= sin.(π .* x) .* sin.(π .* z)\n\nproblem = LBVP([T])\nproblem.fields[\"q\"] = q\nTarang.add_equation!(problem, \"Δ(T) = -q\")","category":"section"},{"location":"examples/heat_transfer/#Heat-Transfer-Analysis","page":"Heat Transfer Examples","title":"Heat Transfer Analysis","text":"","category":"section"},{"location":"examples/heat_transfer/#Nusselt-Number","page":"Heat Transfer Examples","title":"Nusselt Number","text":"function compute_nusselt(T, direction, H, kappa)\n    Tarang.ensure_layout!(T, :g)\n\n    # Heat flux at boundary\n    dT_dz = compute_gradient(T, direction)\n    q_wall = -kappa * mean(dT_dz[boundary])\n\n    # Conductive reference\n    Delta_T = 1.0  # Temperature difference\n    q_cond = kappa * Delta_T / H\n\n    return q_wall / q_cond\nend","category":"section"},{"location":"examples/heat_transfer/#Thermal-Boundary-Layer","page":"Heat Transfer Examples","title":"Thermal Boundary Layer","text":"function boundary_layer_thickness(T, z_grid, T_wall, T_bulk)\n    # Find z where T = 0.99 * (T_bulk - T_wall) + T_wall\n    profile = mean(T, dims=1)  # x-averaged\n    # ... interpolation to find δ_T\nend","category":"section"},{"location":"examples/heat_transfer/#Multi-Physics","page":"Heat Transfer Examples","title":"Multi-Physics","text":"","category":"section"},{"location":"examples/heat_transfer/#Conjugate-Heat-Transfer","page":"Heat Transfer Examples","title":"Conjugate Heat Transfer","text":"Heat transfer across solid-fluid interface.\n\n# Solid domain\nT_solid = ScalarField(dist_solid, \"T_s\", bases_solid, Float64)\n\n# Fluid domain\nT_fluid = ScalarField(dist_fluid, \"T_f\", bases_fluid, Float64)\n\n# Coupling at interface:\n# T_s = T_f (continuity)\n# k_s * ∂T_s/∂n = k_f * ∂T_f/∂n (flux balance)","category":"section"},{"location":"examples/heat_transfer/#Melting/Solidification","page":"Heat Transfer Examples","title":"Melting/Solidification","text":"Phase change with enthalpy method.\n\n# Enthalpy formulation\n# ∂H/∂t = ∇·(k∇T)\n# H = c_p * T + L * f_l (liquid fraction)","category":"section"},{"location":"examples/heat_transfer/#Tips","page":"Heat Transfer Examples","title":"Tips","text":"","category":"section"},{"location":"examples/heat_transfer/#Numerical-Stability","page":"Heat Transfer Examples","title":"Numerical Stability","text":"Diffusion is always stable with implicit methods\nAdvection-diffusion: use IMEX methods\nHigh Peclet number: may need upwinding or higher resolution","category":"section"},{"location":"examples/heat_transfer/#Convergence","page":"Heat Transfer Examples","title":"Convergence","text":"Exponential convergence for smooth solutions\nCheck spectral coefficient decay\nRefine near boundaries for boundary layers","category":"section"},{"location":"examples/heat_transfer/#See-Also","page":"Heat Transfer Examples","title":"See Also","text":"Rayleigh-Bénard Tutorial\nFluid Dynamics Examples\nExample Gallery","category":"section"},{"location":"tutorials/eigenvalue_problems/#Tutorial:-Eigenvalue-Problems","page":"Tutorial: Eigenvalue Problems","title":"Tutorial: Eigenvalue Problems","text":"This tutorial demonstrates solving eigenvalue problems (EVP) with Tarang.jl for linear stability analysis.","category":"section"},{"location":"tutorials/eigenvalue_problems/#Overview","page":"Tutorial: Eigenvalue Problems","title":"Overview","text":"Eigenvalue problems arise in linear stability analysis where we seek modes of the form:\n\nmathbfu(xzt) = hatmathbfu(z) e^i k x + sigma t\n\nwhere sigma is the eigenvalue (growth rate + frequency) and hatmathbfu is the eigenfunction.","category":"section"},{"location":"tutorials/eigenvalue_problems/#Basic-EVP-Setup","page":"Tutorial: Eigenvalue Problems","title":"Basic EVP Setup","text":"","category":"section"},{"location":"tutorials/eigenvalue_problems/#Problem-Definition","page":"Tutorial: Eigenvalue Problems","title":"Problem Definition","text":"using Tarang\nusing MPI\n\nMPI.Init()\n\n# Setup domain\ncoords = CartesianCoordinates(\"z\")\ndist = Distributor(coords; mesh=(1,), dtype=Float64)\nz_basis = ChebyshevT(coords[\"z\"]; size=64, bounds=(0.0, 1.0))\n\n# Create fields for eigenmodes\nu_hat = ScalarField(dist, \"u_hat\", (z_basis,), Float64)\n\n# Create eigenvalue problem\nevp = Tarang.EVP([u_hat]; eigenvalue=:sigma)","category":"section"},{"location":"tutorials/eigenvalue_problems/#Adding-Equations","page":"Tutorial: Eigenvalue Problems","title":"Adding Equations","text":"The EVP format is: A mathbfx = sigma B mathbfx\n\n# Example: diffusion eigenvalue problem\n# σu = d²u/dz² (eigenvalues of Laplacian)\nTarang.add_equation!(evp, \"sigma*u_hat = ∂z(∂z(u_hat))\")\n\n# Or equivalently\nTarang.add_equation!(evp, \"sigma*u_hat = Δ(u_hat)\")","category":"section"},{"location":"tutorials/eigenvalue_problems/#Boundary-Conditions","page":"Tutorial: Eigenvalue Problems","title":"Boundary Conditions","text":"# Dirichlet BCs: u = 0 at boundaries\nTarang.add_equation!(evp, \"u_hat(z=0) = 0\")\nTarang.add_equation!(evp, \"u_hat(z=1) = 0\")","category":"section"},{"location":"tutorials/eigenvalue_problems/#Solving","page":"Tutorial: Eigenvalue Problems","title":"Solving","text":"# Validate problem setup\n@assert Tarang.validate_problem(evp)\n\n# Create solver and solve\nsolver = Tarang.EigenvalueSolver(evp; nev=10, which=\"LR\")\neigenvalues, eigenvectors = Tarang.solve!(solver)\n\n# Print results\nfor (i, σ) in enumerate(eigenvalues)\n    println(\"Mode $i: σ = $(real(σ)) + $(imag(σ))im\")\nend","category":"section"},{"location":"tutorials/eigenvalue_problems/#Rayleigh-Bénard-Stability","page":"Tutorial: Eigenvalue Problems","title":"Rayleigh-Bénard Stability","text":"Classical linear stability problem for thermal convection.","category":"section"},{"location":"tutorials/eigenvalue_problems/#Governing-Equations","page":"Tutorial: Eigenvalue Problems","title":"Governing Equations","text":"Linearized Boussinesq equations for perturbations:\n\nbeginaligned\nsigma hatu = -i k hatp + textPr nabla^2 hatu \nsigma hatw = -D hatp + textPr nabla^2 hatw + textRa cdot textPr cdot hatT \ni k hatu + D hatw = 0 \nsigma hatT = -hatw + nabla^2 hatT\nendaligned\n\nwhere D = ddz and nabla^2 = D^2 - k^2.","category":"section"},{"location":"tutorials/eigenvalue_problems/#Implementation","page":"Tutorial: Eigenvalue Problems","title":"Implementation","text":"using Tarang\nusing MPI\n\nMPI.Init()\n\n# Parameters\nRa = 1708.0  # Critical Rayleigh number\nPr = 1.0     # Prandtl number\nk = 3.117    # Critical wavenumber\n\n# Domain\ncoords = CartesianCoordinates(\"z\")\ndist = Distributor(coords; mesh=(1,), dtype=Float64)\nz_basis = ChebyshevT(coords[\"z\"]; size=64, bounds=(0.0, 1.0))\n\n# Fields (complex amplitudes)\nu_hat = ScalarField(dist, \"u_hat\", (z_basis,), ComplexF64)\nw_hat = ScalarField(dist, \"w_hat\", (z_basis,), ComplexF64)\np_hat = ScalarField(dist, \"p_hat\", (z_basis,), ComplexF64)\nT_hat = ScalarField(dist, \"T_hat\", (z_basis,), ComplexF64)\n\n# EVP setup\nevp = Tarang.EVP([u_hat, w_hat, p_hat, T_hat]; eigenvalue=:sigma)\n\n# Add parameters\nevp.parameters[\"Ra\"] = Ra\nevp.parameters[\"Pr\"] = Pr\nevp.parameters[\"k\"] = k\nevp.parameters[\"k2\"] = k^2\n\n# Momentum equations (modified Laplacian: D² - k²)\nTarang.add_equation!(evp, \"sigma*u_hat + 1im*k*p_hat = Pr*(∂z(∂z(u_hat)) - k2*u_hat)\")\nTarang.add_equation!(evp, \"sigma*w_hat + ∂z(p_hat) = Pr*(∂z(∂z(w_hat)) - k2*w_hat) + Ra*Pr*T_hat\")\n\n# Continuity\nTarang.add_equation!(evp, \"1im*k*u_hat + ∂z(w_hat) = 0\")\n\n# Temperature\nTarang.add_equation!(evp, \"sigma*T_hat + w_hat = ∂z(∂z(T_hat)) - k2*T_hat\")\n\n# Boundary conditions (no-slip, fixed temperature)\nTarang.add_equation!(evp, \"u_hat(z=0) = 0\")\nTarang.add_equation!(evp, \"u_hat(z=1) = 0\")\nTarang.add_equation!(evp, \"w_hat(z=0) = 0\")\nTarang.add_equation!(evp, \"w_hat(z=1) = 0\")\nTarang.add_equation!(evp, \"T_hat(z=0) = 0\")\nTarang.add_equation!(evp, \"T_hat(z=1) = 0\")\n\n# Solve\nsolver = Tarang.EigenvalueSolver(evp; nev=10, which=\"LR\")\neigenvalues, eigenvectors = Tarang.solve!(solver)\n\n# Find critical mode\nmax_idx = argmax(real.(eigenvalues))\nsigma_crit = eigenvalues[max_idx]\n\nprintln(\"Critical eigenvalue: σ = $(sigma_crit)\")\nprintln(\"Growth rate: $(real(sigma_crit))\")\nprintln(\"Frequency: $(imag(sigma_crit))\")\n\nMPI.Finalize()","category":"section"},{"location":"tutorials/eigenvalue_problems/#Orr-Sommerfeld-Equation","page":"Tutorial: Eigenvalue Problems","title":"Orr-Sommerfeld Equation","text":"Stability of parallel shear flows.","category":"section"},{"location":"tutorials/eigenvalue_problems/#Equation","page":"Tutorial: Eigenvalue Problems","title":"Equation","text":"left (U - c)(D^2 - k^2) - U + fracitextRe cdot k(D^2 - k^2)^2 right hatpsi = 0\n\nwhere c = sigma  (ik) is the complex wave speed.","category":"section"},{"location":"tutorials/eigenvalue_problems/#Implementation-2","page":"Tutorial: Eigenvalue Problems","title":"Implementation","text":"# Channel flow with parabolic profile\nU(z) = 1.0 - (2z - 1)^2\nU_pp(z) = -8.0  # U''\n\n# Setup\nevp = Tarang.EVP([psi_hat]; eigenvalue=:c)\n\n# Add equation (expanded form)\nTarang.add_equation!(evp, \"\"\"\n    c*(∂z(∂z(psi_hat)) - k2*psi_hat) =\n    U*(∂z(∂z(psi_hat)) - k2*psi_hat) - U_pp*psi_hat +\n    (1im/(Re*k))*(∂z(∂z(∂z(∂z(psi_hat)))) - 2*k2*∂z(∂z(psi_hat)) + k4*psi_hat)\n\"\"\")\n\n# No-slip: ψ = ∂ψ/∂z = 0 at walls\nTarang.add_equation!(evp, \"psi_hat(z=0) = 0\")\nTarang.add_equation!(evp, \"psi_hat(z=1) = 0\")\nTarang.add_equation!(evp, \"∂z(psi_hat)(z=0) = 0\")\nTarang.add_equation!(evp, \"∂z(psi_hat)(z=1) = 0\")","category":"section"},{"location":"tutorials/eigenvalue_problems/#Parameter-Studies","page":"Tutorial: Eigenvalue Problems","title":"Parameter Studies","text":"","category":"section"},{"location":"tutorials/eigenvalue_problems/#Scanning-Rayleigh-Number","page":"Tutorial: Eigenvalue Problems","title":"Scanning Rayleigh Number","text":"Ra_values = 10 .^ range(3, 5, length=20)\ngrowth_rates = Float64[]\n\nfor Ra in Ra_values\n    evp.parameters[\"Ra\"] = Ra\n\n    solver = Tarang.EigenvalueSolver(evp; nev=5, which=\"LR\")\n    eigenvalues, _ = Tarang.solve!(solver)\n\n    push!(growth_rates, maximum(real.(eigenvalues)))\nend\n\n# Find critical Ra (where growth rate crosses zero)\nusing Interpolations\nitp = LinearInterpolation(growth_rates, Ra_values)\nRa_crit = itp(0.0)\nprintln(\"Critical Rayleigh number: $Ra_crit\")","category":"section"},{"location":"tutorials/eigenvalue_problems/#Scanning-Wavenumber","page":"Tutorial: Eigenvalue Problems","title":"Scanning Wavenumber","text":"k_values = range(1.0, 5.0, length=50)\ngrowth_rates = zeros(length(k_values))\n\nfor (i, k) in enumerate(k_values)\n    evp.parameters[\"k\"] = k\n    evp.parameters[\"k2\"] = k^2\n\n    solver = Tarang.EigenvalueSolver(evp; nev=3, which=\"LR\")\n    eigenvalues, _ = Tarang.solve!(solver)\n\n    growth_rates[i] = maximum(real.(eigenvalues))\nend\n\n# Find most unstable wavenumber\nmax_idx = argmax(growth_rates)\nk_max = k_values[max_idx]\nprintln(\"Most unstable wavenumber: $k_max\")","category":"section"},{"location":"tutorials/eigenvalue_problems/#Neutral-Curves","page":"Tutorial: Eigenvalue Problems","title":"Neutral Curves","text":"Computing the stability boundary in parameter space:\n\nfunction find_neutral_curve(Ra_range, k_range)\n    Ra_neutral = Float64[]\n    k_neutral = Float64[]\n\n    for k in k_range\n        evp.parameters[\"k\"] = k\n        evp.parameters[\"k2\"] = k^2\n\n        # Binary search for neutral Ra\n        Ra_lo, Ra_hi = Ra_range\n\n        while Ra_hi - Ra_lo > 1.0\n            Ra_mid = (Ra_lo + Ra_hi) / 2\n            evp.parameters[\"Ra\"] = Ra_mid\n\n            solver = Tarang.EigenvalueSolver(evp; nev=3, which=\"LR\")\n            eigenvalues, _ = Tarang.solve!(solver)\n            max_growth = maximum(real.(eigenvalues))\n\n            if max_growth > 0\n                Ra_hi = Ra_mid\n            else\n                Ra_lo = Ra_mid\n            end\n        end\n\n        push!(k_neutral, k)\n        push!(Ra_neutral, (Ra_lo + Ra_hi) / 2)\n    end\n\n    return k_neutral, Ra_neutral\nend","category":"section"},{"location":"tutorials/eigenvalue_problems/#Visualizing-Eigenmodes","page":"Tutorial: Eigenvalue Problems","title":"Visualizing Eigenmodes","text":"using Plots\n\nfunction plot_eigenmode(eigenvector, title=\"Eigenmode\")\n    z = get_grid(z_basis)\n\n    # Extract components\n    u_mode = real.(eigenvector[\"u_hat\"])\n    w_mode = real.(eigenvector[\"w_hat\"])\n    T_mode = real.(eigenvector[\"T_hat\"])\n\n    # Normalize\n    max_val = maximum(abs.([u_mode; w_mode; T_mode]))\n    u_mode ./= max_val\n    w_mode ./= max_val\n    T_mode ./= max_val\n\n    # Plot\n    p = plot(layout=(1,3), size=(900,300))\n    plot!(p[1], u_mode, z, xlabel=\"û\", ylabel=\"z\", title=\"Velocity\")\n    plot!(p[2], w_mode, z, xlabel=\"ŵ\", title=\"Vertical velocity\")\n    plot!(p[3], T_mode, z, xlabel=\"T̂\", title=\"Temperature\")\n\n    return p\nend\n\n# Plot critical mode\nplot_eigenmode(eigenvectors[max_idx], \"Critical Mode\")\nsavefig(\"critical_mode.png\")","category":"section"},{"location":"tutorials/eigenvalue_problems/#Solver-Options","page":"Tutorial: Eigenvalue Problems","title":"Solver Options","text":"","category":"section"},{"location":"tutorials/eigenvalue_problems/#Which-Eigenvalues","page":"Tutorial: Eigenvalue Problems","title":"Which Eigenvalues","text":"# Largest magnitude (default for Arnoldi)\nsolver = Tarang.EigenvalueSolver(evp; nev=10, which=\"LM\")\n\n# Largest real part (most unstable)\nsolver = Tarang.EigenvalueSolver(evp; nev=10, which=\"LR\")\n\n# Smallest magnitude\nsolver = Tarang.EigenvalueSolver(evp; nev=10, which=\"SM\")\n\n# Near a target value (shift-invert)\nsolver = Tarang.EigenvalueSolver(evp; nev=10, target=0.1+1.5im)","category":"section"},{"location":"tutorials/eigenvalue_problems/#Convergence","page":"Tutorial: Eigenvalue Problems","title":"Convergence","text":"# Increase iterations for difficult problems\nsolver = Tarang.EigenvalueSolver(evp;\n    nev=20,\n    which=\"LR\",\n    tolerance=1e-10,\n    max_iterations=1000\n)","category":"section"},{"location":"tutorials/eigenvalue_problems/#See-Also","page":"Tutorial: Eigenvalue Problems","title":"See Also","text":"Problems API: EVP problem definition\nSolvers API: Eigenvalue solver details\nRayleigh-Bénard Tutorial: Time-dependent version","category":"section"},{"location":"api/io/#I/O-API","page":"I/O API","title":"I/O API","text":"File input/output for simulation data.","category":"section"},{"location":"api/io/#NetCDF-Output","page":"I/O API","title":"NetCDF Output","text":"","category":"section"},{"location":"api/io/#NetCDFFileHandler","page":"I/O API","title":"NetCDFFileHandler","text":"","category":"section"},{"location":"api/io/#add*netcdf*handler","page":"I/O API","title":"addnetcdfhandler","text":"Create a file handler for NetCDF output.\n\n","category":"section"},{"location":"api/io/#add*file*handler","page":"I/O API","title":"addfilehandler","text":"Alternative constructor for file handlers.\n\nhandler = add_netcdf_handler(\n    base_path,          # Output path/name\n    dist,               # Distributor\n    fields_dict;        # Dict of fields\n    parallel=\"gather\",  # I/O mode\n    max_writes=100      # Files before rollover\n)\n\nArguments:\n\nbase_path: Base path for output files\ndist: MPI distributor\nfields_dict: Dictionary mapping names to fields\nparallel: \"gather\" (single file) or \"virtual\" (per-process)\nmax_writes: Maximum writes per file before creating new file\n\nReturns: NetCDFFileHandler\n\n","category":"section"},{"location":"api/io/#add_task!","page":"I/O API","title":"add_task!","text":"Add a field output task.\n\n","category":"section"},{"location":"api/io/#add_task","page":"I/O API","title":"add_task","text":"Add a field output task (alternative syntax).\n\nadd_task!(handler, field; name=\"field_name\")\n\nWith postprocessing:\n\nadd_task!(handler, field;\n    name=\"processed\",\n    postprocess=data -> mean(data, dims=1)\n)\n\n","category":"section"},{"location":"api/io/#add*profile*task!","page":"I/O API","title":"addprofiletask!","text":"Add a task that computes mean profile over specified dimensions.\n\n# Mean over x (dimension 1) - produces z-profile\nadd_profile_task!(handler, field; dims=1, name=\"field_profile\")\n\n# Mean over x and y\nadd_profile_task!(handler, field; dims=(1,2), name=\"field_profile_xy\")\n\n","category":"section"},{"location":"api/io/#add*mean*task!","page":"I/O API","title":"addmeantask!","text":"Add a task that computes mean values.\n\nadd_mean_task!(handler, field; name=\"field_mean\")\n\n","category":"section"},{"location":"api/io/#add*slice*task!","page":"I/O API","title":"addslicetask!","text":"Add a task that extracts a slice.\n\n# Slice at index\nadd_slice_task!(handler, field; dim=1, idx=64, name=\"field_slice\")\n\n# Using slices dictionary\nadd_slice_task!(handler, field; slices=Dict(1 => 32), name=\"slice\")\n\n","category":"section"},{"location":"api/io/#add*rms*task!","page":"I/O API","title":"addrmstask!","text":"Add a task that computes RMS (root-mean-square) values.\n\nadd_rms_task!(handler, field; name=\"field_rms\")\n\n","category":"section"},{"location":"api/io/#add*variance*task!","page":"I/O API","title":"addvariancetask!","text":"Add a task that computes variance.\n\nadd_variance_task!(handler, field; name=\"field_variance\")\n\n","category":"section"},{"location":"api/io/#add*extrema*task!","page":"I/O API","title":"addextrematask!","text":"Add a task that tracks minimum and maximum values.\n\nadd_extrema_task!(handler, field; name=\"field_extrema\")\n\n","category":"section"},{"location":"api/io/#process!","page":"I/O API","title":"process!","text":"Write pending data to file.\n\nprocess!(handler;\n    iteration=solver.iteration,\n    wall_time=elapsed,\n    sim_time=solver.sim_time,\n    timestep=dt\n)\n\n","category":"section"},{"location":"api/io/#Handler-Management","page":"I/O API","title":"Handler Management","text":"","category":"section"},{"location":"api/io/#check_schedule","page":"I/O API","title":"check_schedule","text":"Check if the handler should write based on schedule.\n\n","category":"section"},{"location":"api/io/#create*current*file!","page":"I/O API","title":"createcurrentfile!","text":"Create a new output file.\n\n","category":"section"},{"location":"api/io/#current_path","page":"I/O API","title":"current_path","text":"Get the current output file path.\n\nfilepath = current_path(handler)\n\n","category":"section"},{"location":"api/io/#current_file","page":"I/O API","title":"current_file","text":"Get the current output file (alternative to current_path).\n\nfilepath = current_file(handler)\n\n","category":"section"},{"location":"api/io/#get*output*files","page":"I/O API","title":"getoutputfiles","text":"Get list of all output files created by handler.\n\n","category":"section"},{"location":"api/io/#get*handler*info","page":"I/O API","title":"gethandlerinfo","text":"Get information about the handler state.\n\n","category":"section"},{"location":"api/io/#close!","page":"I/O API","title":"close!","text":"Close the handler and finalize output.\n\nclose!(handler)\n\n","category":"section"},{"location":"api/io/#reset!","page":"I/O API","title":"reset!","text":"Reset the handler state.\n\n","category":"section"},{"location":"api/io/#File-Merging","page":"I/O API","title":"File Merging","text":"","category":"section"},{"location":"api/io/#NetCDFMerger","page":"I/O API","title":"NetCDFMerger","text":"","category":"section"},{"location":"api/io/#merge*netcdf*files","page":"I/O API","title":"mergenetcdffiles","text":"Merge multiple NetCDF files from parallel output.\n\nmerge_netcdf_files(base_path; output_file=\"merged.nc\")\n\n","category":"section"},{"location":"api/io/#merge_files!","page":"I/O API","title":"merge_files!","text":"","category":"section"},{"location":"api/io/#batch*merge*netcdf","page":"I/O API","title":"batchmergenetcdf","text":"Merge multiple sets of parallel output files.\n\nbatch_merge_netcdf([\"output1\", \"output2\", \"output3\"])\n\n","category":"section"},{"location":"api/io/#find*mergeable*handlers","page":"I/O API","title":"findmergeablehandlers","text":"Find handlers that can be merged.\n\n","category":"section"},{"location":"api/io/#cleanup*source*files!","page":"I/O API","title":"cleanupsourcefiles!","text":"Remove source files after merging.\n\n","category":"section"},{"location":"api/io/#Equation-Parsing","page":"I/O API","title":"Equation Parsing","text":"Internal functions for parsing equation strings.","category":"section"},{"location":"api/io/#split_equation","page":"I/O API","title":"split_equation","text":"","category":"section"},{"location":"api/io/#split_call","page":"I/O API","title":"split_call","text":"","category":"section"},{"location":"api/io/#lambdify_functions","page":"I/O API","title":"lambdify_functions","text":"","category":"section"},{"location":"api/io/#Reading-NetCDF","page":"I/O API","title":"Reading NetCDF","text":"","category":"section"},{"location":"api/io/#Using-NetCDF.jl","page":"I/O API","title":"Using NetCDF.jl","text":"using NetCDF\n\n# Read variable\ndata = NetCDF.ncread(filename, \"temperature\")\n\n# Read attribute\nattr = NetCDF.ncgetatt(filename, \"NC_GLOBAL\", \"title\")\n\n# Read time array\ntimes = NetCDF.ncread(filename, \"t\")","category":"section"},{"location":"api/io/#File-Structure","page":"I/O API","title":"File Structure","text":"","category":"section"},{"location":"api/io/#NetCDF-Layout","page":"I/O API","title":"NetCDF Layout","text":"output_s1.nc\n├── Dimensions\n│   ├── x (128)\n│   ├── z (64)\n│   └── t (unlimited)\n├── Coordinates\n│   ├── x [128]\n│   ├── z [64]\n│   └── t [N_writes]\n├── Variables\n│   ├── temperature (t, x, z)\n│   ├── velocity_x (t, x, z)\n│   └── ...\n└── Attributes\n    ├── title\n    ├── handler_name\n    ├── software\n    └── tarang_version","category":"section"},{"location":"api/io/#Global-Attributes","page":"I/O API","title":"Global Attributes","text":"Written automatically:\n\nAttribute Description\ntitle \"Tarang.jl simulation output\"\nhandler_name Handler name from path\nsoftware \"Tarang\"\ntarang_version Package version","category":"section"},{"location":"api/io/#Checkpointing","page":"I/O API","title":"Checkpointing","text":"","category":"section"},{"location":"api/io/#Saving-State","page":"I/O API","title":"Saving State","text":"function save_checkpoint(solver, filename)\n    using JLD2\n\n    state = Dict(\n        \"sim_time\" => solver.sim_time,\n        \"iteration\" => solver.iteration,\n        \"dt\" => solver.dt,\n        \"fields\" => Dict()\n    )\n\n    for (name, field) in solver.problem.fields\n        Tarang.ensure_layout!(field, :c)\n        state[\"fields\"][name] = copy(field.data_c)\n    end\n\n    if MPI.Comm_rank(MPI.COMM_WORLD) == 0\n        @save filename state\n    end\nend","category":"section"},{"location":"api/io/#Loading-State","page":"I/O API","title":"Loading State","text":"function load_checkpoint!(solver, filename)\n    using JLD2\n    @load filename state\n\n    solver.sim_time = state[\"sim_time\"]\n    solver.iteration = state[\"iteration\"]\n    solver.dt = state[\"dt\"]\n\n    for (name, data) in state[\"fields\"]\n        field = solver.problem.fields[name]\n        field.data_c .= data\n        field.current_layout = :c\n    end\nend","category":"section"},{"location":"api/io/#Parallel-I/O-Modes","page":"I/O API","title":"Parallel I/O Modes","text":"","category":"section"},{"location":"api/io/#Gather-Mode","page":"I/O API","title":"Gather Mode","text":"handler = add_netcdf_handler(path, dist, fields; parallel=\"gather\")\n\nAll data gathered to rank 0\nSingle output file\nMemory limited by rank 0","category":"section"},{"location":"api/io/#Virtual-Mode","page":"I/O API","title":"Virtual Mode","text":"handler = add_netcdf_handler(path, dist, fields; parallel=\"virtual\")\n\nEach process writes own file\nFilenames: output_p0.nc, output_p1.nc, etc.\nRequires post-processing to merge","category":"section"},{"location":"api/io/#File-Management","page":"I/O API","title":"File Management","text":"","category":"section"},{"location":"api/io/#File-Naming","page":"I/O API","title":"File Naming","text":"Files are numbered sequentially:\n\noutput_s1.nc   # First file\noutput_s2.nc   # After max_writes reached\noutput_s3.nc   # etc.","category":"section"},{"location":"api/io/#Merging-Files","page":"I/O API","title":"Merging Files","text":"For post-processing virtual files:\n\n# Merge all parallel files\nmerge_netcdf_files(\"output\"; output_file=\"output_merged.nc\", cleanup=true)\n\n# Batch merge multiple handlers\nbatch_merge_netcdf([\"snapshots\", \"analysis\", \"checkpoints\"])","category":"section"},{"location":"api/io/#Performance-Tips","page":"I/O API","title":"Performance Tips","text":"Batch writes: Don't write every iteration\nUse gather for small outputs: Simpler file handling\nUse virtual for large outputs: Better scaling\nCompress if needed: NetCDF supports compression","category":"section"},{"location":"api/io/#See-Also","page":"I/O API","title":"See Also","text":"Analysis Tutorial: Complete examples\nParallelism: MPI considerations","category":"section"},{"location":"api/io/#Tarang.NetCDFFileHandler","page":"I/O API","title":"Tarang.NetCDFFileHandler","text":"NetCDF File Handler matching Tarang H5FileHandler structure\n\nFollows Tarang pattern:\n\nbasepath/handlernames1/handlernames1p0.nc for processor files\nbasepath/handlername_s1.nc for gathered files\n/scales/ group with time coordinates\n/tasks/ group with field data\n\n\n\n\n\n","category":"type"},{"location":"api/io/#Tarang.add_netcdf_handler","page":"I/O API","title":"Tarang.add_netcdf_handler","text":"Convenience function to create NetCDF file handler (matching Tarang API) Usage: handler = addfilehandler(\"snapshots\", dist, vars, simdt=0.25, maxwrites=50)\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.add_file_handler","page":"I/O API","title":"Tarang.add_file_handler","text":"Tarang-style helper to create a NetCDF file handler. Matches evaluator.addfilehandler(...) usage in Tarang.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.add_task!","page":"I/O API","title":"Tarang.add_task!","text":"Add task to handler (matching Tarang API)\n\nExample usage (matching Tarang style):\n\nsnapshots = evaluator.addfilehandler('snapshots', simdt=0.25, maxwrites=50) snapshots.addtask(b, name='buoyancy') snapshots.addtask(-d3.div(d3.skew(u)), name='vorticity')\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.add_task","page":"I/O API","title":"Tarang.add_task","text":"Alias without bang for Tarang-style task addition.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.add_profile_task!","page":"I/O API","title":"Tarang.add_profile_task!","text":"Add a task that computes a 1D profile (mean over all but one dimension).\n\nArguments\n\nhandler: NetCDFFileHandler instance\nfield: Field to compute profile of\ndim: The dimension to keep (profile along this dimension)\nname: Optional name for the output variable\n\nExample\n\nadd_profile_task!(handler, u, dim=:z, name=\"u_profile_z\")\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.add_mean_task!","page":"I/O API","title":"Tarang.add_mean_task!","text":"Add a task that computes the mean over specified dimensions.\n\nArguments\n\nhandler: NetCDFFileHandler instance\nfield: Field to compute mean of\ndims: Dimensions to average over (e.g., (:x, :y) or (1, 2))\nname: Optional name for the output variable\n\nExample\n\nadd_mean_task!(handler, u, dims=(:x, :y), name=\"u_mean_z\")\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.add_slice_task!","page":"I/O API","title":"Tarang.add_slice_task!","text":"Add a task that extracts a slice of a field.\n\nArguments\n\nhandler: NetCDFFileHandler instance\nfield: Field to slice\nslices: Dictionary or named tuple specifying slice positions         e.g., Dict(:z => 0.5) or (z=0.5,) for midplane slice\nname: Optional name for the output variable\n\nExample\n\nadd_slice_task!(handler, u, slices=Dict(:z => 0.0), name=\"u_bottom\")\nadd_slice_task!(handler, T, slices=(x=0.5, y=0.5), name=\"T_centerline\")\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.add_rms_task!","page":"I/O API","title":"Tarang.add_rms_task!","text":"Add a task that computes the RMS (root mean square) over specified dimensions.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.add_variance_task!","page":"I/O API","title":"Tarang.add_variance_task!","text":"Add a task that computes the variance over specified dimensions.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.add_extrema_task!","page":"I/O API","title":"Tarang.add_extrema_task!","text":"Add a task that computes min/max over the domain.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.process!","page":"I/O API","title":"Tarang.process!","text":"Process handler: write all tasks to NetCDF (matching Tarang process method)\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.check_schedule","page":"I/O API","title":"Tarang.check_schedule","text":"Check if handler should process based on schedule (matching Tarang logic)\n\nAlways writes initial conditions (iteration=0) when any scheduling mode is configured. For subsequent iterations, uses the configured cadence.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.create_current_file!","page":"I/O API","title":"Tarang.create_current_file!","text":"Create NetCDF file with Tarang-style structure\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.current_path","page":"I/O API","title":"Tarang.current_path","text":"Get current set path following Tarang naming: handlernames1/\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.current_file","page":"I/O API","title":"Tarang.current_file","text":"Get current file path following Tarang naming: handlernames1/handlernames1_p0.nc\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.get_output_files","page":"I/O API","title":"Tarang.get_output_files","text":"Get list of all output files created by this handler.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.get_handler_info","page":"I/O API","title":"Tarang.get_handler_info","text":"Get metadata about the handler's output.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.close!","page":"I/O API","title":"Tarang.close!","text":"Close handler and finalize all files.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.reset!","page":"I/O API","title":"Tarang.reset!","text":"Reset handler for a new simulation run.\n\n\n\n\n\nreset!(filter::ExponentialMean)\n\nReset the filter state to zero.\n\n\n\n\n\nreset!(filter::ButterworthFilter)\n\nReset the filter state to zero.\n\n\n\n\n\nreset!(filter::LagrangianFilter)\n\nReset the Lagrangian filter state.\n\n\n\n\n\nreset!(model::EddyViscosityModel)\n\nReset the eddy viscosity field to zero. GPU-aware: fill!() works for both CPU and GPU arrays.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.NetCDFMerger","page":"I/O API","title":"Tarang.NetCDFMerger","text":"NetCDF File Merger - handles merging of per-processor files\n\n\n\n\n\n","category":"type"},{"location":"api/io/#Tarang.merge_netcdf_files","page":"I/O API","title":"Tarang.merge_netcdf_files","text":"merge_netcdf_files(base_name; kwargs...)\n\nMerge per-processor NetCDF files into a single merged file.\n\nArguments\n\nbase_name::String: Base name of the handler (e.g., \"snapshots\", \"analysis\")\nset_number::Int=1: Set number to merge (default: 1)\noutput_name::String=\"\": Output filename (default: auto-generated)\nmerge_mode::MergeMode=RECONSTRUCT: How to combine processor data\ncleanup::Bool=false: Delete source files after successful merge\nverbose::Bool=true: Print progress information\n\nExamples\n\n# Basic merge\nmerge_netcdf_files(\"snapshots\")\n\n# Advanced options  \nmerge_netcdf_files(\"analysis\", \n                   set_number=2,\n                   output_name=\"analysis_complete.nc\", \n                   cleanup=true,\n                   merge_mode=SIMPLE_CONCAT)\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.merge_files!","page":"I/O API","title":"Tarang.merge_files!","text":"Main merge function - orchestrates the entire merging process\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.batch_merge_netcdf","page":"I/O API","title":"Tarang.batch_merge_netcdf","text":"batch_merge_netcdf(handlers; kwargs...)\n\nMerge multiple handlers in batch mode.\n\nExamples\n\n# Merge multiple handlers\nbatch_merge_netcdf([\"snapshots\", \"analysis\", \"checkpoints\"])\n\n# With cleanup\nbatch_merge_netcdf([\"snapshots\", \"analysis\"], cleanup=true)\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.find_mergeable_handlers","page":"I/O API","title":"Tarang.find_mergeable_handlers","text":"find_mergeable_handlers(directory=\".\")\n\nFind all handlers with processor files ready for merging.\n\nReturns a dictionary mapping handler names to available set numbers.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.cleanup_source_files!","page":"I/O API","title":"Tarang.cleanup_source_files!","text":"Clean up source processor files after successful merge\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.split_equation","page":"I/O API","title":"Tarang.split_equation","text":"split_equation(equation::AbstractString)\n\nSplit an equation string into left- and right-hand sides, tracking bracket depth so that keyword arguments (e.g. f(x=1)) and array indices do not trigger false splits.\n\nTracks parentheses (), square brackets [], and curly braces {}.\n\nThrows SymbolicParsingError if there is not exactly one top-level equals sign.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.split_call","page":"I/O API","title":"Tarang.split_call","text":"split_call(call::AbstractString)\n\nSplit a function-style string f(x y) into a head f and a tuple of argument names. Returns (call ()) if the string does not have call syntax.\n\nHandles nested parentheses correctly, e.g., f(g(x y) z) splits into (f (g(x y) z)).\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Tarang.lambdify_functions","page":"I/O API","title":"Tarang.lambdify_functions","text":"lambdify_functions(call::AbstractString, result::AbstractString)\n\nConvert a math-style definition f(x y)/x*y into a Julia anonymous function encoded as a string (xy) - x*y. Returns the original result for non-call statements to preserve standard semantics.\n\n\n\n\n\n","category":"function"},{"location":"pages/custom_operators/#Custom-Operators","page":"Custom Operators","title":"Custom Operators","text":"Creating custom differential and integral operators.","category":"section"},{"location":"pages/custom_operators/#Overview","page":"Custom Operators","title":"Overview","text":"Beyond built-in operators (grad, div, curl, lap), you can define custom operators for specialized physics.","category":"section"},{"location":"pages/custom_operators/#Helper-Functions","page":"Custom Operators","title":"Helper Functions","text":"","category":"section"},{"location":"pages/custom_operators/#Simple-Custom-Operators","page":"Custom Operators","title":"Simple Custom Operators","text":"# Advection operator: u·∇f\nfunction advection(u, f)\n    result = u.components[1].data .* ∂x(f).data\n    for i in 2:length(u.components)\n        result .+= u.components[i].data .* d_operators[i](f).data\n    end\n    return result\nend","category":"section"},{"location":"pages/custom_operators/#Using-in-Equations","page":"Custom Operators","title":"Using in Equations","text":"# Option 1: Expand manually\nTarang.add_equation!(problem, \"∂t(T) = -ux*∂x(T) - uz*∂z(T)\")\n\n# Option 2: Use helper in equation string\n# (requires registration)","category":"section"},{"location":"pages/custom_operators/#Using-Operators-in-Equations","page":"Custom Operators","title":"Using Operators in Equations","text":"The equation parser recognizes all built-in operators. Use them directly:\n\n# Built-in operators available in equations:\n# grad, div, curl, lap (or Δ), dt (or ∂t), d\n# integrate, average, interpolate, convert, lift\n# sin, cos, tan, exp, log, sqrt, abs, tanh\n\n# Use operators directly in equations\nTarang.add_equation!(problem, \"∂t(T) = -ux*∂x(T) - uz*∂z(T) + kappa*Δ(T)\")","category":"section"},{"location":"pages/custom_operators/#Spectral-Differentiation","page":"Custom Operators","title":"Spectral Differentiation","text":"","category":"section"},{"location":"pages/custom_operators/#Fourier-Derivative","page":"Custom Operators","title":"Fourier Derivative","text":"function fourier_derivative(field, basis, order=1)\n    k = get_wavenumbers(basis)\n    Tarang.ensure_layout!(field, :c)\n\n    # Multiply by (ik)^order\n    field.data_c .*= (1im .* k) .^ order\n\n    return field\nend","category":"section"},{"location":"pages/custom_operators/#Chebyshev-Derivative","page":"Custom Operators","title":"Chebyshev Derivative","text":"function chebyshev_derivative(field, basis)\n    Tarang.ensure_layout!(field, :c)\n\n    # Use differentiation matrix\n    D = chebyshev_diff_matrix(basis.size)\n    field.data_c = D * field.data_c\n\n    return field\nend","category":"section"},{"location":"pages/custom_operators/#Integral-Operators","page":"Custom Operators","title":"Integral Operators","text":"","category":"section"},{"location":"pages/custom_operators/#Spatial-Integration","page":"Custom Operators","title":"Spatial Integration","text":"function integrate(field, dim)\n    Tarang.ensure_layout!(field, :g)\n\n    if dim == 1  # x-direction\n        dx = field.bases[1].length / field.bases[1].size\n        return sum(field.data_g, dims=1) * dx\n    elseif dim == 2  # z-direction\n        # Chebyshev: use quadrature weights\n        weights = chebyshev_weights(field.bases[2])\n        return sum(field.data_g .* weights', dims=2)\n    end\nend","category":"section"},{"location":"pages/custom_operators/#Running-Average","page":"Custom Operators","title":"Running Average","text":"function running_average(field, window)\n    Tarang.ensure_layout!(field, :g)\n\n    # Convolution with box filter\n    # ...\nend","category":"section"},{"location":"pages/custom_operators/#Vector-Calculus","page":"Custom Operators","title":"Vector Calculus","text":"","category":"section"},{"location":"pages/custom_operators/#Strain-Rate-Tensor","page":"Custom Operators","title":"Strain Rate Tensor","text":"function strain_rate(u)\n    # S_ij = 1/2 (∂u_i/∂x_j + ∂u_j/∂x_i)\n    S = TensorField(u.dist, u.coords, \"S\", u.bases; symmetric=true)\n\n    ux, uz = u.components[1], u.components[2]\n\n    S[1,1] = ∂x(ux)\n    S[1,2] = 0.5 * (∂x(uz) + ∂z(ux))\n    S[2,2] = ∂z(uz)\n\n    return S\nend","category":"section"},{"location":"pages/custom_operators/#Vorticity-(2D)","page":"Custom Operators","title":"Vorticity (2D)","text":"function vorticity_2d(u)\n    ux, uz = u.components[1], u.components[2]\n    return ∂x(uz) - ∂z(ux)\nend","category":"section"},{"location":"pages/custom_operators/#Helicity-(3D)","page":"Custom Operators","title":"Helicity (3D)","text":"function helicity(u)\n    omega = ∇×(u)\n\n    # H = u · ω\n    H = u.components[1].data .* omega.components[1].data\n    for i in 2:3\n        H .+= u.components[i].data .* omega.components[i].data\n    end\n\n    return H\nend","category":"section"},{"location":"pages/custom_operators/#Nonlinear-Operators","page":"Custom Operators","title":"Nonlinear Operators","text":"","category":"section"},{"location":"pages/custom_operators/#Convective-Derivative","page":"Custom Operators","title":"Convective Derivative","text":"function convective_derivative(u, f)\n    # (u·∇)f\n    result = zeros(size(f.data_g))\n\n    for (i, comp) in enumerate(u.components)\n        Tarang.ensure_layout!(comp, :g)\n        df = d_operators[i](f)\n        Tarang.ensure_layout!(df, :g)\n        result .+= comp.data_g .* df.data_g\n    end\n\n    return result\nend","category":"section"},{"location":"pages/custom_operators/#Nonlinear-Term-(u·u)","page":"Custom Operators","title":"Nonlinear Term (u·∇u)","text":"function nonlinear_advection(u)\n    # Returns vector field\n    result = similar(u)\n\n    for (j, uj) in enumerate(u.components)\n        result.components[j].data_g .= convective_derivative(u, uj)\n    end\n\n    return result\nend","category":"section"},{"location":"pages/custom_operators/#Physics-Specific-Operators","page":"Custom Operators","title":"Physics-Specific Operators","text":"","category":"section"},{"location":"pages/custom_operators/#Coriolis-Force","page":"Custom Operators","title":"Coriolis Force","text":"function coriolis(u, Omega)\n    # 2Ω × u\n    # For rotation about z-axis:\n    fx = -2 * Omega * u.components[2]  # -2Ω*v\n    fy =  2 * Omega * u.components[1]  # +2Ω*u\n    fz = 0\n\n    return (fx, fy, fz)\nend","category":"section"},{"location":"pages/custom_operators/#Lorentz-Force-(MHD)","page":"Custom Operators","title":"Lorentz Force (MHD)","text":"function lorentz_force(J, B)\n    # J × B\n    return cross(J, B)  # or: J × B\nend","category":"section"},{"location":"pages/custom_operators/#Tips","page":"Custom Operators","title":"Tips","text":"","category":"section"},{"location":"pages/custom_operators/#Performance","page":"Custom Operators","title":"Performance","text":"Keep operations in same space (grid or spectral)\nMinimize transforms\nPre-compute constant factors","category":"section"},{"location":"pages/custom_operators/#Validation","page":"Custom Operators","title":"Validation","text":"Test against analytical solutions\nCheck symmetries\nVerify conservation properties","category":"section"},{"location":"pages/custom_operators/#See-Also","page":"Custom Operators","title":"See Also","text":"Operators: Built-in operators\nFields: Field types\nAPI: Operators: Reference","category":"section"},{"location":"examples/kernel_operation/#KernelOperation:-Portable-CPU/GPU-Kernels","page":"KernelOperation: Portable CPU/GPU Kernels","title":"KernelOperation: Portable CPU/GPU Kernels","text":"Use KernelOperation when you want a single KernelAbstractions kernel to run on both CPU and GPU backends through Tarang's architecture abstraction.\n\nusing Tarang, KernelAbstractions\n\n# Define a simple kernel (here: y .= α * x)\n@kernel function scale_kernel!(y, α, @Const(x))\n    i = @index(Global)\n    @inbounds y[i] = α * x[i]\nend\n\n# Wrap the kernel\nscale_op = KernelOperation(scale_kernel!) do y, α, x\n    length(y)  # default ndrange (can be tuple for multi-d arrays)\nend\n\n# Example data\narch = GPU()  # or CPU()\nx = ones(arch, Float64, 1024)\ny = zeros(arch, Float64, 1024)\n\n# Launch via the operation (auto-selects backend, workgroup, etc.)\nscale_op(arch, y, 2.0, x)\n\nKey benefits:\n\nBackend selection is driven by arch (a CPU()/GPU() or array).\nWorkgroup size and synchronization are handled via launch!.\nYou can pass ndrange/dependencies keywords to scale_op when needed.\n\n```","category":"section"},{"location":"notebooks/channel_flow/#Notebook:-Channel-Flow","page":"Notebook: Channel Flow","title":"Notebook: Channel Flow","text":"This notebook demonstrates pressure-driven channel flow simulation.","category":"section"},{"location":"notebooks/channel_flow/#Overview","page":"Notebook: Channel Flow","title":"Overview","text":"Channel flow (plane Poiseuille flow) is a fundamental benchmark for viscous flow simulations. Fluid flows between two parallel plates driven by a pressure gradient.","category":"section"},{"location":"notebooks/channel_flow/#Setup","page":"Notebook: Channel Flow","title":"Setup","text":"using Tarang\nusing MPI\nusing Plots\n\nMPI.Init()","category":"section"},{"location":"notebooks/channel_flow/#Parameters","page":"Notebook: Channel Flow","title":"Parameters","text":"Re = 1000.0     # Reynolds number\ndpdx = -1.0     # Pressure gradient (driving force)\nnu = 1.0 / Re   # Kinematic viscosity\nLx = 4π         # Domain length\nLz = 2.0        # Channel height","category":"section"},{"location":"notebooks/channel_flow/#Domain","page":"Notebook: Channel Flow","title":"Domain","text":"coords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords; mesh=(1,), dtype=Float64)\n\nNx, Nz = 128, 64\nx_basis = RealFourier(coords[\"x\"]; size=Nx, bounds=(0.0, Lx), dealias=1.5)\nz_basis = ChebyshevT(coords[\"z\"]; size=Nz, bounds=(0.0, Lz))\n\ndomain = Domain(dist, (x_basis, z_basis))","category":"section"},{"location":"notebooks/channel_flow/#Fields","page":"Notebook: Channel Flow","title":"Fields","text":"ux = ScalarField(dist, \"ux\", (x_basis, z_basis), Float64)\nuz = ScalarField(dist, \"uz\", (x_basis, z_basis), Float64)\np = ScalarField(dist, \"p\", (x_basis, z_basis), Float64)","category":"section"},{"location":"notebooks/channel_flow/#Problem-Definition","page":"Notebook: Channel Flow","title":"Problem Definition","text":"problem = IVP([ux, uz, p])\nproblem.parameters[\"nu\"] = nu\nproblem.parameters[\"dpdx\"] = dpdx\n\n# Momentum equations\nTarang.add_equation!(problem,\n    \"∂t(ux) + ux*∂x(ux) + uz*∂z(ux) + ∂x(p) = nu*Δ(ux) - dpdx\")\nTarang.add_equation!(problem,\n    \"∂t(uz) + ux*∂x(uz) + uz*∂z(uz) + ∂z(p) = nu*Δ(uz)\")\n\n# Continuity\nTarang.add_equation!(problem, \"∂x(ux) + ∂z(uz) = 0\")","category":"section"},{"location":"notebooks/channel_flow/#Boundary-Conditions","page":"Notebook: Channel Flow","title":"Boundary Conditions","text":"# No-slip at walls\nTarang.add_equation!(problem, \"ux(z=0) = 0\")    # Bottom\nTarang.add_equation!(problem, \"ux(z=$Lz) = 0\")  # Top\nTarang.add_equation!(problem, \"uz(z=0) = 0\")\nTarang.add_equation!(problem, \"uz(z=$Lz) = 0\")","category":"section"},{"location":"notebooks/channel_flow/#Analytical-Solution","page":"Notebook: Channel Flow","title":"Analytical Solution","text":"For laminar flow, the exact solution is parabolic:\n\n# Poiseuille profile\nfunction poiseuille_profile(z, H, dpdx, nu)\n    return -dpdx / (2*nu) * z * (H - z)\nend\n\n# Maximum velocity\nu_max = -dpdx * Lz^2 / (8*nu)\nprintln(\"Expected u_max = $u_max\")","category":"section"},{"location":"notebooks/channel_flow/#Initial-Conditions","page":"Notebook: Channel Flow","title":"Initial Conditions","text":"# Start from Poiseuille profile with perturbation\nz_grid = get_grid(z_basis)\nTarang.ensure_layout!(ux, :g)\n\nfor i in 1:Nx, j in 1:Nz\n    ux.data_g[i, j] = poiseuille_profile(z_grid[j], Lz, dpdx, nu)\nend\n\n# Add small perturbation\nux.data_g .+= 0.01 .* randn(size(ux.data_g))\nTarang.ensure_layout!(ux, :c)","category":"section"},{"location":"notebooks/channel_flow/#Solver","page":"Notebook: Channel Flow","title":"Solver","text":"solver = InitialValueSolver(problem, SBDF2(); dt=1e-3)\n\ncfl = CFL(problem; safety=0.4)\nadd_velocity!(cfl, ux)\nadd_velocity!(cfl, uz)","category":"section"},{"location":"notebooks/channel_flow/#Simulation","page":"Notebook: Channel Flow","title":"Simulation","text":"t_end = 10.0\n\nwhile solver.sim_time < t_end\n    dt = compute_timestep(cfl)\n    step!(solver, dt)\n\n    if solver.iteration % 100 == 0\n        Tarang.ensure_layout!(ux, :g)\n        u_centerline = mean(ux.data_g[:, Nz÷2])\n        println(\"t = $(solver.sim_time), u_center = $u_centerline\")\n    end\nend","category":"section"},{"location":"notebooks/channel_flow/#Results","page":"Notebook: Channel Flow","title":"Results","text":"","category":"section"},{"location":"notebooks/channel_flow/#Velocity-Profile","page":"Notebook: Channel Flow","title":"Velocity Profile","text":"Tarang.ensure_layout!(ux, :g)\n\n# Average over x\nu_profile = mean(ux.data_g, dims=1)[:]\nz_points = get_grid(z_basis)\n\n# Analytical\nu_analytical = [poiseuille_profile(z, Lz, dpdx, nu) for z in z_points]\n\nplot(u_profile, z_points, label=\"Numerical\")\nplot!(u_analytical, z_points, label=\"Analytical\", linestyle=:dash)\nxlabel!(\"u\")\nylabel!(\"z\")\ntitle!(\"Velocity Profile\")","category":"section"},{"location":"notebooks/channel_flow/#Error-Analysis","page":"Notebook: Channel Flow","title":"Error Analysis","text":"error = maximum(abs.(u_profile .- u_analytical))\nprintln(\"Maximum error: $error\")","category":"section"},{"location":"notebooks/channel_flow/#Turbulent-Channel-(Higher-Re)","page":"Notebook: Channel Flow","title":"Turbulent Channel (Higher Re)","text":"For turbulent flow, increase Reynolds number:\n\nRe_turb = 5000\nnu_turb = 1.0 / Re_turb\n\n# Will need:\n# - Higher resolution (Nx=256, Nz=128)\n# - Longer integration time\n# - Statistical averaging","category":"section"},{"location":"notebooks/channel_flow/#Exercises","page":"Notebook: Channel Flow","title":"Exercises","text":"Vary Reynolds number: Compare Re = 100, 500, 1000\nConvergence study: How does error scale with Nz?\nAdd turbulence: Re = 5000 with statistics\nCouette flow: Moving top wall instead of pressure gradient","category":"section"},{"location":"notebooks/channel_flow/#Cleanup","page":"Notebook: Channel Flow","title":"Cleanup","text":"MPI.Finalize()","category":"section"},{"location":"notebooks/channel_flow/#References","page":"Notebook: Channel Flow","title":"References","text":"Pope, S.B. (2000). Turbulent Flows\nKim, J., Moin, P., Moser, R. (1987). Turbulence statistics in channel flow","category":"section"},{"location":"getting_started/running_with_mpi/#Running-with-MPI","page":"Running with MPI","title":"Running with MPI","text":"Tarang.jl is designed for efficient parallel computing using MPI (Message Passing Interface). This guide covers everything you need to know about running Tarang.jl simulations in parallel.","category":"section"},{"location":"getting_started/running_with_mpi/#Basic-MPI-Execution","page":"Running with MPI","title":"Basic MPI Execution","text":"","category":"section"},{"location":"getting_started/running_with_mpi/#Running-a-Script","page":"Running with MPI","title":"Running a Script","text":"Execute a Tarang.jl script with MPI using mpiexec:\n\nmpiexec -n 4 julia your_script.jl\n\nThe -n 4 flag specifies 4 MPI processes. This must match your process mesh configuration in the script.","category":"section"},{"location":"getting_started/running_with_mpi/#Process-Mesh-Configuration","page":"Running with MPI","title":"Process Mesh Configuration","text":"The process mesh determines how MPI processes are arranged:\n\n# 2D process mesh (4 processes: 2×2)\ndist = Distributor(coords, mesh=(2, 2))\n\n# 1D process mesh (4 processes: 4×1)\ndist = Distributor(coords, mesh=(4, 1))\n\n# 3D process mesh (8 processes: 2×2×2)\ndist = Distributor(coords, mesh=(2, 2, 2))\n\ntip: Matching Process Count\nEnsure product(mesh) == number of MPI processes:mesh=(2, 2)  # requires: mpiexec -n 4\nmesh=(4, 2)  # requires: mpiexec -n 8\nmesh=(4, 4)  # requires: mpiexec -n 16","category":"section"},{"location":"getting_started/running_with_mpi/#Process-Mesh-Strategies","page":"Running with MPI","title":"Process Mesh Strategies","text":"","category":"section"},{"location":"getting_started/running_with_mpi/#2D-Problems","page":"Running with MPI","title":"2D Problems","text":"For 2D problems, you can parallelize in both directions:\n\n# Balanced 2D decomposition (recommended)\nmesh=(4, 4)  # 16 processes, good for most 2D problems\n\n# Horizontal decomposition (for thin domains)\nmesh=(8, 2)  # 16 processes, more processes in x-direction\n\n# Vertical decomposition (for tall domains)\nmesh=(2, 8)  # 16 processes, more processes in z-direction\n\nRule of thumb: Match the mesh aspect ratio to your domain aspect ratio.","category":"section"},{"location":"getting_started/running_with_mpi/#3D-Problems","page":"Running with MPI","title":"3D Problems","text":"For 3D problems, Tarang.jl uses pencil decomposition:\n\n# Cubic mesh (for isotropic domains)\nmesh=(4, 4, 4)  # 64 processes\n\n# Anisotropic mesh (for stratified flows)\nmesh=(8, 8, 2)  # 128 processes, fewer in vertical direction\n\nPencil decomposition means data is distributed in two dimensions while remaining contiguous in the third. This enables efficient parallel FFTs.","category":"section"},{"location":"getting_started/running_with_mpi/#Environment-Variables","page":"Running with MPI","title":"Environment Variables","text":"","category":"section"},{"location":"getting_started/running_with_mpi/#Thread-Control","page":"Running with MPI","title":"Thread Control","text":"Set OpenMP thread count to avoid oversubscription:\n\nexport OMP_NUM_THREADS=1\nmpiexec -n 8 julia script.jl\n\nwarning: Performance Impact\nNot setting OMP_NUM_THREADS=1 can cause significant performance degradation. Tarang.jl will warn you if this is not set correctly.","category":"section"},{"location":"getting_started/running_with_mpi/#Julia-Threads","page":"Running with MPI","title":"Julia Threads","text":"Julia's multithreading can work alongside MPI:\n\nexport JULIA_NUM_THREADS=4\nexport OMP_NUM_THREADS=1\nmpiexec -n 4 julia script.jl\n\nThis gives you 4 MPI processes × 4 Julia threads = 16 parallel tasks.","category":"section"},{"location":"getting_started/running_with_mpi/#Other-Useful-Variables","page":"Running with MPI","title":"Other Useful Variables","text":"# FFTW optimization\nexport FFTW_PLANNING_RIGOR=FFTW_MEASURE\n\n# Tarang logging\nexport TARANG_LOG_LEVEL=DEBUG\n\n# MPI debugging\nexport OMPI_MCA_mpi_show_mca_params=1","category":"section"},{"location":"getting_started/running_with_mpi/#HPC-Cluster-Execution","page":"Running with MPI","title":"HPC Cluster Execution","text":"","category":"section"},{"location":"getting_started/running_with_mpi/#SLURM","page":"Running with MPI","title":"SLURM","text":"Example SLURM submission script:\n\n#!/bin/bash\n#SBATCH --job-name=tarang_sim\n#SBATCH --nodes=4\n#SBATCH --ntasks-per-node=32\n#SBATCH --time=24:00:00\n#SBATCH --partition=compute\n\n# Load modules\nmodule load julia/1.9\nmodule load openmpi/4.1\n\n# Set environment\nexport OMP_NUM_THREADS=1\nexport JULIA_NUM_THREADS=1\n\n# Calculate total tasks\nNTASKS=$((SLURM_NNODES * SLURM_NTASKS_PER_NODE))\n\n# Run simulation\nsrun -n $NTASKS julia --project=. simulation.jl\n\nSubmit with:\n\nsbatch submit_tarang.sh","category":"section"},{"location":"getting_started/running_with_mpi/#PBS/Torque","page":"Running with MPI","title":"PBS/Torque","text":"Example PBS script:\n\n#!/bin/bash\n#PBS -N tarang_sim\n#PBS -l nodes=4:ppn=32\n#PBS -l walltime=24:00:00\n#PBS -q batch\n\ncd $PBS_O_WORKDIR\n\nmodule load julia/1.9\nmodule load openmpi/4.1\n\nexport OMP_NUM_THREADS=1\n\nmpiexec julia --project=. simulation.jl\n\nSubmit with:\n\nqsub submit_tarang.pbs","category":"section"},{"location":"getting_started/running_with_mpi/#Load-Balancing","page":"Running with MPI","title":"Load Balancing","text":"","category":"section"},{"location":"getting_started/running_with_mpi/#Automatic-Load-Balancing","page":"Running with MPI","title":"Automatic Load Balancing","text":"Tarang.jl automatically distributes work across MPI processes using PencilArrays. For balanced performance:\n\nUse power-of-2 process counts when possible (4, 8, 16, 32, ...)\nMatch mesh to domain: Aspect ratio of mesh should match domain\nConsider memory: Each process needs enough RAM for its subdomain","category":"section"},{"location":"getting_started/running_with_mpi/#Checking-Load-Distribution","page":"Running with MPI","title":"Checking Load Distribution","text":"Add diagnostics to your script:\n\nrank = MPI.Comm_rank(MPI.COMM_WORLD)\nsize = MPI.Comm_size(MPI.COMM_WORLD)\n\nlocal_size = size(T.data)  # Size of local data on this rank\n\nprintln(\"Rank $rank: Local array size = $local_size\")","category":"section"},{"location":"getting_started/running_with_mpi/#Communication-Patterns","page":"Running with MPI","title":"Communication Patterns","text":"","category":"section"},{"location":"getting_started/running_with_mpi/#PencilArrays-Transposes","page":"Running with MPI","title":"PencilArrays Transposes","text":"Tarang.jl uses PencilArrays for efficient data distribution. Key operations:\n\nFFTs: May require transposes between different pencil orientations\nDerivatives: Computed in spectral space (minimal communication)\nNonlinear terms: Evaluated in grid space (may require transforms)","category":"section"},{"location":"getting_started/running_with_mpi/#Minimizing-Communication","page":"Running with MPI","title":"Minimizing Communication","text":"To reduce communication overhead:\n\nGroup operations: Batch multiple operations before synchronizing\nUse larger process counts: More processes = smaller messages\nOptimize process mesh: Align with dominant communication direction","category":"section"},{"location":"getting_started/running_with_mpi/#Performance-Monitoring","page":"Running with MPI","title":"Performance Monitoring","text":"","category":"section"},{"location":"getting_started/running_with_mpi/#MPI-Profiling","page":"Running with MPI","title":"MPI Profiling","text":"Use MPI profiling tools to identify bottlenecks:\n\n# With mpiP\nmpiexec -n 8 julia --project=. script.jl\n\n# With Intel MPI\nexport I_MPI_STATS=20\nmpiexec -n 8 julia script.jl","category":"section"},{"location":"getting_started/running_with_mpi/#Tarang.jl-Built-in-Profiling","page":"Running with MPI","title":"Tarang.jl Built-in Profiling","text":"Enable performance logging:\n\nusing Tarang\n\n# Setup logging with MPI awareness\nTarang.setup_tarang_logging(\n    level=\"INFO\",\n    filename=\"performance.log\",\n    mpi_aware=true,\n    console=true\n)","category":"section"},{"location":"getting_started/running_with_mpi/#Timing-Critical-Sections","page":"Running with MPI","title":"Timing Critical Sections","text":"Add timing to your simulation:\n\nusing Printf\n\nt_start = time()\n\n# ... simulation code ...\n\nt_end = time()\nelapsed = t_end - t_start\n\nif MPI.Comm_rank(MPI.COMM_WORLD) == 0\n    @printf \"Total time: %.2f seconds\\n\" elapsed\nend","category":"section"},{"location":"getting_started/running_with_mpi/#Debugging-MPI-Applications","page":"Running with MPI","title":"Debugging MPI Applications","text":"","category":"section"},{"location":"getting_started/running_with_mpi/#Running-in-Serial","page":"Running with MPI","title":"Running in Serial","text":"Test your code without MPI first:\n\njulia script.jl  # No mpiexec\n\nModify your script to use 1 process:\n\ndist = Distributor(coords, mesh=(1, 1))","category":"section"},{"location":"getting_started/running_with_mpi/#MPI-Debugging-Tools","page":"Running with MPI","title":"MPI Debugging Tools","text":"Use parallel debuggers:\n\n# With TotalView\nmpiexec -tv -n 4 julia script.jl\n\n# With DDT (ARM Forge)\nddt mpiexec -n 4 julia script.jl\n\n# With gdb (attach to rank 0)\nmpiexec -n 4 xterm -e gdb julia script.jl","category":"section"},{"location":"getting_started/running_with_mpi/#Rank-Specific-Output","page":"Running with MPI","title":"Rank-Specific Output","text":"Debug specific MPI ranks:\n\nrank = MPI.Comm_rank(MPI.COMM_WORLD)\n\nif rank == 0\n    println(\"Debug: Rank 0 data = \", data)\nend\n\n# Or debug all ranks\nprintln(\"Rank $rank: data = $data\")","category":"section"},{"location":"getting_started/running_with_mpi/#Common-Issues-and-Solutions","page":"Running with MPI","title":"Common Issues and Solutions","text":"","category":"section"},{"location":"getting_started/running_with_mpi/#Deadlocks","page":"Running with MPI","title":"Deadlocks","text":"Symptom: Program hangs without error\n\nCauses:\n\nMismatched collective operations\nRanks waiting for different communications\nIncorrect synchronization\n\nSolution: Ensure all ranks participate in collective operations:\n\n# All ranks must call collective operations\nMPI.Barrier(MPI.COMM_WORLD)  # All ranks must call this","category":"section"},{"location":"getting_started/running_with_mpi/#Load-Imbalance","page":"Running with MPI","title":"Load Imbalance","text":"Symptom: Some ranks finish much faster than others\n\nSolution: Check domain decomposition and adjust mesh:\n\n# Before (imbalanced for tall domain)\nmesh=(8, 2)\n\n# After (better for tall domain)\nmesh=(4, 4)","category":"section"},{"location":"getting_started/running_with_mpi/#Memory-Issues","page":"Running with MPI","title":"Memory Issues","text":"Symptom: Out of memory errors on some ranks\n\nSolution: Reduce resolution or increase process count:\n\n# Reduce resolution\nx_basis = RealFourier(coords[\"x\"], size=512, ...)  # was 1024\n\n# Or use more processes to distribute memory\nmesh=(8, 8)  # was (4, 4)","category":"section"},{"location":"getting_started/running_with_mpi/#Wrong-Number-of-Processes","page":"Running with MPI","title":"Wrong Number of Processes","text":"Symptom: ERROR: Process count mismatch\n\nSolution: Match mpiexec -n to mesh product:\n\nmesh=(4, 2)  # requires mpiexec -n 8","category":"section"},{"location":"getting_started/running_with_mpi/#Performance-Tips","page":"Running with MPI","title":"Performance Tips","text":"","category":"section"},{"location":"getting_started/running_with_mpi/#Optimal-Process-Count","page":"Running with MPI","title":"Optimal Process Count","text":"Start with square meshes: mesh=(4,4), (8,8), etc.\nProfile with different counts: Try 4, 8, 16, 32 processes\nCheck scaling: Plot speedup vs. process count\nConsider communication: More processes = more communication overhead","category":"section"},{"location":"getting_started/running_with_mpi/#Node-Level-Optimization","page":"Running with MPI","title":"Node-Level Optimization","text":"On multi-socket nodes:\n\n# Bind processes to cores\nmpiexec -n 16 --bind-to core julia script.jl\n\n# Use one process per socket\nmpiexec -n 2 --map-by socket julia script.jl","category":"section"},{"location":"getting_started/running_with_mpi/#Network-Optimization","page":"Running with MPI","title":"Network Optimization","text":"For InfiniBand or high-speed networks:\n\n# Enable UCX (if available)\nexport OMPI_MCA_pml=ucx\nexport OMPI_MCA_osc=ucx\n\nmpiexec -n 32 julia script.jl","category":"section"},{"location":"getting_started/running_with_mpi/#Benchmarking","page":"Running with MPI","title":"Benchmarking","text":"","category":"section"},{"location":"getting_started/running_with_mpi/#Weak-Scaling","page":"Running with MPI","title":"Weak Scaling","text":"Keep local problem size constant, increase total size:\n\n# 4 processes: 128×64 per process\nmesh=(2, 2); x_size=256; z_size=128\n\n# 16 processes: 128×64 per process\nmesh=(4, 4); x_size=512; z_size=256\n\n# 64 processes: 128×64 per process\nmesh=(8, 8); x_size=1024; z_size=512\n\nIdeal weak scaling: time remains constant.","category":"section"},{"location":"getting_started/running_with_mpi/#Strong-Scaling","page":"Running with MPI","title":"Strong Scaling","text":"Keep total problem size constant, increase processes:\n\n# All use: x_size=1024, z_size=512\nmesh=(2, 2)  # 4 processes\nmesh=(4, 4)  # 16 processes\nmesh=(8, 8)  # 64 processes\n\nIdeal strong scaling: time decreases linearly with processes.","category":"section"},{"location":"getting_started/running_with_mpi/#Next-Steps","page":"Running with MPI","title":"Next Steps","text":"First Steps: Basic Tarang.jl workflow\nTutorials: Example simulations with MPI\nConfiguration: Advanced MPI configuration options\nParallelism Guide: Deep dive into parallel algorithms","category":"section"},{"location":"pages/parallelism/#Parallelism","page":"Parallelism","title":"Parallelism","text":"Tarang.jl uses MPI for distributed-memory parallelism.","category":"section"},{"location":"pages/parallelism/#MPI-Basics","page":"Parallelism","title":"MPI Basics","text":"","category":"section"},{"location":"pages/parallelism/#Initialization","page":"Parallelism","title":"Initialization","text":"using MPI\nusing Tarang\n\n# Always initialize MPI first\nMPI.Init()\n\n# Get process info\nrank = MPI.Comm_rank(MPI.COMM_WORLD)\nsize = MPI.Comm_size(MPI.COMM_WORLD)\n\n# Your simulation code here\n# ...\n\n# Always finalize MPI\nMPI.Finalize()","category":"section"},{"location":"pages/parallelism/#Running-with-MPI","page":"Parallelism","title":"Running with MPI","text":"# Run with 4 processes\nmpiexec -n 4 julia --project simulation.jl\n\n# With thread control\nexport OMP_NUM_THREADS=1\nmpiexec -n 4 julia --project simulation.jl","category":"section"},{"location":"pages/parallelism/#Process-Mesh","page":"Parallelism","title":"Process Mesh","text":"The distributor organizes MPI processes into a mesh:\n\n# 2D domain with 4 processes\ncoords = CartesianCoordinates(\"x\", \"z\")\ndist = Distributor(coords; mesh=(2, 2))\n\n# 3D domain with 8 processes\ncoords = CartesianCoordinates(\"x\", \"y\", \"z\")\ndist = Distributor(coords; mesh=(2, 2, 2))","category":"section"},{"location":"pages/parallelism/#Mesh-Guidelines","page":"Parallelism","title":"Mesh Guidelines","text":"Processes 2D Mesh 3D Mesh\n4 (2, 2) -\n8 (4, 2) or (2, 4) (2, 2, 2)\n16 (4, 4) (4, 2, 2)\n64 (8, 8) (4, 4, 4)\n\nTips:\n\nMatch mesh to domain aspect ratio\nProduct of mesh = number of processes\nBalance communication vs. computation","category":"section"},{"location":"pages/parallelism/#Domain-Decomposition","page":"Parallelism","title":"Domain Decomposition","text":"","category":"section"},{"location":"pages/parallelism/#Pencil-Decomposition","page":"Parallelism","title":"Pencil Decomposition","text":"Tarang uses pencil (slab) decomposition for efficient parallel FFTs:\n\n2D domain decomposed across 4 processes:\n\nFull Domain:        Decomposed:\n┌─────────────┐     ┌──────┬──────┐\n│             │     │ P0   │ P1   │\n│             │     ├──────┼──────┤\n│             │     │ P2   │ P3   │\n└─────────────┘     └──────┴──────┘","category":"section"},{"location":"pages/parallelism/#Local-vs-Global","page":"Parallelism","title":"Local vs Global","text":"# Local data on this process\nlocal_data = field.data_g\nlocal_size = size(local_data)\n\n# Global size\nglobal_size = (basis1.size, basis2.size)\n\n# Local index range (internal function)\nstart_idx = Tarang.local_indices(dist, axis, global_size[axis])","category":"section"},{"location":"pages/parallelism/#Communication-Patterns","page":"Parallelism","title":"Communication Patterns","text":"","category":"section"},{"location":"pages/parallelism/#Automatic-Communication","page":"Parallelism","title":"Automatic Communication","text":"Communication happens automatically during:\n\nLayout transforms: Grid ↔ Spectral\nGlobal reductions: sum, max, min\nFile I/O: Gather to root or parallel write","category":"section"},{"location":"pages/parallelism/#Manual-Communication","page":"Parallelism","title":"Manual Communication","text":"# Global reduction using MPI directly\nlocal_max = maximum(field.data_g)\nglobal_max = MPI.Allreduce(local_max, MPI.MAX, MPI.COMM_WORLD)\n\n# Global sum\nlocal_sum = sum(field.data_g)\nglobal_sum = MPI.Allreduce(local_sum, MPI.SUM, MPI.COMM_WORLD)","category":"section"},{"location":"pages/parallelism/#Output-Strategies","page":"Parallelism","title":"Output Strategies","text":"","category":"section"},{"location":"pages/parallelism/#Gather-Mode","page":"Parallelism","title":"Gather Mode","text":"All data collected to rank 0 for writing:\n\nhandler = add_file_handler(path, dist, fields; parallel=\"gather\")\n\nPros: Simple, standard file format Cons: Memory limited by rank 0, serial I/O","category":"section"},{"location":"pages/parallelism/#Virtual-Mode","page":"Parallelism","title":"Virtual Mode","text":"Each process writes its own file:\n\nhandler = add_file_handler(path, dist, fields; parallel=\"virtual\")\n\nPros: Scalable, parallel I/O Cons: Post-processing needed to merge","category":"section"},{"location":"pages/parallelism/#Performance-Optimization","page":"Parallelism","title":"Performance Optimization","text":"","category":"section"},{"location":"pages/parallelism/#Load-Balance","page":"Parallelism","title":"Load Balance","text":"Ensure even distribution:\n\n# Good: Global size divisible by mesh\nN = 256  # 256 / 4 = 64 per process\nmesh = (4,)\n\n# Bad: Uneven distribution\nN = 250  # Processes get different amounts","category":"section"},{"location":"pages/parallelism/#Communication-Minimization","page":"Parallelism","title":"Communication Minimization","text":"# Minimize layout transforms\nTarang.ensure_layout!(field, :g)\n# Do all grid-space operations\n# Then transform once\nTarang.ensure_layout!(field, :c)","category":"section"},{"location":"pages/parallelism/#FFTW-Wisdom","page":"Parallelism","title":"FFTW Wisdom","text":"# Set FFTW planning\nENV[\"FFTW_PLANNING_RIGOR\"] = \"FFTW_PATIENT\"\n\n# Saves optimal FFT plans\n# Costs startup time, saves runtime","category":"section"},{"location":"pages/parallelism/#Troubleshooting","page":"Parallelism","title":"Troubleshooting","text":"","category":"section"},{"location":"pages/parallelism/#Common-Issues","page":"Parallelism","title":"Common Issues","text":"Deadlock: All processes must call MPI functions together\n\n# Bad - only rank 0 calls\nif rank == 0\n    MPI.Barrier(MPI.COMM_WORLD)\nend\n\n# Good - all ranks call\nMPI.Barrier(MPI.COMM_WORLD)\nif rank == 0\n    # Only rank 0 does work\nend\n\nMemory errors: Each process memory limited\n\n# Estimate memory per process\nmemory = total_points * bytes_per_point / num_processes","category":"section"},{"location":"pages/parallelism/#Debugging","page":"Parallelism","title":"Debugging","text":"# Print from specific rank\nif rank == 0\n    println(\"Debug info...\")\nend\n\n# Print from all ranks (with ordering)\nfor r in 0:size-1\n    if rank == r\n        println(\"Rank $r: ...\")\n    end\n    MPI.Barrier(MPI.COMM_WORLD)\nend","category":"section"},{"location":"pages/parallelism/#See-Also","page":"Parallelism","title":"See Also","text":"Coordinates: Distributor setup\nDomains: Domain decomposition\nRunning with MPI: Getting started","category":"section"},{"location":"tutorials/analysis_and_output/#Tutorial:-Analysis-and-Output","page":"Tutorial: Analysis and Output","title":"Tutorial: Analysis and Output","text":"This tutorial covers saving simulation data and computing diagnostics in Tarang.jl.","category":"section"},{"location":"tutorials/analysis_and_output/#File-Output","page":"Tutorial: Analysis and Output","title":"File Output","text":"Tarang.jl supports multiple output formats for saving simulation data.","category":"section"},{"location":"tutorials/analysis_and_output/#NetCDF-Output","page":"Tutorial: Analysis and Output","title":"NetCDF Output","text":"NetCDF is the recommended format for parallel simulations.\n\nusing Tarang\n\n# Create output handler\nhandler = add_file_handler(\n    \"simulation_output\",   # Base filename\n    dist,                  # Distributor\n    Dict(\"u\" => u, \"T\" => T);  # Fields to track\n    parallel=\"gather\",     # Parallel I/O mode\n    max_writes=100         # Files per handler\n)\n\n# Add field outputs\nadd_task(handler, u; name=\"velocity\")\nadd_task(handler, T; name=\"temperature\")\n\n# Process output at each timestep\nprocess!(handler;\n    iteration=solver.iteration,\n    wall_time=solver.wall_time,\n    sim_time=solver.sim_time,\n    timestep=solver.dt\n)","category":"section"},{"location":"tutorials/analysis_and_output/#Output-Modes","page":"Tutorial: Analysis and Output","title":"Output Modes","text":"# Gather mode: All data collected to root process\nhandler = add_file_handler(path, dist, fields; parallel=\"gather\")\n\n# Virtual mode: Each process writes its own file\nhandler = add_file_handler(path, dist, fields; parallel=\"virtual\")","category":"section"},{"location":"tutorials/analysis_and_output/#Output-Frequency","page":"Tutorial: Analysis and Output","title":"Output Frequency","text":"# Write every N iterations\nif solver.iteration % output_cadence == 0\n    process!(handler; iteration=solver.iteration, ...)\nend\n\n# Write at specific simulation times\nif solver.sim_time >= next_output_time\n    process!(handler; sim_time=solver.sim_time, ...)\n    next_output_time += output_interval\nend","category":"section"},{"location":"tutorials/analysis_and_output/#Analysis-Tasks","page":"Tutorial: Analysis and Output","title":"Analysis Tasks","text":"","category":"section"},{"location":"tutorials/analysis_and_output/#Computing-Means","page":"Tutorial: Analysis and Output","title":"Computing Means","text":"# Horizontal average\nadd_mean_task!(handler, T; dims=1, name=\"T_mean_x\")\n\n# Vertical average\nadd_mean_task!(handler, T; dims=2, name=\"T_mean_z\")\n\n# Full spatial average (scalar)\nadd_mean_task!(handler, T; dims=(1,2), name=\"T_avg\")","category":"section"},{"location":"tutorials/analysis_and_output/#Extracting-Slices","page":"Tutorial: Analysis and Output","title":"Extracting Slices","text":"# Slice at specific index\nadd_slice_task!(handler, T; dim=1, idx=64, name=\"T_slice_x\")\n\n# Multiple slices\nadd_slice_task!(handler, T; dim=2, idx=1, name=\"T_bottom\")\nadd_slice_task!(handler, T; dim=2, idx=Nz, name=\"T_top\")","category":"section"},{"location":"tutorials/analysis_and_output/#Custom-Analysis","page":"Tutorial: Analysis and Output","title":"Custom Analysis","text":"# Define custom postprocessing function\nfunction kinetic_energy(u_data)\n    return 0.5 * sum(u_data.^2)\nend\n\n# Add custom task\nadd_task(handler, u;\n    name=\"kinetic_energy\",\n    postprocess=kinetic_energy\n)","category":"section"},{"location":"tutorials/analysis_and_output/#Global-Diagnostics","page":"Tutorial: Analysis and Output","title":"Global Diagnostics","text":"","category":"section"},{"location":"tutorials/analysis_and_output/#CFL-Condition","page":"Tutorial: Analysis and Output","title":"CFL Condition","text":"using Tarang\n\n# Create CFL calculator\ncfl = CFL(problem; safety=0.5, max_change=1.5, min_change=0.5)\n\n# Register velocity field\nadd_velocity!(cfl, u)\n\n# Compute adaptive timestep\ndt = compute_timestep(cfl)","category":"section"},{"location":"tutorials/analysis_and_output/#Flow-Statistics","page":"Tutorial: Analysis and Output","title":"Flow Statistics","text":"using Tarang\n\n# Create global reducer for MPI operations\nreducer = GlobalArrayReducer(dist.comm)\n\n# Compute global max\nu_max = reduce_scalar(reducer, maximum(abs.(u.data_g)), MPI.MAX)\n\n# Compute global mean\nu_mean = reduce_scalar(reducer, mean(u.data_g), MPI.SUM) / dist.size\n\n# Compute global energy\nfunction global_energy(u, reducer)\n    local_energy = sum(u.data_g.^2) / 2\n    return reduce_scalar(reducer, local_energy, MPI.SUM)\nend","category":"section"},{"location":"tutorials/analysis_and_output/#Reynolds-Number","page":"Tutorial: Analysis and Output","title":"Reynolds Number","text":"function compute_reynolds_number(u, nu, L)\n    ensure_layout!(u, :g)\n\n    # RMS velocity\n    u_rms = sqrt(mean(u.data_g.^2))\n\n    # Reynolds number\n    Re = u_rms * L / nu\n\n    return Re\nend","category":"section"},{"location":"tutorials/analysis_and_output/#Nusselt-Number","page":"Tutorial: Analysis and Output","title":"Nusselt Number","text":"For thermal convection:\n\nfunction compute_nusselt(T, uz, L, kappa)\n    ensure_layout!(T, :g)\n    ensure_layout!(uz, :g)\n\n    # Convective heat flux\n    flux_conv = mean(T.data_g .* uz.data_g)\n\n    # Conductive flux (from temperature gradient)\n    dT = 1.0  # Temperature difference\n\n    # Nusselt = total flux / conductive flux\n    Nu = 1.0 + flux_conv * L / (kappa * dT)\n\n    return Nu\nend","category":"section"},{"location":"tutorials/analysis_and_output/#Energy-Spectra","page":"Tutorial: Analysis and Output","title":"Energy Spectra","text":"","category":"section"},{"location":"tutorials/analysis_and_output/#1D-Spectrum","page":"Tutorial: Analysis and Output","title":"1D Spectrum","text":"function compute_1d_spectrum(u, axis)\n    ensure_layout!(u, :c)  # Spectral space\n\n    data = u.data_c\n    N = size(data, axis)\n\n    # Sum over other dimensions\n    spectrum = zeros(N÷2)\n    for k in 1:N÷2\n        spectrum[k] = sum(abs2.(selectdim(data, axis, k)))\n    end\n\n    return spectrum\nend","category":"section"},{"location":"tutorials/analysis_and_output/#Shell-Averaged-Spectrum","page":"Tutorial: Analysis and Output","title":"Shell-Averaged Spectrum","text":"function compute_shell_spectrum(u, kmax)\n    ensure_layout!(u, :c)\n\n    # Initialize spectrum bins\n    E_k = zeros(kmax)\n    counts = zeros(Int, kmax)\n\n    # Get wavenumbers\n    kx = get_wavenumbers(u.bases[1])\n    ky = get_wavenumbers(u.bases[2])\n    kz = get_wavenumbers(u.bases[3])\n\n    # Bin energy by wavenumber magnitude\n    for i in eachindex(kx), j in eachindex(ky), k in eachindex(kz)\n        k_mag = sqrt(kx[i]^2 + ky[j]^2 + kz[k]^2)\n        k_bin = round(Int, k_mag)\n\n        if 1 <= k_bin <= kmax\n            E_k[k_bin] += abs2(u.data_c[i,j,k])\n            counts[k_bin] += 1\n        end\n    end\n\n    return E_k\nend","category":"section"},{"location":"tutorials/analysis_and_output/#Time-Series","page":"Tutorial: Analysis and Output","title":"Time Series","text":"","category":"section"},{"location":"tutorials/analysis_and_output/#Storing-Scalar-Time-Series","page":"Tutorial: Analysis and Output","title":"Storing Scalar Time Series","text":"# Initialize storage\ntimes = Float64[]\nenergies = Float64[]\nnusselts = Float64[]\n\n# During simulation\nwhile solver.sim_time < t_end\n    step!(solver, dt)\n\n    # Record diagnostics\n    push!(times, solver.sim_time)\n    push!(energies, compute_kinetic_energy(u))\n    push!(nusselts, compute_nusselt(T, uz, L, kappa))\nend\n\n# Save to file\nif rank == 0\n    using JLD2\n    @save \"diagnostics.jld2\" times energies nusselts\nend","category":"section"},{"location":"tutorials/analysis_and_output/#Visualization-Integration","page":"Tutorial: Analysis and Output","title":"Visualization Integration","text":"","category":"section"},{"location":"tutorials/analysis_and_output/#Plots.jl","page":"Tutorial: Analysis and Output","title":"Plots.jl","text":"using Plots\n\nfunction plot_field(field, title=\"\")\n    ensure_layout!(field, :g)\n    data = field.data_g\n\n    heatmap(data',\n        xlabel=\"x\", ylabel=\"z\",\n        title=title,\n        colorbar=true\n    )\nend\n\n# Save figure\nplot_field(T, \"Temperature\")\nsavefig(\"temperature.png\")","category":"section"},{"location":"tutorials/analysis_and_output/#Makie.jl","page":"Tutorial: Analysis and Output","title":"Makie.jl","text":"using CairoMakie\n\nfunction plot_field_makie(field)\n    ensure_layout!(field, :g)\n    data = field.data_g\n\n    fig = Figure()\n    ax = Axis(fig[1,1], xlabel=\"x\", ylabel=\"z\")\n    hm = heatmap!(ax, data')\n    Colorbar(fig[1,2], hm)\n\n    return fig\nend","category":"section"},{"location":"tutorials/analysis_and_output/#Checkpointing","page":"Tutorial: Analysis and Output","title":"Checkpointing","text":"","category":"section"},{"location":"tutorials/analysis_and_output/#Saving-State","page":"Tutorial: Analysis and Output","title":"Saving State","text":"function save_checkpoint(solver, filename)\n    state = Dict(\n        \"sim_time\" => solver.sim_time,\n        \"iteration\" => solver.iteration,\n        \"dt\" => solver.dt,\n        \"fields\" => Dict()\n    )\n\n    for (name, field) in solver.problem.fields\n        ensure_layout!(field, :c)\n        state[\"fields\"][name] = copy(field.data_c)\n    end\n\n    if MPI.Comm_rank(MPI.COMM_WORLD) == 0\n        using JLD2\n        @save filename state\n    end\nend","category":"section"},{"location":"tutorials/analysis_and_output/#Loading-State","page":"Tutorial: Analysis and Output","title":"Loading State","text":"function load_checkpoint!(solver, filename)\n    using JLD2\n    @load filename state\n\n    solver.sim_time = state[\"sim_time\"]\n    solver.iteration = state[\"iteration\"]\n    solver.dt = state[\"dt\"]\n\n    for (name, data) in state[\"fields\"]\n        field = solver.problem.fields[name]\n        field.data_c .= data\n        field.current_layout = :c\n    end\nend","category":"section"},{"location":"tutorials/analysis_and_output/#Complete-Example","page":"Tutorial: Analysis and Output","title":"Complete Example","text":"using Tarang\nusing MPI\nusing Printf\n\nMPI.Init()\nrank = MPI.Comm_rank(MPI.COMM_WORLD)\n\n# Setup (abbreviated)\n# ... create domain, fields, problem ...\n\n# Output handler\nhandler = add_file_handler(\"output\", dist, Dict(\"T\" => T);\n    parallel=\"gather\", max_writes=100)\nadd_task(handler, T; name=\"temperature\")\nadd_mean_task!(handler, T; dims=1, name=\"T_mean\")\n\n# Create solver\nsolver = InitialValueSolver(problem, RK222(), dt=1e-3)\n\n# CFL\ncfl = CFL(problem, safety=0.5)\nadd_velocity!(cfl, u)\n\n# Diagnostics storage\ntimes, energies = Float64[], Float64[]\n\n# Main loop\noutput_interval = 0.1\nnext_output = output_interval\n\nwhile solver.sim_time < 10.0\n    dt = compute_timestep(cfl)\n    step!(solver, dt)\n\n    # Store diagnostics\n    push!(times, solver.sim_time)\n    push!(energies, compute_kinetic_energy(u))\n\n    # Periodic output\n    if solver.sim_time >= next_output\n        process!(handler;\n            iteration=solver.iteration,\n            sim_time=solver.sim_time,\n            wall_time=0.0,\n            timestep=dt\n        )\n\n        if rank == 0\n            @printf(\"t = %.3f, E = %.6e\\n\", solver.sim_time, energies[end])\n        end\n\n        next_output += output_interval\n    end\nend\n\nMPI.Finalize()","category":"section"},{"location":"tutorials/analysis_and_output/#See-Also","page":"Tutorial: Analysis and Output","title":"See Also","text":"Analysis API: Full API reference\nI/O API: NetCDF output documentation\nParallelism: Parallel I/O configuration","category":"section"}]
}
