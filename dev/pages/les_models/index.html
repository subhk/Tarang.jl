<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>LES Models · Tarang.jl</title><meta name="title" content="LES Models · Tarang.jl"/><meta property="og:title" content="LES Models · Tarang.jl"/><meta property="twitter:title" content="LES Models · Tarang.jl"/><meta name="description" content="Documentation for Tarang.jl."/><meta property="og:description" content="Documentation for Tarang.jl."/><meta property="twitter:description" content="Documentation for Tarang.jl."/><meta property="og:url" content="https://subhk.github.io/Tarang.jl/stable/pages/les_models/"/><meta property="twitter:url" content="https://subhk.github.io/Tarang.jl/stable/pages/les_models/"/><link rel="canonical" href="https://subhk.github.io/Tarang.jl/stable/pages/les_models/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Tarang.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Tarang.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting_started/installation/">Installation</a></li><li><a class="tocitem" href="../../getting_started/first_steps/">First Steps</a></li><li><a class="tocitem" href="../../getting_started/running_with_mpi/">Running with MPI</a></li><li><a class="tocitem" href="../configuration/">Configuration</a></li></ul></li><li><span class="tocitem">Tutorials &amp; Examples</span><ul><li><a class="tocitem" href="../../tutorials/overview/">Overview</a></li><li><a class="tocitem" href="../../tutorials/ivp_2d_rbc/">2D Rayleigh-Benard</a></li><li><a class="tocitem" href="../../tutorials/ivp_3d_turbulence/">3D Turbulence</a></li><li><a class="tocitem" href="../../tutorials/boundary_conditions/">Boundary Conditions</a></li><li><a class="tocitem" href="../../tutorials/analysis_and_output/">Analysis &amp; Output</a></li><li><a class="tocitem" href="../../tutorials/eigenvalue_problems/">Eigenvalue Problems</a></li><li><a class="tocitem" href="../../tutorials/surface_dynamics/">Surface Dynamics</a></li><li><a class="tocitem" href="../../tutorials/rotating_shallow_water/">Rotating Shallow Water</a></li><li><a class="tocitem" href="../../examples/gallery/">Examples Gallery</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../coordinates/">Coordinates</a></li><li><a class="tocitem" href="../bases/">Bases</a></li><li><a class="tocitem" href="../domains/">Domains</a></li><li><a class="tocitem" href="../fields/">Fields</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../problems/">Problems</a></li><li><a class="tocitem" href="../solvers/">Solvers</a></li><li><a class="tocitem" href="../timesteppers/">Time Steppers</a></li><li><a class="tocitem" href="../gpu_computing/">GPU Computing</a></li><li><a class="tocitem" href="../parallelism/">Parallelism</a></li><li><a class="tocitem" href="../stochastic_forcing/">Stochastic Forcing</a></li><li class="is-active"><a class="tocitem" href>LES Models</a><ul class="internal"><li><a class="tocitem" href="#What-is-Large-Eddy-Simulation?"><span>What is Large Eddy Simulation?</span></a></li><li><a class="tocitem" href="#The-Closure-Problem"><span>The Closure Problem</span></a></li><li><a class="tocitem" href="#Energy-Cascade-and-Dissipation"><span>Energy Cascade and Dissipation</span></a></li><li><a class="tocitem" href="#Available-Models-in-Tarang.jl"><span>Available Models in Tarang.jl</span></a></li><li><a class="tocitem" href="#Smagorinsky-Model"><span>Smagorinsky Model</span></a></li><li><a class="tocitem" href="#Anisotropic-Minimum-Dissipation-(AMD)-Model"><span>Anisotropic Minimum Dissipation (AMD) Model</span></a></li><li><a class="tocitem" href="#Choosing-Between-Models"><span>Choosing Between Models</span></a></li><li><a class="tocitem" href="#Complete-Example:-LES-of-Decaying-Turbulence"><span>Complete Example: LES of Decaying Turbulence</span></a></li><li><a class="tocitem" href="#Complete-Example:-LES-of-Rayleigh-Bénard-Convection"><span>Complete Example: LES of Rayleigh-Bénard Convection</span></a></li><li><a class="tocitem" href="#Diagnostics-and-Analysis"><span>Diagnostics and Analysis</span></a></li><li><a class="tocitem" href="#Tips-for-Successful-LES"><span>Tips for Successful LES</span></a></li><li><a class="tocitem" href="#2D-Flows"><span>2D Flows</span></a></li><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li><li><a class="tocitem" href="#Troubleshooting"><span>Troubleshooting</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li><li><a class="tocitem" href="#See-Also"><span>See Also</span></a></li></ul></li><li><a class="tocitem" href="../gql_approximation/">GQL Approximation</a></li><li><a class="tocitem" href="../tau_method/">Tau Method</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/coordinates/">Coordinates</a></li><li><a class="tocitem" href="../../api/bases/">Bases</a></li><li><a class="tocitem" href="../../api/domains/">Domains</a></li><li><a class="tocitem" href="../../api/fields/">Fields</a></li><li><a class="tocitem" href="../../api/operators/">Operators</a></li><li><a class="tocitem" href="../../api/problems/">Problems</a></li><li><a class="tocitem" href="../../api/solvers/">Solvers</a></li><li><a class="tocitem" href="../../api/timesteppers/">Time Steppers</a></li><li><a class="tocitem" href="../../api/gpu/">GPU</a></li><li><a class="tocitem" href="../../api/stochastic_forcing/">Stochastic Forcing</a></li><li><a class="tocitem" href="../../api/les_models/">LES Models</a></li><li><a class="tocitem" href="../../api/analysis/">Analysis</a></li><li><a class="tocitem" href="../../api/io/">I/O</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>LES Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>LES Models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/subhk/Tarang.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/subhk/Tarang.jl/blob/main/docs/src/pages/les_models.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Large-Eddy-Simulation-(LES)-Models"><a class="docs-heading-anchor" href="#Large-Eddy-Simulation-(LES)-Models">Large Eddy Simulation (LES) Models</a><a id="Large-Eddy-Simulation-(LES)-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Large-Eddy-Simulation-(LES)-Models" title="Permalink"></a></h1><p>This page provides a comprehensive introduction to Large Eddy Simulation (LES) and the subgrid-scale (SGS) closure models available in Tarang.jl.</p><hr/><h2 id="What-is-Large-Eddy-Simulation?"><a class="docs-heading-anchor" href="#What-is-Large-Eddy-Simulation?">What is Large Eddy Simulation?</a><a id="What-is-Large-Eddy-Simulation?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-Large-Eddy-Simulation?" title="Permalink"></a></h2><h3 id="The-Turbulence-Challenge"><a class="docs-heading-anchor" href="#The-Turbulence-Challenge">The Turbulence Challenge</a><a id="The-Turbulence-Challenge-1"></a><a class="docs-heading-anchor-permalink" href="#The-Turbulence-Challenge" title="Permalink"></a></h3><p>Turbulent flows contain a vast range of length scales, from the largest energy-containing eddies down to the smallest dissipative scales (Kolmogorov scales). In a Direct Numerical Simulation (DNS), we resolve <strong>all</strong> these scales, which requires:</p><p class="math-container">\[N \sim Re^{9/4}\]</p><p>grid points in 3D, where <span>$Re$</span> is the Reynolds number. For atmospheric or oceanic flows with <span>$Re \sim 10^9$</span>, this is computationally impossible.</p><h3 id="The-LES-Approach"><a class="docs-heading-anchor" href="#The-LES-Approach">The LES Approach</a><a id="The-LES-Approach-1"></a><a class="docs-heading-anchor-permalink" href="#The-LES-Approach" title="Permalink"></a></h3><p>Large Eddy Simulation offers a practical alternative:</p><ol><li><strong>Resolve</strong> the large, energy-containing eddies directly</li><li><strong>Model</strong> the effect of small, unresolved eddies</li></ol><pre><code class="nohighlight hljs">┌─────────────────────────────────────────────────────────────┐
│                    Energy Spectrum E(k)                      │
│                                                              │
│    E(k)                                                      │
│     │                                                        │
│     │   ╭──╮                                                 │
│     │  ╱    ╲          k^(-5/3)                              │
│     │ ╱      ╲___                                            │
│     │╱            ╲___                                       │
│     │                  ╲___                                  │
│     │                       ╲___                             │
│     └──────────────────────────────────────────────► k       │
│         │                    │                               │
│         │◄── Resolved ──────►│◄── Modeled (SGS) ──►│        │
│         │   (large eddies)   │   (small eddies)    │        │
│                              │                               │
│                          filter cutoff (Δ)                   │
└─────────────────────────────────────────────────────────────┘</code></pre><p>The <strong>filter width</strong> <span>$\Delta$</span> (typically the grid spacing) separates resolved from unresolved scales.</p><h3 id="Filtering-the-Navier-Stokes-Equations"><a class="docs-heading-anchor" href="#Filtering-the-Navier-Stokes-Equations">Filtering the Navier-Stokes Equations</a><a id="Filtering-the-Navier-Stokes-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-the-Navier-Stokes-Equations" title="Permalink"></a></h3><p>We apply a spatial filter to decompose velocity into resolved (<span>$\bar{u}$</span>) and subgrid (<span>$u&#39;$</span>) parts:</p><p class="math-container">\[u = \bar{u} + u&#39;\]</p><p>Filtering the incompressible Navier-Stokes equations gives:</p><p class="math-container">\[\frac{\partial \bar{u}_i}{\partial t} + \bar{u}_j \frac{\partial \bar{u}_i}{\partial x_j} = -\frac{1}{\rho}\frac{\partial \bar{p}}{\partial x_i} + \nu \nabla^2 \bar{u}_i - \frac{\partial \tau_{ij}}{\partial x_j}\]</p><p>where the <strong>subgrid-scale (SGS) stress tensor</strong> appears:</p><p class="math-container">\[\tau_{ij} = \overline{u_i u_j} - \bar{u}_i \bar{u}_j\]</p><p>This tensor represents the effect of unresolved turbulent motions on the resolved flow. Since we cannot compute <span>$\tau_{ij}$</span> directly (it involves unresolved velocities), we must <strong>model</strong> it.</p><hr/><h2 id="The-Closure-Problem"><a class="docs-heading-anchor" href="#The-Closure-Problem">The Closure Problem</a><a id="The-Closure-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-Closure-Problem" title="Permalink"></a></h2><h3 id="Why-We-Need-Models"><a class="docs-heading-anchor" href="#Why-We-Need-Models">Why We Need Models</a><a id="Why-We-Need-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Why-We-Need-Models" title="Permalink"></a></h3><p>The SGS stress <span>$\tau_{ij}$</span> contains information about scales we don&#39;t resolve. This creates the <strong>closure problem</strong>: our filtered equations have more unknowns than equations.</p><h3 id="The-Eddy-Viscosity-Hypothesis"><a class="docs-heading-anchor" href="#The-Eddy-Viscosity-Hypothesis">The Eddy Viscosity Hypothesis</a><a id="The-Eddy-Viscosity-Hypothesis-1"></a><a class="docs-heading-anchor-permalink" href="#The-Eddy-Viscosity-Hypothesis" title="Permalink"></a></h3><p>Most SGS models use the <strong>Boussinesq hypothesis</strong>, which assumes the SGS stress is proportional to the resolved strain rate:</p><p class="math-container">\[\tau_{ij} - \frac{1}{3}\tau_{kk}\delta_{ij} = -2 \nu_e \bar{S}_{ij}\]</p><p>where:</p><ul><li><p class="math-container">\[\nu_e\]</p>is the <strong>eddy viscosity</strong> (to be modeled)</li><li><p class="math-container">\[\bar{S}_{ij}\]</p>is the resolved strain rate tensor:</li></ul><p class="math-container">\[\bar{S}_{ij} = \frac{1}{2}\left(\frac{\partial \bar{u}_i}{\partial x_j} + \frac{\partial \bar{u}_j}{\partial x_i}\right)\]</p><p>This transforms the filtered momentum equation into:</p><p class="math-container">\[\frac{\partial \bar{u}_i}{\partial t} + \bar{u}_j \frac{\partial \bar{u}_i}{\partial x_j} = -\frac{1}{\rho}\frac{\partial \bar{p}^*}{\partial x_i} + (\nu + \nu_e) \nabla^2 \bar{u}_i\]</p><p>where we&#39;ve absorbed the isotropic part into a modified pressure <span>$\bar{p}^*$</span>.</p><p><strong>Key insight</strong>: The SGS model effectively adds a spatially-varying viscosity <span>$\nu_e(x,t)$</span> to the molecular viscosity <span>$\nu$</span>.</p><hr/><h2 id="Energy-Cascade-and-Dissipation"><a class="docs-heading-anchor" href="#Energy-Cascade-and-Dissipation">Energy Cascade and Dissipation</a><a id="Energy-Cascade-and-Dissipation-1"></a><a class="docs-heading-anchor-permalink" href="#Energy-Cascade-and-Dissipation" title="Permalink"></a></h2><h3 id="Forward-Energy-Cascade"><a class="docs-heading-anchor" href="#Forward-Energy-Cascade">Forward Energy Cascade</a><a id="Forward-Energy-Cascade-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-Energy-Cascade" title="Permalink"></a></h3><p>In 3D turbulence, energy flows from large scales to small scales (forward cascade):</p><pre><code class="nohighlight hljs">Large eddies ──► Medium eddies ──► Small eddies ──► Dissipation
  (production)                                        (ε = 2νSᵢⱼSᵢⱼ)</code></pre><p>The SGS model must drain energy from resolved scales at the correct rate to maintain physical behavior.</p><h3 id="SGS-Dissipation"><a class="docs-heading-anchor" href="#SGS-Dissipation">SGS Dissipation</a><a id="SGS-Dissipation-1"></a><a class="docs-heading-anchor-permalink" href="#SGS-Dissipation" title="Permalink"></a></h3><p>The rate at which energy is transferred from resolved to unresolved scales is:</p><p class="math-container">\[\varepsilon_{sgs} = -\tau_{ij} \bar{S}_{ij} = 2\nu_e |\bar{S}|^2\]</p><p>where <span>$|\bar{S}| = \sqrt{2\bar{S}_{ij}\bar{S}_{ij}}$</span> is the strain rate magnitude.</p><p>A good SGS model ensures <span>$\varepsilon_{sgs}$</span> matches the actual energy transfer rate.</p><hr/><h2 id="Available-Models-in-Tarang.jl"><a class="docs-heading-anchor" href="#Available-Models-in-Tarang.jl">Available Models in Tarang.jl</a><a id="Available-Models-in-Tarang.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Available-Models-in-Tarang.jl" title="Permalink"></a></h2><p>Tarang.jl provides two eddy viscosity models:</p><table><tr><th style="text-align: right">Model</th><th style="text-align: right">Year</th><th style="text-align: right">Key Feature</th><th style="text-align: right">Best For</th></tr><tr><td style="text-align: right"><strong>Smagorinsky</strong></td><td style="text-align: right">1963</td><td style="text-align: right">Simple, robust</td><td style="text-align: right">Isotropic grids, fully turbulent flows</td></tr><tr><td style="text-align: right"><strong>AMD</strong></td><td style="text-align: right">2015</td><td style="text-align: right">Minimum dissipation, anisotropic</td><td style="text-align: right">Transitional flows, stretched grids</td></tr></table><hr/><h2 id="Smagorinsky-Model"><a class="docs-heading-anchor" href="#Smagorinsky-Model">Smagorinsky Model</a><a id="Smagorinsky-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Smagorinsky-Model" title="Permalink"></a></h2><h3 id="Physical-Basis"><a class="docs-heading-anchor" href="#Physical-Basis">Physical Basis</a><a id="Physical-Basis-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-Basis" title="Permalink"></a></h3><p>Joseph Smagorinsky (1963) proposed the first and most widely-used SGS model. It&#39;s based on dimensional analysis and mixing length theory.</p><p><strong>Key assumptions:</strong></p><ol><li>The subgrid scales are in equilibrium (production = dissipation)</li><li>The characteristic length scale is proportional to the filter width <span>$\Delta$</span></li><li>The characteristic velocity scale is <span>$\Delta |\bar{S}|$</span></li></ol><h3 id="Mathematical-Formulation"><a class="docs-heading-anchor" href="#Mathematical-Formulation">Mathematical Formulation</a><a id="Mathematical-Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Formulation" title="Permalink"></a></h3><p>The eddy viscosity is computed as:</p><p class="math-container">\[\nu_e = (C_s \Delta)^2 |\bar{S}|\]</p><p>where:</p><ul><li><p class="math-container">\[C_s \approx 0.17\]</p>is the <strong>Smagorinsky constant</strong></li><li><p class="math-container">\[\Delta = (\Delta_x \Delta_y \Delta_z)^{1/3}\]</p>is the effective filter width</li><li><p class="math-container">\[|\bar{S}| = \sqrt{2 \bar{S}_{ij} \bar{S}_{ij}}\]</p>is the strain rate magnitude</li></ul><p><strong>Expanded form for 3D:</strong></p><p class="math-container">\[|\bar{S}| = \sqrt{2\left[\left(\frac{\partial \bar{u}}{\partial x}\right)^2 + \left(\frac{\partial \bar{v}}{\partial y}\right)^2 + \left(\frac{\partial \bar{w}}{\partial z}\right)^2\right] + \left(\frac{\partial \bar{u}}{\partial y} + \frac{\partial \bar{v}}{\partial x}\right)^2 + \left(\frac{\partial \bar{u}}{\partial z} + \frac{\partial \bar{w}}{\partial x}\right)^2 + \left(\frac{\partial \bar{v}}{\partial z} + \frac{\partial \bar{w}}{\partial y}\right)^2}\]</p><h3 id="Usage-in-Tarang.jl"><a class="docs-heading-anchor" href="#Usage-in-Tarang.jl">Usage in Tarang.jl</a><a id="Usage-in-Tarang.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-in-Tarang.jl" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Tarang

# Grid parameters
N = 128                     # Grid points per direction
L = 2π                      # Domain size
Δ = L / N                   # Grid spacing

# Create the Smagorinsky model
sgs_model = SmagorinskyModel(
    C_s = 0.17,                    # Smagorinsky constant
    filter_width = (Δ, Δ, Δ),      # Grid spacing in each direction
    field_size = (N, N, N)         # Number of grid points
)

# Compute eddy viscosity from velocity gradients
# You need all 9 components of the velocity gradient tensor
compute_eddy_viscosity!(sgs_model,
    ∂u∂x, ∂u∂y, ∂u∂z,    # Gradients of u
    ∂v∂x, ∂v∂y, ∂v∂z,    # Gradients of v
    ∂w∂x, ∂w∂y, ∂w∂z     # Gradients of w
)

# Retrieve the computed eddy viscosity field
νₑ = get_eddy_viscosity(sgs_model)</code></pre><h3 id="Choosing-the-Smagorinsky-Constant"><a class="docs-heading-anchor" href="#Choosing-the-Smagorinsky-Constant">Choosing the Smagorinsky Constant</a><a id="Choosing-the-Smagorinsky-Constant-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-the-Smagorinsky-Constant" title="Permalink"></a></h3><p>The constant <span>$C_s$</span> is not universal and depends on the flow:</p><table><tr><th style="text-align: right">Flow Type</th><th style="text-align: right">Recommended <span>$C_s$</span></th><th style="text-align: right">Notes</th></tr><tr><td style="text-align: right">Isotropic turbulence</td><td style="text-align: right">0.17 - 0.20</td><td style="text-align: right">Theoretical value from Lilly (1967)</td></tr><tr><td style="text-align: right">Channel flow</td><td style="text-align: right">0.10 - 0.12</td><td style="text-align: right">Reduced due to wall effects</td></tr><tr><td style="text-align: right">Mixing layers</td><td style="text-align: right">0.10 - 0.14</td><td style="text-align: right">Transitional regions need lower values</td></tr><tr><td style="text-align: right">Free shear flows</td><td style="text-align: right">0.10 - 0.12</td><td style="text-align: right">Similar to channel flow</td></tr><tr><td style="text-align: right">Atmospheric boundary layer</td><td style="text-align: right">0.10 - 0.15</td><td style="text-align: right">Depends on stability</td></tr></table><p><strong>Rule of thumb</strong>: Start with <span>$C_s = 0.17$</span> and reduce if you observe over-dissipation.</p><h3 id="Limitations"><a class="docs-heading-anchor" href="#Limitations">Limitations</a><a id="Limitations-1"></a><a class="docs-heading-anchor-permalink" href="#Limitations" title="Permalink"></a></h3><ol><li><strong>Over-dissipation</strong>: The model is always &quot;on&quot;, even in laminar regions</li><li><strong>No backscatter</strong>: Cannot represent energy transfer from small to large scales</li><li><strong>Wall behavior</strong>: Needs damping functions near solid walls</li><li><strong>Isotropic assumption</strong>: Assumes same behavior in all directions</li></ol><hr/><h2 id="Anisotropic-Minimum-Dissipation-(AMD)-Model"><a class="docs-heading-anchor" href="#Anisotropic-Minimum-Dissipation-(AMD)-Model">Anisotropic Minimum Dissipation (AMD) Model</a><a id="Anisotropic-Minimum-Dissipation-(AMD)-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Anisotropic-Minimum-Dissipation-(AMD)-Model" title="Permalink"></a></h2><h3 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h3><p>The AMD model (Rozema et al., 2015) addresses key limitations of Smagorinsky:</p><ol><li><strong>Automatic switch-off</strong>: <span>$\nu_e = 0$</span> in laminar/transitional regions</li><li><strong>Anisotropic grids</strong>: Properly handles <span>$\Delta_x \neq \Delta_y \neq \Delta_z$</span></li><li><strong>Minimum dissipation</strong>: Adds only the dissipation needed for stability</li></ol><h3 id="Mathematical-Formulation-2"><a class="docs-heading-anchor" href="#Mathematical-Formulation-2">Mathematical Formulation</a><a class="docs-heading-anchor-permalink" href="#Mathematical-Formulation-2" title="Permalink"></a></h3><p>The AMD model computes eddy viscosity as:</p><p class="math-container">\[\nu_e = \max\left(0, -C \frac{\hat{\delta}_{ij}^2 \frac{\partial \bar{u}_i}{\partial x_k} \frac{\partial \bar{u}_j}{\partial x_k} \bar{S}_{ij}}{\frac{\partial \bar{u}_m}{\partial x_n} \frac{\partial \bar{u}_m}{\partial x_n}}\right)\]</p><p>where <span>$\hat{\delta}_{ij} = \Delta_i \delta_{ij}$</span> (no sum) incorporates anisotropic filter widths.</p><p><strong>Simplified form:</strong></p><p class="math-container">\[\nu_e = \max\left(0, -C \frac{\text{numerator}}{\text{denominator}}\right)\]</p><ul><li><strong>Numerator</strong>: Measures alignment between velocity gradients and strain rate</li><li><strong>Denominator</strong>: Total velocity gradient magnitude squared</li><li><strong>max(0, ...)</strong>: Ensures non-negative eddy viscosity</li></ul><h3 id="Physical-Interpretation"><a class="docs-heading-anchor" href="#Physical-Interpretation">Physical Interpretation</a><a id="Physical-Interpretation-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-Interpretation" title="Permalink"></a></h3><p>The numerator can be negative (giving <span>$\nu_e &gt; 0$</span>) when:</p><ul><li>Velocity gradients are aligned with the strain rate</li><li>Energy is being transferred to smaller scales</li></ul><p>The numerator is positive (giving <span>$\nu_e = 0$</span>) when:</p><ul><li>Flow is laminar or transitional</li><li>No SGS dissipation is needed</li></ul><h3 id="Usage-in-Tarang.jl-2"><a class="docs-heading-anchor" href="#Usage-in-Tarang.jl-2">Usage in Tarang.jl</a><a class="docs-heading-anchor-permalink" href="#Usage-in-Tarang.jl-2" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Create the AMD model
sgs_model = AMDModel(
    C = 1/12,                      # Poincaré constant (for spectral methods)
    filter_width = (Δx, Δy, Δz),   # Can be different in each direction
    field_size = (Nx, Ny, Nz),
    clip_negative = true           # Ensure νₑ ≥ 0 (recommended)
)

# Compute eddy viscosity (same interface as Smagorinsky)
compute_eddy_viscosity!(sgs_model,
    ∂u∂x, ∂u∂y, ∂u∂z,
    ∂v∂x, ∂v∂y, ∂v∂z,
    ∂w∂x, ∂w∂y, ∂w∂z
)

νₑ = get_eddy_viscosity(sgs_model)</code></pre><h3 id="Choosing-the-AMD-Constant"><a class="docs-heading-anchor" href="#Choosing-the-AMD-Constant">Choosing the AMD Constant</a><a id="Choosing-the-AMD-Constant-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-the-AMD-Constant" title="Permalink"></a></h3><p>The constant <span>$C$</span> depends on the numerical discretization:</p><table><tr><th style="text-align: right">Discretization</th><th style="text-align: right">Recommended <span>$C$</span></th><th style="text-align: right">Notes</th></tr><tr><td style="text-align: right">Spectral methods</td><td style="text-align: right">1/12 ≈ 0.0833</td><td style="text-align: right">Theoretical value</td></tr><tr><td style="text-align: right">4th-order finite difference</td><td style="text-align: right">0.212</td><td style="text-align: right">From Verstappen (2011)</td></tr><tr><td style="text-align: right">2nd-order finite difference</td><td style="text-align: right">0.3</td><td style="text-align: right">Higher due to numerical diffusion</td></tr></table><h3 id="Scalar-Transport-(Buoyancy)"><a class="docs-heading-anchor" href="#Scalar-Transport-(Buoyancy)">Scalar Transport (Buoyancy)</a><a id="Scalar-Transport-(Buoyancy)-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-Transport-(Buoyancy)" title="Permalink"></a></h3><p>For buoyancy-driven flows, AMD also provides eddy diffusivity for scalar transport:</p><p class="math-container">\[\kappa_e = \max\left(0, -C \frac{\Delta_k^2 \frac{\partial \bar{u}_i}{\partial x_k} \frac{\partial \bar{\theta}}{\partial x_k} \frac{\partial \bar{\theta}}{\partial x_i}}{\frac{\partial \bar{\theta}}{\partial x_n} \frac{\partial \bar{\theta}}{\partial x_n}}\right)\]</p><pre><code class="language-julia hljs"># Compute eddy diffusivity for buoyancy/temperature
compute_eddy_diffusivity!(sgs_model,
    ∂w∂x, ∂w∂y, ∂w∂z,    # Vertical velocity gradients
    ∂b∂x, ∂b∂y, ∂b∂z     # Buoyancy/scalar gradients
)

κₑ = get_eddy_diffusivity(sgs_model)</code></pre><hr/><h2 id="Choosing-Between-Models"><a class="docs-heading-anchor" href="#Choosing-Between-Models">Choosing Between Models</a><a id="Choosing-Between-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-Between-Models" title="Permalink"></a></h2><h3 id="Decision-Flowchart"><a class="docs-heading-anchor" href="#Decision-Flowchart">Decision Flowchart</a><a id="Decision-Flowchart-1"></a><a class="docs-heading-anchor-permalink" href="#Decision-Flowchart" title="Permalink"></a></h3><pre><code class="nohighlight hljs">Start
  │
  ▼
Is your grid anisotropic (Δx ≠ Δy ≠ Δz)?
  │
  ├── Yes ──► Use AMD (handles anisotropy naturally)
  │
  └── No
       │
       ▼
Does your flow have laminar or transitional regions?
       │
       ├── Yes ──► Use AMD (automatically switches off)
       │
       └── No
            │
            ▼
Is computational cost a primary concern?
            │
            ├── Yes ──► Use Smagorinsky (slightly cheaper)
            │
            └── No ──► Either works; AMD is generally more accurate</code></pre><h3 id="Summary-Comparison"><a class="docs-heading-anchor" href="#Summary-Comparison">Summary Comparison</a><a id="Summary-Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-Comparison" title="Permalink"></a></h3><table><tr><th style="text-align: right">Aspect</th><th style="text-align: right">Smagorinsky</th><th style="text-align: right">AMD</th></tr><tr><td style="text-align: right"><strong>Complexity</strong></td><td style="text-align: right">Simple</td><td style="text-align: right">Moderate</td></tr><tr><td style="text-align: right"><strong>Cost per timestep</strong></td><td style="text-align: right">Low</td><td style="text-align: right">Slightly higher</td></tr><tr><td style="text-align: right"><strong>Laminar regions</strong></td><td style="text-align: right">Over-dissipates</td><td style="text-align: right">Correctly gives νₑ = 0</td></tr><tr><td style="text-align: right"><strong>Anisotropic grids</strong></td><td style="text-align: right">Needs modification</td><td style="text-align: right">Native support</td></tr><tr><td style="text-align: right"><strong>Near walls</strong></td><td style="text-align: right">Needs damping</td><td style="text-align: right">Better behavior</td></tr><tr><td style="text-align: right"><strong>Tuning required</strong></td><td style="text-align: right">Often yes</td><td style="text-align: right">Usually not</td></tr><tr><td style="text-align: right"><strong>Scalar transport</strong></td><td style="text-align: right">Use Pr_t</td><td style="text-align: right">Built-in κₑ</td></tr></table><hr/><h2 id="Complete-Example:-LES-of-Decaying-Turbulence"><a class="docs-heading-anchor" href="#Complete-Example:-LES-of-Decaying-Turbulence">Complete Example: LES of Decaying Turbulence</a><a id="Complete-Example:-LES-of-Decaying-Turbulence-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Example:-LES-of-Decaying-Turbulence" title="Permalink"></a></h2><p>This example demonstrates a complete LES setup for decaying homogeneous isotropic turbulence.</p><pre><code class="language-julia hljs">using Tarang
using Statistics

# ============================================================
# 1. Physical and Numerical Parameters
# ============================================================

N = 128                     # Grid points per direction
L = 2π                      # Domain size [m]
Δ = L / N                   # Grid spacing [m]
ν = 1e-4                    # Molecular (kinematic) viscosity [m²/s]
dt = 0.001                  # Time step [s]
nsteps = 1000               # Number of time steps

# ============================================================
# 2. Create the SGS Model
# ============================================================

# Option A: Smagorinsky (simple, robust)
sgs = SmagorinskyModel(
    C_s = 0.17,
    filter_width = (Δ, Δ, Δ),
    field_size = (N, N, N)
)

# Option B: AMD (recommended for most applications)
# sgs = AMDModel(
#     C = 1/12,
#     filter_width = (Δ, Δ, Δ),
#     field_size = (N, N, N)
# )

# ============================================================
# 3. Setup Computational Domain
# ============================================================

coords = CartesianCoordinates(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)
dist = Distributor(coords; mesh=(1, 1, 1))  # Single processor

# Fourier bases for periodic domain
xbasis = RealFourier(coords[&quot;x&quot;]; size=N, bounds=(0.0, L))
ybasis = RealFourier(coords[&quot;y&quot;]; size=N, bounds=(0.0, L))
zbasis = RealFourier(coords[&quot;z&quot;]; size=N, bounds=(0.0, L))

domain = Domain(dist, (xbasis, ybasis, zbasis))

# Create velocity field
u = VectorField(dist, coords, &quot;u&quot;, (xbasis, ybasis, zbasis))

# ============================================================
# 4. Initialize with Turbulent Velocity Field
# ============================================================

# (Initialize u with your preferred IC - e.g., random phases
#  with prescribed energy spectrum)

# ============================================================
# 5. Helper Function: Compute All Velocity Gradients
# ============================================================

function compute_velocity_gradients(u)
    # Uses spectral differentiation for high accuracy
    ∂u∂x, ∂u∂y, ∂u∂z = gradient(u.components[1])
    ∂v∂x, ∂v∂y, ∂v∂z = gradient(u.components[2])
    ∂w∂x, ∂w∂y, ∂w∂z = gradient(u.components[3])
    return (∂u∂x, ∂u∂y, ∂u∂z,
            ∂v∂x, ∂v∂y, ∂v∂z,
            ∂w∂x, ∂w∂y, ∂w∂z)
end

# ============================================================
# 6. Time Integration Loop
# ============================================================

for step in 1:nsteps
    # --- Step 1: Compute velocity gradients ---
    grads = compute_velocity_gradients(u)

    # --- Step 2: Update SGS eddy viscosity ---
    compute_eddy_viscosity!(sgs, grads...)

    # --- Step 3: Get effective viscosity ---
    νₑ = get_eddy_viscosity(sgs)
    ν_eff = ν .+ νₑ  # Total viscosity = molecular + SGS

    # --- Step 4: Advance momentum equation ---
    # The filtered Navier-Stokes with SGS model:
    #   ∂ū/∂t + (ū·∇)ū = -∇p̄/ρ + (ν + νₑ)∇²ū
    #
    # In your timestepper, use ν_eff instead of ν
    # for the viscous term

    # --- Step 5: Diagnostics ---
    if step % 100 == 0
        mean_νₑ = mean_eddy_viscosity(sgs)
        max_νₑ = max_eddy_viscosity(sgs)

        println(&quot;Step $step:&quot;)
        println(&quot;  Mean eddy viscosity: $(mean_νₑ)&quot;)
        println(&quot;  Max eddy viscosity:  $(max_νₑ)&quot;)
        println(&quot;  Ratio νₑ/ν (mean):   $(mean_νₑ/ν)&quot;)
    end
end</code></pre><hr/><h2 id="Complete-Example:-LES-of-Rayleigh-Bénard-Convection"><a class="docs-heading-anchor" href="#Complete-Example:-LES-of-Rayleigh-Bénard-Convection">Complete Example: LES of Rayleigh-Bénard Convection</a><a id="Complete-Example:-LES-of-Rayleigh-Bénard-Convection-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Example:-LES-of-Rayleigh-Bénard-Convection" title="Permalink"></a></h2><p>For buoyancy-driven turbulence, we need both momentum and scalar closures:</p><pre><code class="language-julia hljs">using Tarang

# ============================================================
# Physical Parameters
# ============================================================

Nx, Nz = 256, 128           # Grid resolution
Lx, Lz = 4.0, 1.0           # Domain size
Δx, Δz = Lx/Nx, Lz/Nz       # Grid spacing

Ra = 1e8                    # Rayleigh number
Pr = 1.0                    # Prandtl number
ν = sqrt(Pr / Ra)           # Kinematic viscosity
κ = ν / Pr                  # Thermal diffusivity

# ============================================================
# Create AMD Model (recommended for RBC)
# ============================================================

sgs = AMDModel(
    C = 1/12,
    filter_width = (Δx, Δz),
    field_size = (Nx, Nz)
)

# ============================================================
# In the Time Loop
# ============================================================

for step in 1:nsteps
    # Compute velocity gradients
    ∂u∂x, ∂u∂z = gradient(u)
    ∂w∂x, ∂w∂z = gradient(w)

    # Compute temperature gradients
    ∂T∂x, ∂T∂z = gradient(T)

    # --- Momentum closure ---
    compute_eddy_viscosity!(sgs, ∂u∂x, ∂u∂z, ∂w∂x, ∂w∂z)
    νₑ = get_eddy_viscosity(sgs)
    ν_eff = ν .+ νₑ

    # --- Scalar (temperature) closure ---
    compute_eddy_diffusivity!(sgs, ∂w∂x, ∂w∂z, ∂T∂x, ∂T∂z)
    κₑ = get_eddy_diffusivity(sgs)
    κ_eff = κ .+ κₑ

    # Use ν_eff in momentum equation
    # Use κ_eff in temperature equation
end</code></pre><hr/><h2 id="Diagnostics-and-Analysis"><a class="docs-heading-anchor" href="#Diagnostics-and-Analysis">Diagnostics and Analysis</a><a id="Diagnostics-and-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostics-and-Analysis" title="Permalink"></a></h2><h3 id="SGS-Energy-Dissipation"><a class="docs-heading-anchor" href="#SGS-Energy-Dissipation">SGS Energy Dissipation</a><a id="SGS-Energy-Dissipation-1"></a><a class="docs-heading-anchor-permalink" href="#SGS-Energy-Dissipation" title="Permalink"></a></h3><p>The SGS dissipation rate tells you how much energy is being drained by the model:</p><pre><code class="language-julia hljs"># Get strain magnitude (computed during eddy viscosity calculation)
S_mag = sgs.strain_magnitude  # Only for Smagorinsky

# Or compute it yourself
S_mag = sqrt(2 * (S11.^2 + S22.^2 + S33.^2 + 2*S12.^2 + 2*S13.^2 + 2*S23.^2))

# SGS dissipation field: ε_sgs = 2 νₑ |S|²
ε_sgs = sgs_dissipation(sgs, S_mag)

# Domain-averaged SGS dissipation
ε_sgs_mean = mean_sgs_dissipation(sgs, S_mag)</code></pre><h3 id="Monitoring-Model-Behavior"><a class="docs-heading-anchor" href="#Monitoring-Model-Behavior">Monitoring Model Behavior</a><a id="Monitoring-Model-Behavior-1"></a><a class="docs-heading-anchor-permalink" href="#Monitoring-Model-Behavior" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Check ratio of SGS to molecular viscosity
νₑ_mean = mean_eddy_viscosity(sgs)
println(&quot;νₑ/ν = $(νₑ_mean/ν)&quot;)

# If νₑ/ν &gt;&gt; 1: SGS model is dominant (typical for high Re)
# If νₑ/ν &lt;&lt; 1: Flow is nearly DNS-resolved
# If νₑ/ν ~ 1: Well-resolved LES

# For AMD: check how often νₑ = 0
νₑ = get_eddy_viscosity(sgs)
fraction_zero = sum(νₑ .== 0) / length(νₑ)
println(&quot;Fraction with νₑ = 0: $(fraction_zero)&quot;)
# High fraction → flow is largely laminar/transitional</code></pre><hr/><h2 id="Tips-for-Successful-LES"><a class="docs-heading-anchor" href="#Tips-for-Successful-LES">Tips for Successful LES</a><a id="Tips-for-Successful-LES-1"></a><a class="docs-heading-anchor-permalink" href="#Tips-for-Successful-LES" title="Permalink"></a></h2><h3 id="Resolution-Requirements"><a class="docs-heading-anchor" href="#Resolution-Requirements">Resolution Requirements</a><a id="Resolution-Requirements-1"></a><a class="docs-heading-anchor-permalink" href="#Resolution-Requirements" title="Permalink"></a></h3><p>LES still requires adequate resolution:</p><pre><code class="nohighlight hljs">┌────────────────────────────────────────────────────────────┐
│  Resolution Quality for LES                                 │
├────────────────────────────────────────────────────────────┤
│  80% of TKE resolved      →  Minimum acceptable LES        │
│  90% of TKE resolved      →  Good quality LES              │
│  95%+ of TKE resolved     →  Nearly DNS quality            │
└────────────────────────────────────────────────────────────┘</code></pre><p>Rule of thumb: Grid spacing should resolve the inertial range, typically <span>$\Delta \lesssim L_{integral}/10$</span>.</p><h3 id="Common-Pitfalls"><a class="docs-heading-anchor" href="#Common-Pitfalls">Common Pitfalls</a><a id="Common-Pitfalls-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Pitfalls" title="Permalink"></a></h3><table><tr><th style="text-align: right">Symptom</th><th style="text-align: right">Likely Cause</th><th style="text-align: right">Solution</th></tr><tr><td style="text-align: right">Simulation blows up</td><td style="text-align: right">νₑ too small</td><td style="text-align: right">Increase <span>$C_s$</span> or <span>$C$</span></td></tr><tr><td style="text-align: right">Flow looks too smooth</td><td style="text-align: right">Over-dissipation</td><td style="text-align: right">Reduce <span>$C_s$</span>, or use AMD</td></tr><tr><td style="text-align: right">Checkerboard patterns</td><td style="text-align: right">Aliasing errors</td><td style="text-align: right">Enable dealiasing (2/3 rule)</td></tr><tr><td style="text-align: right">νₑ unrealistically large</td><td style="text-align: right">Poor resolution</td><td style="text-align: right">Refine grid</td></tr><tr><td style="text-align: right">AMD gives νₑ = 0 everywhere</td><td style="text-align: right">Flow is laminar</td><td style="text-align: right">This is correct!</td></tr></table><h3 id="When-LES-May-Not-Be-Appropriate"><a class="docs-heading-anchor" href="#When-LES-May-Not-Be-Appropriate">When LES May Not Be Appropriate</a><a id="When-LES-May-Not-Be-Appropriate-1"></a><a class="docs-heading-anchor-permalink" href="#When-LES-May-Not-Be-Appropriate" title="Permalink"></a></h3><ul><li><strong>Very low Reynolds numbers</strong>: DNS may be feasible</li><li><strong>Strongly anisotropic turbulence</strong>: May need special treatment</li><li><strong>Flows with strong backscatter</strong>: Standard models don&#39;t capture this</li><li><strong>Near-wall regions</strong>: May need wall models or finer grids</li></ul><hr/><h2 id="2D-Flows"><a class="docs-heading-anchor" href="#2D-Flows">2D Flows</a><a id="2D-Flows-1"></a><a class="docs-heading-anchor-permalink" href="#2D-Flows" title="Permalink"></a></h2><p>Both models support 2D simulations:</p><pre><code class="language-julia hljs"># 2D Smagorinsky
sgs_2d = SmagorinskyModel(
    C_s = 0.17,
    filter_width = (Δx, Δy),
    field_size = (Nx, Ny)
)

# 2D velocity gradients (4 components)
compute_eddy_viscosity!(sgs_2d, ∂u∂x, ∂u∂y, ∂v∂x, ∂v∂y)</code></pre><p><strong>Note on 2D turbulence</strong>: 2D turbulence has an <em>inverse</em> energy cascade (energy flows to large scales), which is fundamentally different from 3D. Standard SGS models may not be appropriate for 2D flows.</p><hr/><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><pre><code class="language-julia hljs">SmagorinskyModel(;
    C_s = 0.17,                    # Smagorinsky constant
    filter_width::NTuple{N, Real}, # (Δx, Δy) or (Δx, Δy, Δz)
    field_size::NTuple{N, Int},    # (Nx, Ny) or (Nx, Ny, Nz)
    dtype = Float64                # Precision
)

AMDModel(;
    C = 1/12,                      # Poincaré constant
    filter_width::NTuple{N, Real}, # Can be anisotropic
    field_size::NTuple{N, Int},
    clip_negative = true,          # Ensure νₑ ≥ 0
    dtype = Float64
)</code></pre><h3 id="Core-Functions"><a class="docs-heading-anchor" href="#Core-Functions">Core Functions</a><a id="Core-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Functions" title="Permalink"></a></h3><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>compute_eddy_viscosity!(model, grads...)</code></td><td style="text-align: right">Compute νₑ from velocity gradients</td></tr><tr><td style="text-align: right"><code>compute_eddy_diffusivity!(model, grads...)</code></td><td style="text-align: right">Compute κₑ for scalars (AMD only)</td></tr><tr><td style="text-align: right"><code>get_eddy_viscosity(model)</code></td><td style="text-align: right">Return the νₑ field</td></tr><tr><td style="text-align: right"><code>get_eddy_diffusivity(model)</code></td><td style="text-align: right">Return the κₑ field (AMD)</td></tr></table><h3 id="Analysis-Functions"><a class="docs-heading-anchor" href="#Analysis-Functions">Analysis Functions</a><a id="Analysis-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-Functions" title="Permalink"></a></h3><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>mean_eddy_viscosity(model)</code></td><td style="text-align: right">Domain-averaged νₑ</td></tr><tr><td style="text-align: right"><code>max_eddy_viscosity(model)</code></td><td style="text-align: right">Maximum νₑ</td></tr><tr><td style="text-align: right"><code>sgs_dissipation(model, S_mag)</code></td><td style="text-align: right">SGS dissipation field</td></tr><tr><td style="text-align: right"><code>mean_sgs_dissipation(model, S_mag)</code></td><td style="text-align: right">Domain-averaged dissipation</td></tr></table><h3 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h3><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>set_constant!(model, C)</code></td><td style="text-align: right">Update model constant</td></tr><tr><td style="text-align: right"><code>reset!(model)</code></td><td style="text-align: right">Reset νₑ (and κₑ) to zero</td></tr><tr><td style="text-align: right"><code>get_filter_width(model)</code></td><td style="text-align: right">Return filter width tuple</td></tr><tr><td style="text-align: right"><code>compute_sgs_stress(model, S...)</code></td><td style="text-align: right">Compute full SGS stress tensor</td></tr></table><hr/><h2 id="Troubleshooting"><a class="docs-heading-anchor" href="#Troubleshooting">Troubleshooting</a><a id="Troubleshooting-1"></a><a class="docs-heading-anchor-permalink" href="#Troubleshooting" title="Permalink"></a></h2><table><tr><th style="text-align: right">Problem</th><th style="text-align: right">Possible Cause</th><th style="text-align: right">Solution</th></tr><tr><td style="text-align: right">Simulation becomes unstable</td><td style="text-align: right">νₑ too small</td><td style="text-align: right">Increase <span>$C_s$</span> or <span>$C$</span>; check CFL condition</td></tr><tr><td style="text-align: right">Flow appears over-damped</td><td style="text-align: right">νₑ too large</td><td style="text-align: right">Reduce <span>$C_s$</span>; consider AMD model</td></tr><tr><td style="text-align: right">Spurious oscillations</td><td style="text-align: right">Aliasing</td><td style="text-align: right">Enable 2/3 dealiasing rule</td></tr><tr><td style="text-align: right">AMD gives νₑ = 0 everywhere</td><td style="text-align: right">Flow is laminar</td><td style="text-align: right">Correct behavior; model switches off</td></tr><tr><td style="text-align: right">Unphysical behavior near walls</td><td style="text-align: right">Poor wall resolution</td><td style="text-align: right">Refine near-wall grid; use wall functions</td></tr></table><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><h3 id="Original-Papers"><a class="docs-heading-anchor" href="#Original-Papers">Original Papers</a><a id="Original-Papers-1"></a><a class="docs-heading-anchor-permalink" href="#Original-Papers" title="Permalink"></a></h3><ol><li><p><strong>Smagorinsky, J.</strong> (1963). &quot;General circulation experiments with the primitive equations: I. The basic experiment.&quot; <em>Monthly Weather Review</em>, 91(3), 99-164.</p></li><li><p><strong>Rozema, W., Bae, H. J., Moin, P., &amp; Verstappen, R.</strong> (2015). &quot;Minimum-dissipation models for large-eddy simulation.&quot; <em>Physics of Fluids</em>, 27(8), 085107. <a href="http://www.its.caltech.edu/~jbae/publications/Rozema_2015.pdf">PDF</a></p></li><li><p><strong>Abkar, M., Bae, H. J., &amp; Moin, P.</strong> (2016). &quot;Minimum-dissipation scalar transport model for large-eddy simulation of turbulent flows.&quot; <em>Physical Review Fluids</em>, 1(4), 041701. <a href="https://link.aps.org/doi/10.1103/PhysRevFluids.1.041701">Link</a></p></li></ol><h3 id="Textbooks-and-Reviews"><a class="docs-heading-anchor" href="#Textbooks-and-Reviews">Textbooks and Reviews</a><a id="Textbooks-and-Reviews-1"></a><a class="docs-heading-anchor-permalink" href="#Textbooks-and-Reviews" title="Permalink"></a></h3><ol><li><p><strong>Pope, S. B.</strong> (2000). <em>Turbulent Flows</em>. Cambridge University Press. (Chapter 13: Large-Eddy Simulation)</p></li><li><p><strong>Sagaut, P.</strong> (2006). <em>Large Eddy Simulation for Incompressible Flows</em>. Springer.</p></li></ol><h3 id="Related-Documentation"><a class="docs-heading-anchor" href="#Related-Documentation">Related Documentation</a><a id="Related-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Related-Documentation" title="Permalink"></a></h3><ul><li><a href="https://dedales.readthedocs.io/en/latest/closures/anisotropic_minimum_dissipation.html">dedaLES AMD Documentation</a></li></ul><hr/><h2 id="See-Also"><a class="docs-heading-anchor" href="#See-Also">See Also</a><a id="See-Also-1"></a><a class="docs-heading-anchor-permalink" href="#See-Also" title="Permalink"></a></h2><ul><li><a href="../solvers/">Solvers</a> - Time integration methods</li><li><a href="../operators/">Operators</a> - Gradient and differential operators</li><li><a href="../stochastic_forcing/">Stochastic Forcing</a> - Forcing for turbulence</li><li><a href="../../api/les_models/">API: LES Models</a> - Complete API reference</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../stochastic_forcing/">« Stochastic Forcing</a><a class="docs-footer-nextpage" href="../gql_approximation/">GQL Approximation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 25 January 2026 12:52">Sunday 25 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
