<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rotating Shallow Water · Tarang.jl</title><meta name="title" content="Rotating Shallow Water · Tarang.jl"/><meta property="og:title" content="Rotating Shallow Water · Tarang.jl"/><meta property="twitter:title" content="Rotating Shallow Water · Tarang.jl"/><meta name="description" content="Documentation for Tarang.jl."/><meta property="og:description" content="Documentation for Tarang.jl."/><meta property="twitter:description" content="Documentation for Tarang.jl."/><meta property="og:url" content="https://subhk.github.io/Tarang.jl/stable/tutorials/rotating_shallow_water/"/><meta property="twitter:url" content="https://subhk.github.io/Tarang.jl/stable/tutorials/rotating_shallow_water/"/><link rel="canonical" href="https://subhk.github.io/Tarang.jl/stable/tutorials/rotating_shallow_water/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Tarang.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Tarang.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting_started/installation/">Installation</a></li><li><a class="tocitem" href="../../getting_started/first_steps/">First Steps</a></li><li><a class="tocitem" href="../../getting_started/running_with_mpi/">Running with MPI</a></li><li><a class="tocitem" href="../../pages/configuration/">Configuration</a></li></ul></li><li><span class="tocitem">Tutorials &amp; Examples</span><ul><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../ivp_2d_rbc/">2D Rayleigh-Benard</a></li><li><a class="tocitem" href="../ivp_3d_turbulence/">3D Turbulence</a></li><li><a class="tocitem" href="../boundary_conditions/">Boundary Conditions</a></li><li><a class="tocitem" href="../analysis_and_output/">Analysis &amp; Output</a></li><li><a class="tocitem" href="../eigenvalue_problems/">Eigenvalue Problems</a></li><li><a class="tocitem" href="../surface_dynamics/">Surface Dynamics</a></li><li class="is-active"><a class="tocitem" href>Rotating Shallow Water</a><ul class="internal"><li><a class="tocitem" href="#Physical-Problem"><span>Physical Problem</span></a></li><li><a class="tocitem" href="#Extensions"><span>Extensions</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li><li><a class="tocitem" href="#Next-Steps"><span>Next Steps</span></a></li></ul></li><li><a class="tocitem" href="../../examples/gallery/">Examples Gallery</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../../pages/coordinates/">Coordinates</a></li><li><a class="tocitem" href="../../pages/bases/">Bases</a></li><li><a class="tocitem" href="../../pages/domains/">Domains</a></li><li><a class="tocitem" href="../../pages/fields/">Fields</a></li><li><a class="tocitem" href="../../pages/operators/">Operators</a></li><li><a class="tocitem" href="../../pages/problems/">Problems</a></li><li><a class="tocitem" href="../../pages/solvers/">Solvers</a></li><li><a class="tocitem" href="../../pages/timesteppers/">Time Steppers</a></li><li><a class="tocitem" href="../../pages/gpu_computing/">GPU Computing</a></li><li><a class="tocitem" href="../../pages/parallelism/">Parallelism</a></li><li><a class="tocitem" href="../../pages/stochastic_forcing/">Stochastic Forcing</a></li><li><a class="tocitem" href="../../pages/les_models/">LES Models</a></li><li><a class="tocitem" href="../../pages/gql_approximation/">GQL Approximation</a></li><li><a class="tocitem" href="../../pages/tau_method/">Tau Method</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/coordinates/">Coordinates</a></li><li><a class="tocitem" href="../../api/bases/">Bases</a></li><li><a class="tocitem" href="../../api/domains/">Domains</a></li><li><a class="tocitem" href="../../api/fields/">Fields</a></li><li><a class="tocitem" href="../../api/operators/">Operators</a></li><li><a class="tocitem" href="../../api/problems/">Problems</a></li><li><a class="tocitem" href="../../api/solvers/">Solvers</a></li><li><a class="tocitem" href="../../api/timesteppers/">Time Steppers</a></li><li><a class="tocitem" href="../../api/gpu/">GPU</a></li><li><a class="tocitem" href="../../api/stochastic_forcing/">Stochastic Forcing</a></li><li><a class="tocitem" href="../../api/les_models/">LES Models</a></li><li><a class="tocitem" href="../../api/analysis/">Analysis</a></li><li><a class="tocitem" href="../../api/io/">I/O</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials &amp; Examples</a></li><li class="is-active"><a href>Rotating Shallow Water</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Rotating Shallow Water</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/subhk/Tarang.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/subhk/Tarang.jl/blob/main/docs/src/tutorials/rotating_shallow_water.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Rotating-Shallow-Water-with-Lagrangian-Averaging"><a class="docs-heading-anchor" href="#Rotating-Shallow-Water-with-Lagrangian-Averaging">Rotating Shallow Water with Lagrangian Averaging</a><a id="Rotating-Shallow-Water-with-Lagrangian-Averaging-1"></a><a class="docs-heading-anchor-permalink" href="#Rotating-Shallow-Water-with-Lagrangian-Averaging" title="Permalink"></a></h1><p>This tutorial demonstrates how to use <strong>temporal filters</strong> to separate fast inertia-gravity waves from slow geostrophic flow in a rotating shallow water model.</p><hr/><h2 id="Physical-Problem"><a class="docs-heading-anchor" href="#Physical-Problem">Physical Problem</a><a id="Physical-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-Problem" title="Permalink"></a></h2><p>The rotating shallow water equations on an f-plane:</p><p class="math-container">\[
\frac{\partial u}{\partial t} - fv = -g\frac{\partial \eta}{\partial x}
$$

$$
\frac{\partial v}{\partial t} + fu = -g\frac{\partial \eta}{\partial y}
$$

$$
\frac{\partial \eta}{\partial t} + H\left(\frac{\partial u}{\partial x} + \frac{\partial v}{\partial y}\right) = 0
$$

where:
- $u, v$ = velocity components
- $\eta$ = surface elevation
- $f$ = Coriolis parameter
- $g$ = gravity
- $H$ = mean depth

This system supports two types of motion:
1. **Slow geostrophic flow** - balanced flow satisfying $fv = g\partial\eta/\partial x$
2. **Fast inertia-gravity waves** - oscillations with frequency $\omega^2 = f^2 + c^2(k_x^2 + k_y^2)$

The challenge: **How do we separate these efficiently?**

---

## Solution: Temporal Filtering

Instead of explicit trajectory tracking, we use **exponential temporal filters** that run alongside the simulation. The Butterworth filter provides sharp frequency separation with only two auxiliary arrays per filtered field.

### Wave-Mean Decomposition

After filtering:
```
u = ū + u&#39;     (mean + wave fluctuation)
```

The mean $\bar{u}$ captures the slow geostrophic motion, while $u&#39;$ contains the fast wave oscillations.

---

## Complete Example Code

```julia
using Tarang
using Statistics: mean

# =============================================================================
# ROTATING SHALLOW WATER MODEL WITH LAGRANGIAN MEAN COMPUTATION
# =============================================================================

# -----------------------------------------------------------------------------
# 1. Physical Parameters
# -----------------------------------------------------------------------------

# Domain
Lx, Ly = 2π, 2π        # Domain size
Nx, Ny = 128, 128      # Resolution

# Physical constants
f = 1.0                # Coriolis parameter
g = 10.0               # Gravity
H = 1.0                # Mean depth
ν = 0.001              # Viscosity (for numerical stability)

# Derived quantities
c = sqrt(g * H)        # Gravity wave phase speed
ω_min = f              # Minimum wave frequency (inertial)
T_inertial = 2π / f    # Inertial period

println(&quot;Physical parameters:&quot;)
println(&quot;  Gravity wave speed c = &quot;, c)
println(&quot;  Inertial period T = &quot;, round(T_inertial, digits=3))

# -----------------------------------------------------------------------------
# 2. Grid and Operators
# -----------------------------------------------------------------------------

dx, dy = Lx/Nx, Ly/Ny
x = [(i-1)*dx for i in 1:Nx]
y = [(j-1)*dy for j in 1:Ny]

# Spectral wavenumbers
kx = [i &lt;= Nx÷2+1 ? i-1 : i-Nx-1 for i in 1:Nx] .* (2π/Lx)
ky = [j &lt;= Ny÷2+1 ? j-1 : j-Ny-1 for j in 1:Ny] .* (2π/Ly)

# Preallocate FFT arrays
using FFTW
FFTW.set_num_threads(4)
plan_fft = plan_fft!(zeros(ComplexF64, Nx, Ny))
plan_ifft = plan_ifft!(zeros(ComplexF64, Nx, Ny))

# Derivative operators in spectral space
function spectral_gradient!(dfdx, dfdy, f_hat, kx, ky)
    @inbounds for j in 1:size(f_hat, 2), i in 1:size(f_hat, 1)
        dfdx[i,j] = im * kx[i] * f_hat[i,j]
        dfdy[i,j] = im * ky[j] * f_hat[i,j]
    end
end

# -----------------------------------------------------------------------------
# 3. Initialize Fields
# -----------------------------------------------------------------------------

# Velocity and elevation
u = zeros(Nx, Ny)
v = zeros(Nx, Ny)
η = zeros(Nx, Ny)

# Work arrays
u_hat = zeros(ComplexF64, Nx, Ny)
v_hat = zeros(ComplexF64, Nx, Ny)
η_hat = zeros(ComplexF64, Nx, Ny)

# Temporary arrays for derivatives
dudx = zeros(ComplexF64, Nx, Ny)
dudy = zeros(ComplexF64, Nx, Ny)
dvdx = zeros(ComplexF64, Nx, Ny)
dvdy = zeros(ComplexF64, Nx, Ny)
dηdx = zeros(ComplexF64, Nx, Ny)
dηdy = zeros(ComplexF64, Nx, Ny)

# Initial condition: Geostrophic jet + wave perturbation
for i in 1:Nx, j in 1:Ny
    # Background geostrophic jet
    u[i,j] = 0.5 * sin(y[j])
    v[i,j] = 0.0
    η[i,j] = -(f/g) * 0.5 * cos(y[j])  # Geostrophic balance

    # Add wave perturbation (k=2, l=2 mode)
    k_wave, l_wave = 2.0, 2.0
    ω_wave = sqrt(f^2 + c^2 * (k_wave^2 + l_wave^2))
    amplitude = 0.1
    η[i,j] += amplitude * cos(k_wave * x[i] + l_wave * y[j])
end

println(&quot;\nInitial condition:&quot;)
println(&quot;  Geostrophic jet: U = 0.5 sin(y)&quot;)
println(&quot;  Wave perturbation: amplitude = 0.1&quot;)

# -----------------------------------------------------------------------------
# 4. Setup Temporal Filters
# -----------------------------------------------------------------------------

# Filter timescale: average over ~20 wave periods
T_wave = 2π / sqrt(f^2 + c^2 * 4)  # Wave period for k=l=2
α = 1.0 / (20 * T_wave)            # Filter parameter

println(&quot;\nFilter setup:&quot;)
println(&quot;  Wave period T_wave = &quot;, round(T_wave, digits=3))
println(&quot;  Filter timescale 1/α = &quot;, round(1/α, digits=1))

# Create filters for each prognostic variable
u_filter = ButterworthFilter((Nx, Ny); α=α)
v_filter = ButterworthFilter((Nx, Ny); α=α)
η_filter = ButterworthFilter((Nx, Ny); α=α)

# Precompute ETD coefficients for unconditional stability
dt = 0.01  # Time step
etd_coeffs_u = precompute_etd_coefficients(u_filter, dt)
etd_coeffs_v = precompute_etd_coefficients(v_filter, dt)
etd_coeffs_η = precompute_etd_coefficients(η_filter, dt)

println(&quot;  Using ETD integration (unconditionally stable)&quot;)
println(&quot;  α·dt = &quot;, round(α * dt, digits=4))

# -----------------------------------------------------------------------------
# 5. Time Integration (RK4 for dynamics, ETD for filters)
# -----------------------------------------------------------------------------

function rhs!(du, dv, dη, u, v, η, u_hat, v_hat, η_hat,
              dudx, dudy, dvdx, dvdy, dηdx, dηdy,
              plan_fft, plan_ifft, kx, ky, f, g, H, ν)

    # Transform to spectral space
    u_hat .= u
    v_hat .= v
    η_hat .= η
    plan_fft * u_hat
    plan_fft * v_hat
    plan_fft * η_hat

    # Compute gradients
    spectral_gradient!(dudx, dudy, u_hat, kx, ky)
    spectral_gradient!(dvdx, dvdy, v_hat, kx, ky)
    spectral_gradient!(dηdx, dηdy, η_hat, kx, ky)

    # Transform derivatives back
    plan_ifft * dudx
    plan_ifft * dudy
    plan_ifft * dvdx
    plan_ifft * dvdy
    plan_ifft * dηdx
    plan_ifft * dηdy

    # RHS of shallow water equations
    @inbounds for j in 1:size(u, 2), i in 1:size(u, 1)
        # Nonlinear advection
        adv_u = u[i,j] * real(dudx[i,j]) + v[i,j] * real(dudy[i,j])
        adv_v = u[i,j] * real(dvdx[i,j]) + v[i,j] * real(dvdy[i,j])

        # Momentum equations
        du[i,j] = f * v[i,j] - g * real(dηdx[i,j]) - adv_u
        dv[i,j] = -f * u[i,j] - g * real(dηdy[i,j]) - adv_v

        # Continuity equation
        dη[i,j] = -H * (real(dudx[i,j]) + real(dvdy[i,j]))
    end

    # Add viscous damping in spectral space for stability
    if ν &gt; 0
        u_hat .= u
        v_hat .= v
        plan_fft * u_hat
        plan_fft * v_hat
        @inbounds for j in 1:size(u_hat, 2), i in 1:size(u_hat, 1)
            k2 = kx[i]^2 + ky[j]^2
            visc = -ν * k2
            u_hat[i,j] *= visc
            v_hat[i,j] *= visc
        end
        plan_ifft * u_hat
        plan_ifft * v_hat
        du .+= real.(u_hat)
        dv .+= real.(v_hat)
    end
end

# RK4 time stepper for dynamics
function step_rk4!(u, v, η, dt, args...)
    # Allocate RK stages
    k1_u, k1_v, k1_η = similar(u), similar(v), similar(η)
    k2_u, k2_v, k2_η = similar(u), similar(v), similar(η)
    k3_u, k3_v, k3_η = similar(u), similar(v), similar(η)
    k4_u, k4_v, k4_η = similar(u), similar(v), similar(η)
    u_tmp, v_tmp, η_tmp = similar(u), similar(v), similar(η)

    # k1
    rhs!(k1_u, k1_v, k1_η, u, v, η, args...)

    # k2
    @. u_tmp = u + 0.5 * dt * k1_u
    @. v_tmp = v + 0.5 * dt * k1_v
    @. η_tmp = η + 0.5 * dt * k1_η
    rhs!(k2_u, k2_v, k2_η, u_tmp, v_tmp, η_tmp, args...)

    # k3
    @. u_tmp = u + 0.5 * dt * k2_u
    @. v_tmp = v + 0.5 * dt * k2_v
    @. η_tmp = η + 0.5 * dt * k2_η
    rhs!(k3_u, k3_v, k3_η, u_tmp, v_tmp, η_tmp, args...)

    # k4
    @. u_tmp = u + dt * k3_u
    @. v_tmp = v + dt * k3_v
    @. η_tmp = η + dt * k3_η
    rhs!(k4_u, k4_v, k4_η, u_tmp, v_tmp, η_tmp, args...)

    # Update
    @. u += dt/6 * (k1_u + 2*k2_u + 2*k3_u + k4_u)
    @. v += dt/6 * (k1_v + 2*k2_v + 2*k3_v + k4_v)
    @. η += dt/6 * (k1_η + 2*k2_η + 2*k3_η + k4_η)
end

# -----------------------------------------------------------------------------
# 6. Main Time Loop
# -----------------------------------------------------------------------------

T_final = 100.0        # Total simulation time
nsteps = Int(T_final / dt)
output_interval = Int(1.0 / dt)  # Output every 1 time unit

# Diagnostics storage
times = Float64[]
KE_total = Float64[]
KE_mean = Float64[]
KE_wave = Float64[]
PE_total = Float64[]

println(&quot;\n&quot; * &quot;=&quot;^60)
println(&quot;Starting simulation...&quot;)
println(&quot;=&quot;^60)

for step in 1:nsteps
    t = step * dt

    # Step dynamics (RK4)
    step_rk4!(u, v, η, dt,
              u_hat, v_hat, η_hat,
              dudx, dudy, dvdx, dvdy, dηdx, dηdy,
              plan_fft, plan_ifft, kx, ky, f, g, H, ν)

    # Update filters (ETD - unconditionally stable)
    update_etd!(u_filter, u, etd_coeffs_u)
    update_etd!(v_filter, v, etd_coeffs_v)
    update_etd!(η_filter, η, etd_coeffs_η)

    # Output diagnostics
    if step % output_interval == 0
        # Get filtered means
        ū = get_mean(u_filter)
        v̄ = get_mean(v_filter)
        η̄ = get_mean(η_filter)

        # Wave components
        u_wave = u .- ū
        v_wave = v .- v̄
        η_wave = η .- η̄

        # Energy diagnostics
        ke_total = 0.5 * mean(u.^2 .+ v.^2)
        ke_mean = 0.5 * mean(ū.^2 .+ v̄.^2)
        ke_wave = 0.5 * mean(u_wave.^2 .+ v_wave.^2)
        pe_total = 0.5 * g/H * mean(η.^2)

        push!(times, t)
        push!(KE_total, ke_total)
        push!(KE_mean, ke_mean)
        push!(KE_wave, ke_wave)
        push!(PE_total, pe_total)

        @printf(&quot;t = %6.2f | KE_total = %.4e | KE_mean = %.4e | KE_wave = %.4e\n&quot;,
                t, ke_total, ke_mean, ke_wave)
    end
end

# -----------------------------------------------------------------------------
# 7. Final Analysis
# -----------------------------------------------------------------------------

println(&quot;\n&quot; * &quot;=&quot;^60)
println(&quot;Simulation complete!&quot;)
println(&quot;=&quot;^60)

# Final wave-mean decomposition
ū = get_mean(u_filter)
v̄ = get_mean(v_filter)
η̄ = get_mean(η_filter)

u_wave = u .- ū
v_wave = v .- v̄
η_wave = η .- η̄

println(&quot;\nFinal state statistics:&quot;)
println(&quot;  Mean flow:&quot;)
println(&quot;    max|ū| = &quot;, round(maximum(abs.(ū)), digits=4))
println(&quot;    max|v̄| = &quot;, round(maximum(abs.(v̄)), digits=4))
println(&quot;    max|η̄| = &quot;, round(maximum(abs.(η̄)), digits=4))

println(&quot;  Wave fluctuations:&quot;)
println(&quot;    max|u&#39;| = &quot;, round(maximum(abs.(u_wave)), digits=4))
println(&quot;    max|v&#39;| = &quot;, round(maximum(abs.(v_wave)), digits=4))
println(&quot;    max|η&#39;| = &quot;, round(maximum(abs.(η_wave)), digits=4))

println(&quot;\nEnergy partition:&quot;)
ke_final_total = 0.5 * mean(u.^2 .+ v.^2)
ke_final_mean = 0.5 * mean(ū.^2 .+ v̄.^2)
ke_final_wave = 0.5 * mean(u_wave.^2 .+ v_wave.^2)
println(&quot;  Total KE:     &quot;, round(ke_final_total, digits=6))
println(&quot;  Mean flow KE: &quot;, round(ke_final_mean, digits=6),
        &quot; (&quot;, round(100*ke_final_mean/ke_final_total, digits=1), &quot;%)&quot;)
println(&quot;  Wave KE:      &quot;, round(ke_final_wave, digits=6),
        &quot; (&quot;, round(100*ke_final_wave/ke_final_total, digits=1), &quot;%)&quot;)
```

---

## Understanding the Output

### Energy Partition

The simulation separates kinetic energy into:
- **Mean flow KE**: Energy in slow, filtered geostrophic motion
- **Wave KE**: Energy in fast inertia-gravity oscillations

Typical output after spinup:
```
Energy partition:
  Total KE:     0.062500
  Mean flow KE: 0.050000 (80.0%)
  Wave KE:      0.012500 (20.0%)
```

### Wave-Mean Decomposition

The filtered mean $\bar{u}$ should recover the initial geostrophic jet:
```julia
# Expected: ū ≈ 0.5 sin(y) (the background jet)
# Expected: v̄ ≈ 0 (no mean meridional flow)
```

---

## Time Integration Methods

### Method 1: Explicit Euler (not recommended)

```julia
update!(filter, field, dt)  # Forward Euler
```
**Stability limit**: $\Delta t \leq \sqrt{2}/\alpha$

### Method 2: RK2 (moderate stability)

```julia
update!(filter, field, dt, Val(:RK2))
```
**Stability limit**: $\Delta t \leq 2\sqrt{2}/\alpha$

### Method 3: ETD (recommended - unconditionally stable)

```julia
coeffs = precompute_etd_coefficients(filter, dt)
update_etd!(filter, field, coeffs)
```
**No stability limit!** Can use any timestep.

### Method 4: IMEX/SBDF (for implicit PDE solvers)

```julia
coeffs = precompute_imex_coefficients(filter, dt; scheme=:SBDF2)
update_imex!(filter, (h_n, h_nm1), coeffs)
```
**No stability limit!** Integrates naturally with SBDF timestepping.

---

## Choosing Filter Parameters

### The key parameter: α

$$\alpha = \frac{1}{T_{\text{avg}}}\]</p><p><strong>Rule of thumb</strong>: <span>$T_{\text{avg}} \approx 10$</span>-<span>$100 \times T_{\text{wave}}$</span></p><table><tr><th style="text-align: right">Waves to filter</th><th style="text-align: right">Wave period</th><th style="text-align: right">Recommended α</th></tr><tr><td style="text-align: right">Inertia-gravity waves</td><td style="text-align: right"><span>$2\pi/\sqrt{f^2 + c^2 k^2}$</span></td><td style="text-align: right"><span>$\alpha = 0.05$</span>-<span>$0.1 \times$</span> wave frequency</td></tr><tr><td style="text-align: right">Near-inertial waves</td><td style="text-align: right"><span>$2\pi/f$</span></td><td style="text-align: right"><span>$\alpha \approx f/50$</span></td></tr><tr><td style="text-align: right">Internal gravity waves</td><td style="text-align: right"><span>$2\pi/N$</span></td><td style="text-align: right"><span>$\alpha \approx N/100$</span></td></tr></table><h3 id="Filter-comparison"><a class="docs-heading-anchor" href="#Filter-comparison">Filter comparison</a><a id="Filter-comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Filter-comparison" title="Permalink"></a></h3><table><tr><th style="text-align: right">Filter</th><th style="text-align: right">High-freq rolloff</th><th style="text-align: right">Memory</th><th style="text-align: right">Use case</th></tr><tr><td style="text-align: right"><code>ExponentialMean</code></td><td style="text-align: right">-20 dB/decade</td><td style="text-align: right">1 array</td><td style="text-align: right">Simple averaging</td></tr><tr><td style="text-align: right"><code>ButterworthFilter</code></td><td style="text-align: right">-40 dB/decade</td><td style="text-align: right">2 arrays</td><td style="text-align: right">Sharp wave-mean separation</td></tr></table><hr/><h2 id="Extensions"><a class="docs-heading-anchor" href="#Extensions">Extensions</a><a id="Extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Extensions" title="Permalink"></a></h2><h3 id="Adding-Lagrangian-Averaging"><a class="docs-heading-anchor" href="#Adding-Lagrangian-Averaging">Adding Lagrangian Averaging</a><a id="Adding-Lagrangian-Averaging-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Lagrangian-Averaging" title="Permalink"></a></h3><p>For true Lagrangian mean (following particle motion):</p><pre><code class="language-julia hljs"># Create Lagrangian filter
lag_filter = LagrangianFilter((Nx, Ny);
    α=α,
    filter_type=:butterworth
)

# In time loop:
update_displacement!(lag_filter, (u, v), dt)

# Get Lagrangian mean velocity
ū_L = get_mean_velocity(lag_filter)

# Compute Lagrangian mean of a tracer
θ_L = zeros(Nx, Ny)
lagrangian_mean!(lag_filter, θ_L, tracer, dt)</code></pre><h3 id="Computing-Stokes-Drift"><a class="docs-heading-anchor" href="#Computing-Stokes-Drift">Computing Stokes Drift</a><a id="Computing-Stokes-Drift-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Stokes-Drift" title="Permalink"></a></h3><p>The Stokes drift is the difference between Lagrangian and Eulerian means:</p><pre><code class="language-julia hljs">u_stokes = ū_L - ū_E  # Lagrangian mean - Eulerian mean</code></pre><p>This captures wave-induced transport important for:</p><ul><li>Pollutant dispersion</li><li>Larval transport in oceans</li><li>Sea ice drift</li></ul><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ol><li><p><strong>Minz, C., Baker, L. E., Kafiabad, H. A., &amp; Vanneste, J.</strong> (2025). Efficient Lagrangian averaging with exponential filters. <em>Phys. Rev. Fluids</em>, 10, 074902. <a href="https://doi.org/10.1103/PhysRevFluids.10.074902">DOI</a></p></li><li><p><strong>Vallis, G. K.</strong> (2017). <em>Atmospheric and Oceanic Fluid Dynamics</em> (2nd ed.). Cambridge University Press. Chapter 3: Shallow water systems.</p></li><li><p><strong>Bühler, O.</strong> (2014). <em>Waves and Mean Flows</em> (2nd ed.). Cambridge University Press.</p></li></ol><hr/><h2 id="Next-Steps"><a class="docs-heading-anchor" href="#Next-Steps">Next Steps</a><a id="Next-Steps-1"></a><a class="docs-heading-anchor-permalink" href="#Next-Steps" title="Permalink"></a></h2><ul><li><a href="../../pages/temporal_filters/">Temporal Filters Reference</a> - Complete API documentation</li><li><a href="../../pages/les_models/">LES Models</a> - Subgrid-scale modeling for turbulence</li><li><a href="../surface_dynamics/">Surface Dynamics</a> - SQG and other surface-confined flows</li></ul><hr/><p><em>Tutorial version 1.0 | December 2024 | Tarang.jl</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../surface_dynamics/">« Surface Dynamics</a><a class="docs-footer-nextpage" href="../../examples/gallery/">Examples Gallery »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 25 January 2026 13:18">Sunday 25 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
