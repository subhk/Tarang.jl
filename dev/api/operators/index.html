<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Operators API · Tarang.jl</title><meta name="title" content="Operators API · Tarang.jl"/><meta property="og:title" content="Operators API · Tarang.jl"/><meta property="twitter:title" content="Operators API · Tarang.jl"/><meta name="description" content="Documentation for Tarang.jl."/><meta property="og:description" content="Documentation for Tarang.jl."/><meta property="twitter:description" content="Documentation for Tarang.jl."/><meta property="og:url" content="https://subhk.github.io/Tarang.jl/api/operators/"/><meta property="twitter:url" content="https://subhk.github.io/Tarang.jl/api/operators/"/><link rel="canonical" href="https://subhk.github.io/Tarang.jl/api/operators/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Tarang.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Tarang.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Installing Tarang</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../getting_started/installation/">Installation</a></li><li><a class="tocitem" href="../../getting_started/first_steps/">First Steps with Tarang.jl</a></li><li><a class="tocitem" href="../../getting_started/running_with_mpi/">Running with MPI</a></li><li><a class="tocitem" href="../../pages/configuration/">Configuration</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials &amp; Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Tutorial Notebooks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/overview/">Tutorials Overview</a></li><li><a class="tocitem" href="../../tutorials/ivp_2d_rbc/">Tutorial: 2D Rayleigh-Bénard Convection</a></li><li><a class="tocitem" href="../../tutorials/ivp_3d_turbulence/">Tutorial: 3D Turbulence Simulation</a></li><li><a class="tocitem" href="../../tutorials/boundary_conditions/">Tutorial: Boundary Conditions</a></li><li><a class="tocitem" href="../../tutorials/analysis_and_output/">Tutorial: Analysis and Output</a></li><li><a class="tocitem" href="../../tutorials/eigenvalue_problems/">Tutorial: Eigenvalue Problems</a></li><li><a class="tocitem" href="../../tutorials/surface_dynamics/">Surface and Boundary Dynamics</a></li><li><a class="tocitem" href="../../tutorials/rotating_shallow_water/">Rotating Shallow Water with Lagrangian Averaging</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Example Scripts</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../examples/gallery/">Example Gallery</a></li><li><a class="tocitem" href="../../examples/fluid_dynamics/">Fluid Dynamics Examples</a></li><li><a class="tocitem" href="../../examples/heat_transfer/">Heat Transfer Examples</a></li><li><a class="tocitem" href="../../examples/eigenvalue_analysis/">Eigenvalue Analysis Examples</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Jupyter Notebooks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../notebooks/rayleigh_benard/">Notebook: Rayleigh-Bénard Convection</a></li><li><a class="tocitem" href="../../notebooks/channel_flow/">Notebook: Channel Flow</a></li><li><a class="tocitem" href="../../notebooks/taylor_green/">Notebook: Taylor-Green Vortex</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Core Concepts</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../pages/coordinates/">Coordinates</a></li><li><a class="tocitem" href="../../pages/bases/">Spectral Bases</a></li><li><a class="tocitem" href="../../pages/domains/">Domains</a></li><li><a class="tocitem" href="../../pages/fields/">Fields</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Problem Setup</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../pages/operators/">Operators</a></li><li><a class="tocitem" href="../../pages/problems/">Problems</a></li><li><a class="tocitem" href="../../pages/solvers/">Solvers</a></li><li><a class="tocitem" href="../../pages/timesteppers/">Time Steppers</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Physics &amp; Modeling</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../pages/stochastic_forcing/">Stochastic Forcing</a></li><li><a class="tocitem" href="../../pages/temporal_filters/">Temporal Filters for Lagrangian Averaging</a></li><li><a class="tocitem" href="../../pages/les_models/">Large Eddy Simulation (LES) Models</a></li><li><a class="tocitem" href="../../pages/gql_approximation/">Generalized Quasi-Linear (GQL) Approximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Performance &amp; Parallelism</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../pages/gpu_computing/">GPU Computing</a></li><li><a class="tocitem" href="../../pages/parallelism/">Parallelism</a></li><li><a class="tocitem" href="../../pages/optimization/">Performance Optimization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Analysis &amp; Output</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../pages/analysis/">Analysis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Advanced Topics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../pages/tau_method/">The Tau Method for Boundary Conditions</a></li><li><a class="tocitem" href="../../pages/custom_operators/">Custom Operators</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Core</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../coordinates/">Coordinates API</a></li><li><a class="tocitem" href="../bases/">Bases API</a></li><li><a class="tocitem" href="../domains/">Domains API</a></li><li><a class="tocitem" href="../fields/">Fields API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox" checked/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Operators &amp; Problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Operators API</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Unicode-Operators"><span>Unicode Operators</span></a></li><li><a class="tocitem" href="#Differential-Operators"><span>Differential Operators</span></a></li><li><a class="tocitem" href="#Coordinate-Derivatives"><span>Coordinate Derivatives</span></a></li><li><a class="tocitem" href="#Time-Derivatives"><span>Time Derivatives</span></a></li><li><a class="tocitem" href="#Vector-Operations"><span>Vector Operations</span></a></li><li><a class="tocitem" href="#Composite-Operators"><span>Composite Operators</span></a></li><li><a class="tocitem" href="#Operator-Properties"><span>Operator Properties</span></a></li><li><a class="tocitem" href="#Custom-Operators"><span>Custom Operators</span></a></li><li><a class="tocitem" href="#Equation-Parsing"><span>Equation Parsing</span></a></li><li><a class="tocitem" href="#Performance-Tips"><span>Performance Tips</span></a></li><li><a class="tocitem" href="#See-Also"><span>See Also</span></a></li></ul></li><li><a class="tocitem" href="../problems/">Problems API</a></li><li><a class="tocitem" href="../solvers/">Solvers API</a></li><li><a class="tocitem" href="../timesteppers/">Timesteppers API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">GPU &amp; Performance</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../gpu/">GPU API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">Extras</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../stochastic_forcing/">Stochastic Forcing API</a></li><li><a class="tocitem" href="../les_models/">LES Models API</a></li><li><a class="tocitem" href="../analysis/">Analysis API</a></li><li><a class="tocitem" href="../io/">I/O API</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../pages/contributing/">Contributing</a></li><li><a class="tocitem" href="../../pages/architecture/">Architecture</a></li><li><a class="tocitem" href="../../pages/testing/">Testing</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li><a class="is-disabled">Operators &amp; Problems</a></li><li class="is-active"><a href>Operators API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Operators API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/subhk/Tarang.jl/blob/main/docs/src/api/operators.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Operators-API"><a class="docs-heading-anchor" href="#Operators-API">Operators API</a><a id="Operators-API-1"></a><a class="docs-heading-anchor-permalink" href="#Operators-API" title="Permalink"></a></h1><p>Operators compute derivatives and other mathematical operations on fields. Tarang.jl provides a symbolic syntax for natural mathematical notation in equations.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Tarang.jl supports:</p><ul><li><strong>Differential operators</strong>: grad (∇), div, curl, lap (Δ, ∇²)</li><li><strong>Coordinate derivatives</strong>: ∂x, ∂y, ∂z, ∂r, etc.</li><li><strong>Time derivatives</strong>: ∂t</li><li><strong>Field operations</strong>: dot (⋅), cross (×)</li><li><strong>Custom operators</strong>: User-defined operations</li></ul><h2 id="Unicode-Operators"><a class="docs-heading-anchor" href="#Unicode-Operators">Unicode Operators</a><a id="Unicode-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Unicode-Operators" title="Permalink"></a></h2><p>Tarang.jl uses Unicode mathematical symbols for readable, publication-quality code:</p><table><tr><th style="text-align: right">Syntax</th><th style="text-align: right">Description</th><th style="text-align: right">Typing</th></tr><tr><td style="text-align: right"><code>∇(f)</code></td><td style="text-align: right">Gradient</td><td style="text-align: right"><code>\nabla</code> Tab</td></tr><tr><td style="text-align: right"><code>Δ(f)</code> or <code>∇²(f)</code></td><td style="text-align: right">Laplacian</td><td style="text-align: right"><code>\Delta</code> Tab</td></tr><tr><td style="text-align: right"><code>∂t(f)</code></td><td style="text-align: right">Time derivative</td><td style="text-align: right"><code>\partial</code> Tab <code>t</code></td></tr><tr><td style="text-align: right"><code>∂x(f)</code></td><td style="text-align: right">x-derivative</td><td style="text-align: right"><code>\partial</code> Tab <code>x</code></td></tr><tr><td style="text-align: right"><code>∂y(f)</code></td><td style="text-align: right">y-derivative</td><td style="text-align: right"><code>\partial</code> Tab <code>y</code></td></tr><tr><td style="text-align: right"><code>∂z(f)</code></td><td style="text-align: right">z-derivative</td><td style="text-align: right"><code>\partial</code> Tab <code>z</code></td></tr><tr><td style="text-align: right"><code>∂r(f)</code></td><td style="text-align: right">r-derivative</td><td style="text-align: right"><code>\partial</code> Tab <code>r</code></td></tr><tr><td style="text-align: right"><code>u ⋅ v</code></td><td style="text-align: right">Dot product</td><td style="text-align: right"><code>\cdot</code> Tab</td></tr><tr><td style="text-align: right"><code>u × v</code></td><td style="text-align: right">Cross product</td><td style="text-align: right"><code>\times</code> Tab</td></tr></table><p><strong>Example</strong> - Navier-Stokes equation:</p><pre><code class="language-julia hljs">add_equation!(problem, &quot;∂t(u) + u⋅∇(u) = -∇(p) + nu*Δ(u)&quot;)</code></pre><p><strong>Typing Unicode in Julia</strong>:</p><ul><li><code>∇</code> : Type <code>\nabla</code> then press Tab</li><li><code>Δ</code> : Type <code>\Delta</code> then press Tab</li><li><code>∂t</code> : Type <code>\partial</code> Tab <code>\_t</code> Tab</li><li><code>∂x</code> : Type <code>\partial</code> Tab <code>x</code></li><li><code>⋅</code> : Type <code>\cdot</code> then press Tab</li><li><code>×</code> : Type <code>\times</code> then press Tab</li></ul><hr/><h2 id="Differential-Operators"><a class="docs-heading-anchor" href="#Differential-Operators">Differential Operators</a><a id="Differential-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Differential-Operators" title="Permalink"></a></h2><h3 id="Gradient-(grad-/-)"><a class="docs-heading-anchor" href="#Gradient-(grad-/-)">Gradient (grad / ∇)</a><a id="Gradient-(grad-/-)-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-(grad-/-)" title="Permalink"></a></h3><p>Computes the gradient of a scalar field, returning a vector field.</p><p><strong>Syntax</strong>:</p><pre><code class="language-julia hljs"># In equations
add_equation!(problem, &quot;∇(p)&quot;)  # or &quot;grad(p)&quot;

# Programmatic
∇p = ∇(p)  # or grad(p)</code></pre><p><strong>Definitions</strong>:</p><p><strong>Cartesian</strong>:</p><p class="math-container">\[\nabla p = \frac{\partial p}{\partial x}\hat{x} + \frac{\partial p}{\partial y}\hat{y} + \frac{\partial p}{\partial z}\hat{z}\]</p><p><strong>Spherical</strong>:</p><p class="math-container">\[\nabla p = \frac{\partial p}{\partial r}\hat{r} + \frac{1}{r}\frac{\partial p}{\partial \theta}\hat{\theta} + \frac{1}{r\sin\theta}\frac{\partial p}{\partial \phi}\hat{\phi}\]</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs"># 2D gradient
coords = CartesianCoordinates(&quot;x&quot;, &quot;z&quot;)
problem = IVP([u, w, p])

# Pressure gradient in momentum equation
add_equation!(problem, &quot;∂t(u) = -∇(p)&quot;)

# Expands to:
# ∂t(u_x) = -∂x(p)
# ∂t(u_z) = -∂z(p)</code></pre><pre><code class="language-julia hljs"># 3D gradient with custom usage
∇T = ∇(T)  # Returns VectorField
# Components: ∇T.components[1] = ∂x(T), etc.</code></pre><p><strong>Return type</strong>: VectorField</p><hr/><h3 id="Divergence-(div)"><a class="docs-heading-anchor" href="#Divergence-(div)">Divergence (div)</a><a id="Divergence-(div)-1"></a><a class="docs-heading-anchor-permalink" href="#Divergence-(div)" title="Permalink"></a></h3><p>Computes the divergence of a vector field, returning a scalar field.</p><p><strong>Syntax</strong>:</p><pre><code class="language-julia hljs"># In equations
add_equation!(problem, &quot;div(u) = 0&quot;)

# Programmatic
div_u = div(u)</code></pre><p><strong>Definitions</strong>:</p><p><strong>Cartesian</strong>:</p><p class="math-container">\[\nabla \cdot \mathbf{u} = \frac{\partial u_x}{\partial x} + \frac{\partial u_y}{\partial y} + \frac{\partial u_z}{\partial z}\]</p><p><strong>Spherical</strong>:</p><p class="math-container">\[\nabla \cdot \mathbf{u} = \frac{1}{r^2}\frac{\partial (r^2 u_r)}{\partial r} + \frac{1}{r\sin\theta}\frac{\partial (\sin\theta\, u_\theta)}{\partial \theta} + \frac{1}{r\sin\theta}\frac{\partial u_\phi}{\partial \phi}\]</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs"># Incompressibility constraint
problem = IVP([u, v, w, p])
add_equation!(problem, &quot;div(u) = 0&quot;)</code></pre><pre><code class="language-julia hljs"># Mass conservation with source
add_equation!(problem, &quot;div(u) = S&quot;)</code></pre><p><strong>Return type</strong>: ScalarField</p><hr/><h3 id="Curl-(curl)"><a class="docs-heading-anchor" href="#Curl-(curl)">Curl (curl)</a><a id="Curl-(curl)-1"></a><a class="docs-heading-anchor-permalink" href="#Curl-(curl)" title="Permalink"></a></h3><p>Computes the curl of a vector field, returning a vector field.</p><p><strong>Syntax</strong>:</p><pre><code class="language-julia hljs"># In equations
add_equation!(problem, &quot;omega = curl(u)&quot;)

# Programmatic
ω = curl(u)</code></pre><p><strong>Definitions</strong>:</p><p><strong>Cartesian (3D)</strong>:</p><p class="math-container">\[\nabla \times \mathbf{u} = \left(\frac{\partial u_z}{\partial y} - \frac{\partial u_y}{\partial z}\right)\hat{x} + \left(\frac{\partial u_x}{\partial z} - \frac{\partial u_z}{\partial x}\right)\hat{y} + \left(\frac{\partial u_y}{\partial x} - \frac{\partial u_x}{\partial y}\right)\hat{z}\]</p><p><strong>2D (returns scalar vorticity)</strong>:</p><p class="math-container">\[\omega = \frac{\partial v}{\partial x} - \frac{\partial u}{\partial y}\]</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs"># Vorticity equation (3D)
problem = IVP([u, omega])
add_equation!(problem, &quot;∂t(omega) = curl(u × omega)&quot;)</code></pre><pre><code class="language-julia hljs"># 2D vorticity
coords = CartesianCoordinates(&quot;x&quot;, &quot;y&quot;)
problem = IVP([u, v, omega])
add_equation!(problem, &quot;omega = ∂x(v) - ∂y(u)&quot;)</code></pre><p><strong>Return type</strong>: VectorField (3D) or ScalarField (2D)</p><hr/><h3 id="Laplacian-(lap)"><a class="docs-heading-anchor" href="#Laplacian-(lap)">Laplacian (lap)</a><a id="Laplacian-(lap)-1"></a><a class="docs-heading-anchor-permalink" href="#Laplacian-(lap)" title="Permalink"></a></h3><p>Computes the Laplacian (second derivative) of a field.</p><p><strong>Syntax</strong>:</p><pre><code class="language-julia hljs"># In equations
add_equation!(problem, &quot;∂t(T) = kappa*Δ(T)&quot;)

# Programmatic
∇²T = Δ(T)</code></pre><p><strong>Definitions</strong>:</p><p><strong>Cartesian</strong>:</p><p class="math-container">\[\nabla^2 f = \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2} + \frac{\partial^2 f}{\partial z^2}\]</p><p><strong>Spherical</strong>:</p><p class="math-container">\[\nabla^2 f = \frac{1}{r^2}\frac{\partial}{\partial r}\left(r^2\frac{\partial f}{\partial r}\right) + \frac{1}{r^2\sin\theta}\frac{\partial}{\partial \theta}\left(\sin\theta\frac{\partial f}{\partial \theta}\right) + \frac{1}{r^2\sin^2\theta}\frac{\partial^2 f}{\partial \phi^2}\]</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs"># Diffusion equation
add_equation!(problem, &quot;∂t(T) = kappa*Δ(T)&quot;)</code></pre><pre><code class="language-julia hljs"># Viscous term in Navier-Stokes
add_equation!(problem, &quot;∂t(u) = nu*Δ(u) - ∇(p)&quot;)</code></pre><pre><code class="language-julia hljs"># Poisson equation (BVP)
problem = LBVP([phi])
add_equation!(problem, &quot;Δ(phi) = rho&quot;)</code></pre><p><strong>Works on</strong>: ScalarField, VectorField (applies componentwise)</p><hr/><h2 id="Coordinate-Derivatives"><a class="docs-heading-anchor" href="#Coordinate-Derivatives">Coordinate Derivatives</a><a id="Coordinate-Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Coordinate-Derivatives" title="Permalink"></a></h2><h3 id="First-Derivatives"><a class="docs-heading-anchor" href="#First-Derivatives">First Derivatives</a><a id="First-Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#First-Derivatives" title="Permalink"></a></h3><p>Partial derivatives with respect to coordinate directions.</p><p><strong>Syntax</strong>:</p><pre><code class="language-julia hljs">∂x(field)   # ∂/∂x
∂y(field)   # ∂/∂y
∂z(field)   # ∂/∂z
∂r(field)   # ∂/∂r (spherical/polar)
∂θ(field)   # ∂/∂θ
∂φ(field)   # ∂/∂φ</code></pre><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs"># Advection term
add_equation!(problem, &quot;∂t(T) = -u*∂x(T) - w*∂z(T)&quot;)</code></pre><pre><code class="language-julia hljs"># Shear
add_equation!(problem, &quot;S = ∂x(u) + ∂z(w)&quot;)</code></pre><pre><code class="language-julia hljs"># Custom derivative
dudz = ∂z(u)  # Returns field with ∂u/∂z</code></pre><p><strong>Implementation</strong>:</p><ul><li><strong>Fourier</strong>: Multiplication by ik in spectral space</li><li><strong>Chebyshev/Legendre</strong>: Sparse matrix multiplication using recurrence relations</li></ul><hr/><h3 id="Higher-Derivatives"><a class="docs-heading-anchor" href="#Higher-Derivatives">Higher Derivatives</a><a id="Higher-Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Higher-Derivatives" title="Permalink"></a></h3><p>Multiple derivatives can be composed:</p><p><strong>Syntax</strong>:</p><pre><code class="language-julia hljs"># Second derivatives
∂x(∂x(T))   # ∂²T/∂x²
∂z(∂z(T))   # ∂²T/∂z²

# Mixed derivatives
∂x(∂z(T))   # ∂²T/∂x∂z

# Higher order
∂x(∂x(∂x(T)))  # ∂³T/∂x³</code></pre><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs"># Biharmonic operator
add_equation!(problem, &quot;Δ(Δ(psi)) = omega&quot;)

# Equivalent to:
add_equation!(problem, &quot;∂x(∂x(∂x(∂x(psi)))) + 2*∂x(∂x(∂z(∂z(psi)))) + ∂z(∂z(∂z(∂z(psi)))) = omega&quot;)</code></pre><pre><code class="language-julia hljs"># Hyperdiffusion (for numerical stability)
add_equation!(problem, &quot;∂t(T) = -nu4*Δ(Δ(T))&quot;)</code></pre><hr/><h2 id="Time-Derivatives"><a class="docs-heading-anchor" href="#Time-Derivatives">Time Derivatives</a><a id="Time-Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Derivatives" title="Permalink"></a></h2><h3 id="dt-/-t-Operator"><a class="docs-heading-anchor" href="#dt-/-t-Operator">dt / ∂t Operator</a><a id="dt-/-t-Operator-1"></a><a class="docs-heading-anchor-permalink" href="#dt-/-t-Operator" title="Permalink"></a></h3><p>Time derivative for initial value problems.</p><p><strong>Syntax</strong>:</p><pre><code class="language-julia hljs">dt(field)   # ASCII
∂t(field)   # Unicode (type \partial Tab \_t Tab)</code></pre><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs"># Evolution equations
add_equation!(problem, &quot;∂t(u) = -u*∂x(u) + nu*Δ(u)&quot;)
add_equation!(problem, &quot;∂t(T) = -u*∂x(T) + kappa*Δ(T)&quot;)</code></pre><p><strong>Note</strong>: Only use in IVP (Initial Value Problems). Not valid for BVP or EVP.</p><hr/><h2 id="Vector-Operations"><a class="docs-heading-anchor" href="#Vector-Operations">Vector Operations</a><a id="Vector-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-Operations" title="Permalink"></a></h2><h3 id="Dot-Product-/-Advection"><a class="docs-heading-anchor" href="#Dot-Product-/-Advection">Dot Product / Advection</a><a id="Dot-Product-/-Advection-1"></a><a class="docs-heading-anchor-permalink" href="#Dot-Product-/-Advection" title="Permalink"></a></h3><p><strong>Syntax</strong>:</p><pre><code class="language-julia hljs"># In equations - use vector notation directly
add_equation!(problem, &quot;∂t(T) = -u⋅∇(T)&quot;)

# For vector advection (nonlinear term)
add_equation!(problem, &quot;∂t(u) = -u⋅∇(u)&quot;)</code></pre><p><strong>Example</strong>:</p><pre><code class="language-julia hljs"># Scalar advection: -u·∇T
add_equation!(problem, &quot;∂t(T) = -u⋅∇(T)&quot;)

# Vector advection (Navier-Stokes nonlinear term)
add_equation!(problem, &quot;∂t(u) - nu*Δ(u) + ∇(p) = -u⋅∇(u)&quot;)</code></pre><hr/><h3 id="Cross-Product"><a class="docs-heading-anchor" href="#Cross-Product">Cross Product</a><a id="Cross-Product-1"></a><a class="docs-heading-anchor-permalink" href="#Cross-Product" title="Permalink"></a></h3><p><strong>Syntax</strong>:</p><pre><code class="language-julia hljs"># Use cross function or × operator
u_cross_omega = cross(u, omega)
u_cross_omega = u × omega  # Unicode: \times Tab</code></pre><p><strong>Example</strong>:</p><pre><code class="language-julia hljs"># Vorticity equation: ∂ω/∂t = ∇×(u×ω)
problem = IVP([ux, uy, uz, omega_x, omega_y, omega_z])

# Compute u × ω
u_cross_omega = cross(u, omega)
# Or equivalently:
u_cross_omega = u × omega

# Then: ∇×(u×ω)
add_equation!(problem, &quot;∂t(omega) = curl(u_cross_omega)&quot;)</code></pre><hr/><h2 id="Composite-Operators"><a class="docs-heading-anchor" href="#Composite-Operators">Composite Operators</a><a id="Composite-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-Operators" title="Permalink"></a></h2><p>Combine operators for complex expressions.</p><h3 id="Vector-Laplacian"><a class="docs-heading-anchor" href="#Vector-Laplacian">Vector Laplacian</a><a id="Vector-Laplacian-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-Laplacian" title="Permalink"></a></h3><pre><code class="language-julia hljs"># For vector field u
# ∇²u = (∇²u_x, ∇²u_y, ∇²u_z)

add_equation!(problem, &quot;∂t(u) = nu*Δ(u)&quot;)
# Automatically applies componentwise</code></pre><h3 id="Advection-Operator"><a class="docs-heading-anchor" href="#Advection-Operator">Advection Operator</a><a id="Advection-Operator-1"></a><a class="docs-heading-anchor-permalink" href="#Advection-Operator" title="Permalink"></a></h3><pre><code class="language-julia hljs"># u·∇u (nonlinear advection) - use vector notation directly

# Navier-Stokes momentum equation:
add_equation!(problem, &quot;∂t(u) - nu*Δ(u) + ∇(p) = -u⋅∇(u)&quot;)

# Scalar advection:
add_equation!(problem, &quot;∂t(T) - kappa*Δ(T) = -u⋅∇(T)&quot;)

# With buoyancy (Boussinesq):
add_equation!(problem, &quot;∂t(u) - nu*Δ(u) + ∇(p) = -u⋅∇(u) + Ra*T*ez&quot;)</code></pre><h3 id="Strain-Rate-Tensor"><a class="docs-heading-anchor" href="#Strain-Rate-Tensor">Strain Rate Tensor</a><a id="Strain-Rate-Tensor-1"></a><a class="docs-heading-anchor-permalink" href="#Strain-Rate-Tensor" title="Permalink"></a></h3><pre><code class="language-julia hljs"># S_ij = 1/2 (∂u_i/∂x_j + ∂u_j/∂x_i)

function strain_rate_tensor(u)
    # Returns TensorField
    S = TensorField(u.distributor, u.coords, &quot;S&quot;, u.bases, symmetric=true)

    S[1,1] = ∂x(u.components[1])
    S[1,2] = 0.5 * (∂x(u.components[2]) + ∂y(u.components[1]))
    S[2,2] = ∂y(u.components[2])
    # ... etc

    return S
end</code></pre><hr/><h2 id="Operator-Properties"><a class="docs-heading-anchor" href="#Operator-Properties">Operator Properties</a><a id="Operator-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-Properties" title="Permalink"></a></h2><h3 id="Linearity"><a class="docs-heading-anchor" href="#Linearity">Linearity</a><a id="Linearity-1"></a><a class="docs-heading-anchor-permalink" href="#Linearity" title="Permalink"></a></h3><p>All operators are linear:</p><pre><code class="language-julia hljs"># ∇(αf + βg) = α∇f + β∇g
∇(alpha*f + beta*g) == alpha*∇(f) + beta*∇(g)</code></pre><h3 id="Commutativity"><a class="docs-heading-anchor" href="#Commutativity">Commutativity</a><a id="Commutativity-1"></a><a class="docs-heading-anchor-permalink" href="#Commutativity" title="Permalink"></a></h3><p>Partial derivatives commute:</p><pre><code class="language-julia hljs"># ∂²f/∂x∂z = ∂²f/∂z∂x
∂x(∂z(f)) == ∂z(∂x(f))</code></pre><h3 id="Product-Rule"><a class="docs-heading-anchor" href="#Product-Rule">Product Rule</a><a id="Product-Rule-1"></a><a class="docs-heading-anchor-permalink" href="#Product-Rule" title="Permalink"></a></h3><pre><code class="language-julia hljs"># ∇(fg) = f∇g + g∇f
∇(f*g) == f*∇(g) + g*∇(f)</code></pre><hr/><h2 id="Custom-Operators"><a class="docs-heading-anchor" href="#Custom-Operators">Custom Operators</a><a id="Custom-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Operators" title="Permalink"></a></h2><h3 id="Defining-Helper-Functions"><a class="docs-heading-anchor" href="#Defining-Helper-Functions">Defining Helper Functions</a><a id="Defining-Helper-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Helper-Functions" title="Permalink"></a></h3><p>You can define helper functions that compose built-in operators:</p><pre><code class="language-julia hljs"># Define helper function
function my_diffusion(field, kappa)
    # Custom operation combining derivatives
    return kappa * Δ(field)
end

# Use programmatically
diffusion_term = my_diffusion(T, kappa)</code></pre><h3 id="Using-Built-in-Operators-in-Equations"><a class="docs-heading-anchor" href="#Using-Built-in-Operators-in-Equations">Using Built-in Operators in Equations</a><a id="Using-Built-in-Operators-in-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Built-in-Operators-in-Equations" title="Permalink"></a></h3><p>The equation parser recognizes all registered operators. Use them directly in equation strings:</p><pre><code class="language-julia hljs"># Available operators in equations:
# grad, div, curl, lap (or Δ), dt (or ∂t), d
# integrate, average, interpolate, convert, lift
# sin, cos, tan, exp, log, sqrt, abs, tanh

# Example: diffusion equation
add_equation!(problem, &quot;∂t(T) = kappa*Δ(T)&quot;)

# Example: advection-diffusion
add_equation!(problem, &quot;∂t(T) + u⋅∇(T) = kappa*Δ(T)&quot;)</code></pre><p>For complex expressions, compute terms programmatically and use the result:</p><pre><code class="language-julia hljs"># Compute complex term
rhs_term = kappa * Δ(T) - u * ∂x(T)

# Add to field&#39;s RHS
T.rhs .+= rhs_term.data</code></pre><hr/><h2 id="Equation-Parsing"><a class="docs-heading-anchor" href="#Equation-Parsing">Equation Parsing</a><a id="Equation-Parsing-1"></a><a class="docs-heading-anchor-permalink" href="#Equation-Parsing" title="Permalink"></a></h2><h3 id="Symbolic-Syntax"><a class="docs-heading-anchor" href="#Symbolic-Syntax">Symbolic Syntax</a><a id="Symbolic-Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Syntax" title="Permalink"></a></h3><p>Tarang.jl parses equation strings into operator applications:</p><pre><code class="language-julia hljs"># String equation
add_equation!(problem, &quot;∂t(u) + u*∂x(u) = nu*Δ(u) - ∂x(p)&quot;)

# Parsed as:
# LHS: ∂t(u) + u*∂x(u)
# RHS: nu*Δ(u) - ∂x(p)</code></pre><p><strong>Supported operations</strong>:</p><ul><li>Addition: <code>+</code></li><li>Subtraction: <code>-</code></li><li>Multiplication: <code>*</code></li><li>Division: <code>/</code></li><li>Parentheses: <code>(</code>, <code>)</code></li><li>Functions: <code>sin</code>, <code>cos</code>, <code>exp</code>, etc.</li></ul><h3 id="Operator-Evaluation"><a class="docs-heading-anchor" href="#Operator-Evaluation">Operator Evaluation</a><a id="Operator-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-Evaluation" title="Permalink"></a></h3><p>Operators are evaluated in spectral space when possible:</p><pre><code class="language-julia hljs"># ∂x(u): Multiply by ik in Fourier space
# Δ(u): Multiply by -k² in Fourier space
# Nonlinear terms: Transform to grid space, evaluate, transform back</code></pre><hr/><h2 id="Performance-Tips"><a class="docs-heading-anchor" href="#Performance-Tips">Performance Tips</a><a id="Performance-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Tips" title="Permalink"></a></h2><h3 id="Minimize-Grid-Spectral-Transforms"><a class="docs-heading-anchor" href="#Minimize-Grid-Spectral-Transforms">Minimize Grid-Spectral Transforms</a><a id="Minimize-Grid-Spectral-Transforms-1"></a><a class="docs-heading-anchor-permalink" href="#Minimize-Grid-Spectral-Transforms" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Bad: Multiple transforms
add_equation!(problem, &quot;∂t(T) = -u*∂x(T)&quot;)  # Transforms for each term

# Better: Group operations
# Tarang automatically optimizes transform grouping</code></pre><h3 id="Precompute-Common-Terms"><a class="docs-heading-anchor" href="#Precompute-Common-Terms">Precompute Common Terms</a><a id="Precompute-Common-Terms-1"></a><a class="docs-heading-anchor-permalink" href="#Precompute-Common-Terms" title="Permalink"></a></h3><pre><code class="language-julia hljs"># If using same derivative multiple times
dudx = ∂x(u)

add_equation!(problem, &quot;term1 = dudx&quot;)
add_equation!(problem, &quot;term2 = w*dudx&quot;)</code></pre><h3 id="Use-Sparse-Differentiation"><a class="docs-heading-anchor" href="#Use-Sparse-Differentiation">Use Sparse Differentiation</a><a id="Use-Sparse-Differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Use-Sparse-Differentiation" title="Permalink"></a></h3><p>Chebyshev/Legendre derivatives are sparse matrix operations - very efficient.</p><hr/><h2 id="See-Also"><a class="docs-heading-anchor" href="#See-Also">See Also</a><a id="See-Also-1"></a><a class="docs-heading-anchor-permalink" href="#See-Also" title="Permalink"></a></h2><ul><li><a href="../fields/">Fields</a>: Field types that operators act on</li><li><a href="../problems/">Problems</a>: Using operators in equations</li><li><a href="../domains/">Domains</a>: Spatial discretization for operators</li><li><a href="../bases/">Bases</a>: Spectral bases for differentiation</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fields/">« Fields API</a><a class="docs-footer-nextpage" href="../problems/">Problems API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and <a href="https://julialang.org">Julia</a>. Tarang.jl © 2024 Subhajit Kar.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 24 January 2026 12:02">Saturday 24 January 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
